<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<title>F29H85x-SDK: RAM-based UART SBL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="F29H85x-SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F29H85x-SDK
   &#160;<span id="projectnumber">1.02.02.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <span id="MSearchSelectExt">&#160;</span>
              <input type="text" id="MSearchField" name="query" value="" placeholder="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('EXAMPLES_DRIVERS_RAM_BASED_UART_SBL.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">RAM-based UART SBL</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md606">Introduction</a></li>
<li class="level1"><a href="#autotoc_md607">Getting Started</a></li>
<li class="level1"><a href="#autotoc_md608">Software Overview</a></li>
<li class="level1"><a href="#autotoc_md609">Build Configurations</a><ul><li class="level2"><a href="#autotoc_md610">Build Options</a></li>
<li class="level2"><a href="#autotoc_md611">Post Build Steps</a></li>
<li class="level2"><a href="#autotoc_md612">Memory Partition</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md613">Device Setup</a></li>
<li class="level1"><a href="#autotoc_md614">Available commands</a></li>
<li class="level1"><a href="#autotoc_md615">Example demonstration</a><ul><li class="level2"><a href="#autotoc_md616">Device Bringup</a></li>
<li class="level2"><a href="#autotoc_md617">Device Conversion from HS-FS to HS-KP</a></li>
<li class="level2"><a href="#autotoc_md618">Device Conversion from HS-KP to HS-SE</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md619">Addintional resource</a></li>
<li class="level1"><a href="#autotoc_md620">Help and Support</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_C_1_2anandyk_2C29_2SDK_2source__code_2c29__sdk__docs_2docs__src_2docs_2api__guide_2examples_2drivers_2ram__based__uart__sbl"></a></p>
<p>F29x RAM-based UART SBL example, formerly named UART Flash Kernel.</p>
<p>Located in F29H85X-SDK /examples/driverlib/single_core/flash/ram_based_sbl</p>
<h1><a class="anchor" id="autotoc_md606"></a>
Introduction</h1>
<p>This example serves as a bootloader that leverages UART boot to perform programming operations.</p>
<p>The UART Flash Programmer CLI is required to interface with the device via UART. More details are provided in the following sections.</p>
<h1><a class="anchor" id="autotoc_md607"></a>
Getting Started</h1>
<p>To fully understand this example, it is highly recommened to first review the foundational concepts outlined in the <a class="el" href="UART_FLASH_PROGRAMMER_PAGE.html">Uart Flash Programmer</a> document.</p>
<p>The document covers essential topics such as device lifecycle, firmware update methodologies (DFU,FOTA,LFU) and flash bank modes, which are prerequisites for a complete understanding of this SBL.</p>
<h1><a class="anchor" id="autotoc_md608"></a>
Software Overview</h1>
<p>The RAM-based UART Secondary Bootloader (SBL), in a nutshell, is an intermediate piece of code that runs in RAM. It is downloaded to the device by the UART Flash Programmer via UART boot. Once loaded, it receives commands from the flash programmer and performs the corresponding programming operations.</p>
<p>The primary purposes of the RAM-based UART SBL are:</p>
<ol type="1">
<li><b>Device bring-up</b><ul>
<li>Convert the device into HS-SE which enforces HSM &amp; SSU security.</li>
<li>Programs any CPU/HSM flash applications.</li>
</ul>
</li>
<li><b>Device Firmware Update (DFU)</b><ul>
<li>Supports both unsecure and secure (CP) programming.</li>
</ul>
</li>
</ol>
<p>For instructions on how to use the RAM-based SBL, refer to the "Example Demonstration" section.</p>
<h1><a class="anchor" id="autotoc_md609"></a>
Build Configurations</h1>
<p>The example provides configurations for both nonsecure programming and secure programming (KP &amp; CP), to a total of four build configurations:</p>
<table class="doxtable">
<tr>
<th colspan="2">RAM-based SBL build configuration  </th></tr>
<tr>
<td bgcolor="#F0F0F0">NONSECURE_DFU </td><td>• CPU Flash Programming <br  />
 • HS-FS only   </td></tr>
<tr>
<td bgcolor="#F0F0F0">SECURE_KP_AND_CP </td><td>• KP and CP <br  />
 • HS-FS, KP and SE <br  />
 • Requires RAM-based HSM runtime  </td></tr>
<tr>
<td bgcolor="#F0F0F0">SECURE_ONLY_KP </td><td>• Key Provision only <br  />
 • HS-FS or HS-KP <br  />
 • Requires RAM-based HSM runtime (OTP Keywriter)   </td></tr>
<tr>
<td bgcolor="#F0F0F0">SECURE_ONLY_CP </td><td>• Code Provision only <br  />
 • HS-KP or HS-SE <br  />
 • Requires RAM-based HSM runtime (CP services)   </td></tr>
</table>
<p><em>NONSECURE_DFU</em> contains the DFU operations via CPU's Flash API without HSM involvement. It can only be run on a device in HS-FS, where device security features are not enforced.</p>
<p><em>SECURE_KP_AND_CP</em> consolidates the key and code provisioning code to support the full device conversion from HS-FS to HS-KP and then to HS-SE. In contrast, the KP_ONLY configuration contains only the operations for converting to HS-KP, and the CP_ONLY configuration contains only the operations for converting and programming in HS-SE. See the "Available Commands" section for the supported operations for each.</p>
<p>While SECURE_KP_AND_CP can be seen as a superset of the other two and is recommended for development due to its simplicity, they differ in the available encryption options, as detailed in the "Post-Build Steps" section.</p>
<h2><a class="anchor" id="autotoc_md610"></a>
Build Options</h2>
<p>Two build options are provided in the <code>\ccs</code> folder: importing a CCS project or using a Makefile.</p>
<ul>
<li><b>CCS project</b>:<ul>
<li>In CCS, click on "Import CCS Projects..." and select "ram_based_uart_sbl"</li>
<li>Select the project and choose the desired build configuration.</li>
<li>Build the project "ram_based_uart_sbl", and it will produce a X.509 certificate prepended binary image <code>ram_based_uart_sbl.bin</code>.</li>
</ul>
</li>
<li><b>Makefile</b>:<ul>
<li>First, make sure all required Makefile dependency paths are properly set up (see <a class="el" href="MAKEFILE_BUILD_PAGE.html">Makefile based Build</a>)</li>
<li>To build the makefile, within <code>\ccs</code> folder, do:<ul>
<li>For NONSECURE_DFU config, use<code>Make -f ram_based_sbl.mk all</code></li>
<li>For SECURE_KP_AND_CP config, use <code>Make -f ram_based_sbl.mk all APP=SECURE</code></li>
<li>For SECURE_ONLY_KP config, use <code>Make -f ram_based_sbl.mk all APP=KP</code></li>
<li>For SECURE_ONLY_CP config, use <code>Make -f ram_based_sbl.mk all APP=CP</code></li>
</ul>
</li>
<li>It will a;sp produce a X.509 certificate prepended binary image <code>ram_based_uart_sbl.bin</code></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md611"></a>
Post Build Steps</h2>
<p>The post-build step is responsible for converting the generated .out file into a binary image and prepending it with an X.509 certificate. While all configurations follow a similar flow, each uses slightly different certificate generation parameters due to different authentication requirements for device boot.</p>
<ul>
<li>NONSECURE_DFU<ul>
<li>In HS-FS, no authentication is required, so any dummy certificate will suffice <div class="fragment"><div class="line">NONSECURE_DFU</div>
<div class="line">$(PYTHON) ${COM_TI_MCU_SDK_INSTALL_DIR}/tools/boot/signing/mcu_rom_image_gen.py --image-bin ${ProjName}.temp.bin --core C29 --swrv 1 --loadaddr 0x200E1000 --sign-key ${COM_TI_MCU_SDK_INSTALL_DIR}/$(SIGNING_KEY) --out-image ${ProjName}.bin --boot RAM --device f29h85x --debug DBG_SOC_DEFAULT;</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>SECURE_KP_AND_CP<ul>
<li>The key used for signing must match the user key programmed on the device</li>
<li>Imagine integrity checks enabled <div class="fragment"><div class="line">SECURE_KP_AND_CP</div>
<div class="line">$(PYTHON) ${COM_TI_MCU_SDK_INSTALL_DIR}/tools/boot/signing/mcu_rom_image_gen.py --image-bin ${ProjName}.temp.bin --core C29 --swrv 1 --loadaddr 0x200E1000 --sign-key ${COM_TI_MCU_SDK_INSTALL_DIR}/$(SIGNING_KEY) --out-image ${ProjName}.bin --boot RAM --device f29h85x --debug DBG_SOC_DEFAULT --img_integ yes;</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>SECURE_ONLY_KP<ul>
<li>The key used for signing must match the user key programmed on the device</li>
<li>Imagine integrity checks enabled <div class="fragment"><div class="line">SECURE_ONLY_KP</div>
<div class="line"> $(PYTHON) ${COM_TI_MCU_SDK_INSTALL_DIR}/tools/boot/signing/mcu_rom_image_gen.py --image-bin ${ProjName}.temp.bin --core C29 --swrv 1 --loadaddr 0x200E1000 --sign-key ${COM_TI_MCU_SDK_INSTALL_DIR}/$(SIGNING_KEY) --out-image ${ProjName}.bin --boot RAM --device f29h85x --debug DBG_SOC_DEFAULT --img_integ yes;</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>SECURE_ONLY_CP<ul>
<li>The key used for signing must match the user key programmed on the device</li>
<li>Imagine integrity checks enabled</li>
<li>SBL encryption enabled w/ key-derivation salt <div class="fragment"><div class="line">SECURE_ONLY_CP</div>
<div class="line">$(PYTHON) ${COM_TI_MCU_SDK_INSTALL_DIR}/tools/boot/signing/mcu_rom_image_gen.py --image-bin ${ProjName}.temp.bin --core C29 --swrv 1 --loadaddr 0x200E1000 --sign-key ${COM_TI_MCU_SDK_INSTALL_DIR}/$(SIGNING_KEY) --out-image ${ProjName}.bin --boot RAM --device f29h85x --debug DBG_SOC_DEFAULT --img_integ yes --sbl-enc --enc-key ${COM_TI_MCU_SDK_INSTALL_DIR}/tools/boot/signing/mcu_custMek.key --kd-salt ${COM_TI_MCU_SDK_INSTALL_DIR}/tools/boot/signing/kd_salt.txt;</div>
</div><!-- fragment --></li>
</ul>
</li>
</ul>
<p>The biggest difference between SECURE_KP_AND_CP and SECURE_ONLY_CP is that the latter supports image encryption (via SMEK/BMEK), whereas the former does not, since image encryption is not supported on an HS-FS device.</p>
<p>Therefore, if the SBL image and its X.509 certificate are considered secret, using two separate KP and CP SBL images is preferred. The KP SBL can be kept internal to burn the key into the device, and the encrypted CP SBL can be safely distributed to external parties for any field programming.</p>
<p>By default, all certificate generation examples use mcu_custMek.key as the signing key. It is recommended to first conduct the device conversion exercise to HS-SE using this default signing key.</p>
<h2><a class="anchor" id="autotoc_md612"></a>
Memory Partition</h2>
<p>In peripheral UART boot, the maximum size of the RAM bootloader is limited to 98 KB, which includes:</p>
<ul>
<li>65KB LPAx RAM<ul>
<li>0x10000 bytes</li>
<li>executable RAM</li>
</ul>
</li>
<li>32KB CPA0 RAM<ul>
<li>0x8000 bytes</li>
<li>non-executable RAM</li>
</ul>
</li>
</ul>
<p>Therefore, executable code is limited to the size of LPAx RAM, unless it is stored in CPA0 and copied to uninitialized executable memory (LDAx RAM) via a linker copy table or memcpy.</p>
<p>Below is the F29H85x memory layout in peripheral boot mode:</p>
<p>(R-read, W-write, I-initialize, X-execute)</p><ul>
<li>LDAx RAM (RWX)<ul>
<li>Accessible by CPU1 &amp; HSM</li>
<li>LDA7 - LDA2 reserved by RAM-based HSM runtime</li>
<li>LDA1 - LDA0 used by RAM-based SBL</li>
</ul>
</li>
<li>LPAx RAM (RWIX)</li>
<li>CPA0 RAM (RWI)</li>
<li>CPA1 RAM (RW)</li>
<li>CDAx RAM (RW)</li>
</ul>
<p>LDAx is unique due to its shared access between the SBL (running on CPU1) and the HSM. LDA7-2 are reserved for the RAM-based HSM runtime, which provides services for secure programming. During these services, the HSM must access objects passed from the CPU via Secure IPC. Therefore, the security libraries included by the SBL, which consist of HSM client calls and SIPC functions, must reside in LDAx for the HSM to access them, along with the SBL stack.</p>
<p>For this reason, the SBL's <b>LDA1</b> RAM is solely reserved as a scratchpad to pass programming/authentication data to the HSM, while <b>LDA0</b> RAM contains the security library, stack, and any HSM-accessible global variables. This memory configuration is retained for the unsecure configuration as well, with LDA1 used to store the certificate and Flash API to further utilize the scratchpad and save LPAx RAM space.</p>
<div class="fragment"><div class="line">sbl_ramopen_lnk.cmd</div>
<div class="line"> </div>
<div class="line">    /* LDA1 is reserved as a scratchpad to pass in rcvd img to HSMRT for authentication (KP &amp; CP) or to store Fapi (DFU, or program bankmodes in KP/CP with mannual copy to re-populate the library) */   </div>
<div class="line">    UNION: RUN = SRAM_LDA1</div>
<div class="line">    {</div>
<div class="line">        secure_scratchpad : { . = . + 0x4000; } /* Map HSM authenticate data to HSM accessible region */</div>
<div class="line">        GROUP: </div>
<div class="line">        {</div>
<div class="line">            cert_scratchpad : { . = . + 0x1000; }</div>
<div class="line">    /* Due to limited LPAx space (initalized and executable RAM), store fapi in CPA0 (non-executable) and *manually* copy_in &amp; run in LDA1 (scratchpad) when needed */</div>
<div class="line">            fapi         : {&quot;*F29H85x_NWFlashAPI*.lib&quot;(.text)} LOAD=SRAM_CPA0, table(fapiCopyTable)</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    hsmlib       : {&quot;*security_drivers.lib&quot;(.text)} RUN=SRAM_LDA0, LOAD=SRAM_CPA0, table(BINIT) /* Map HSMClient and SIPC funcs to HSM accessible region (LDAx) */</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md613"></a>
Device Setup</h1>
<p>The SBL UART TX/RX pins are mapped to GPIO 42/43, which are also the default pins for UART boot and Flash-based UART SBL in F29H85x .</p>
<ul>
<li>On the <b>F29H85x SOM</b>, GPIO 42/43 are routed to the UART extension pins of the XDS110 JTAG debugger, therefore no addintional setups are required.</li>
<li>On the <b>F29H85x Launchpad</b>, GPIO 42/43 are exposed as standard GPIO headers, and an UART transeciver is needed to connect the device with the host PC.</li>
</ul>
<h1><a class="anchor" id="autotoc_md614"></a>
Available commands</h1>
<p>The list below shows the commands supported by the UART Flash Programmer for the RAM-based SBL configurations:</p>
<p><b>Unsecure</b>:</p><ul>
<li>CPU1 DFU/FOTA</li>
<li>CPU3 DFU/FOTA</li>
<li>Set Bankmode 0</li>
<li>Set Bankmode 1</li>
<li>Set Bankmode 2</li>
<li>Set Bankmode 3<ul>
<li>Note: all bankmode commands are for development only, as data integrity are not presevered after mode switch. It's recommened to switch bank mode prior to any programming operation.</li>
</ul>
</li>
</ul>
<p><b>KP</b>:</p><ul>
<li>Load HSM RAM Image</li>
<li>Load HSM Key</li>
</ul>
<p><b>CP</b>:</p><ul>
<li>Load HSM RAM Image</li>
<li>Program Sec Cfg</li>
<li>Load HSM Flash Image</li>
<li>Load C29 CPU1 Image</li>
<li>Load C29 CPU3 Image</li>
</ul>
<p><b>Utility commands</b>:</p><ul>
<li>Sync Device Status</li>
<li>Get SocID Info</li>
<li>Get Boot ROM Status</li>
<li>Run CPU3</li>
<li>Reset CPU1</li>
<li>Configure UART Baud Rate</li>
</ul>
<h1><a class="anchor" id="autotoc_md615"></a>
Example demonstration</h1>
<p>This section and following subsections provides a walkthrough for a complete device bring-up.</p>
<p>It is recommened to perform these exercises first with the default signing key (<b>mcu_custMek.pem</b>), used by all the related examples to sign the required images.</p>
<dl class="section attention"><dt>Attention</dt><dd>For more information on HSM security software, please request access to the TIFS-SDK for F29H85x , available on the same TI download page as F29H85X-SDK for F29H85x .</dd></dl>
<h2><a class="anchor" id="autotoc_md616"></a>
Device Bringup</h2>
<p>A complete device bring-up encompasses all operations needed for a production program, including device conversion from its initial HS-FS to a fully secure HS-SE type, bank mode changes, programming Sec Cfg and CPU, HSM flash.</p>
<p>To perform a complete device bring-up and in fewest steps, follow the steps in chronological order:</p>
<p>Device in HS-FS:</p><ol type="1">
<li>Load RAM-based SBL</li>
<li>Set flash bank mode (if applicable)</li>
<li>Load HSM RAM image (OTP keywriter)</li>
<li>Program Key</li>
<li>Power-on Reset (PORSn)</li>
</ol>
<p>Device in HS-KP:</p><ol type="1">
<li>Load RAM-based SBL</li>
<li>Load HSM RAM image (CP services)</li>
<li>Program Sec Cfg</li>
<li>Program CPU1,3 &amp; HSM flash<ul>
<li>In no particular order</li>
</ul>
</li>
<li>Power-on Reset (PORSn)</li>
</ol>
<p>See the following subsections on step-by-step instructions in converting the device to HS-KP and HS-SE.</p>
<h2><a class="anchor" id="autotoc_md617"></a>
Device Conversion from HS-FS to HS-KP</h2>
<p>Device conversion from HS-FS to HS-KP is done through Key Provision (KP).</p>
<p>A. Preparation:</p>
<p>First, prepare the following:</p><ol type="1">
<li><b>RAM-based SBL binary</b><ul>
<li>Can use either SECURE_KP_AND_CP or SECURE_ONLY_KP configuration</li>
<li>Prepended w/ X.509 cert</li>
<li>Any dummy certificate will suffice, as no boot authentication is performed in HS-FS</li>
</ul>
</li>
<li><b>RAM-based HSM image</b> w/ OTP Keywriter service</li>
<li><b>User key</b><ul>
<li>SMPK/SMEK &amp; BMPK/BMEK</li>
</ul>
</li>
</ol>
<p>B. Dry Run vs Key Writer Mode:</p>
<p>By default, RAM-based SBL operates in <em>DRYRUN_MODE</em>. This mode simulates the key writing process and produces verification logs without permanently program the OTP eFuse. It's <b>strongly recommened</b> to perform a successsful dry run first to validate your setups, tools and the provided keys before making irreversible changes.</p>
<p>Once you have verified the process with a dry run, modify the source code to reflect <code>certHeader.reserved = KEYWRITER_MODE</code> in sbl_key_provision.c. Rebuild the SBL and run through the flash programmer steps again.</p>
<div class="fragment"><div class="line">sbl_key_provision.c : provisionKeys()</div>
<div class="line"> </div>
<div class="line">    /*</div>
<div class="line">        !!!IMPORTANT!!!</div>
<div class="line">        The default mode is DRYRUN_MODE. **No conversion** occurs in this mode.</div>
<div class="line">        To convert a device change the certHeader.reserved field below to KEYWRITER_MODE .</div>
<div class="line">    */</div>
<div class="line">    certHeader.reserved = DRYRUN_MODE;</div>
<div class="line">    //certHeader.reserved = KEYWRITER_MODE;</div>
</div><!-- fragment --><p>C. Run the UART Flash Programmer</p>
<ol type="1">
<li>Load the RAM-based SBL through UART Flash Programmer<ul>
<li>See "Peripheral UART boot" section of <a class="el" href="UART_FLASH_PROGRAMMER_PAGE.html">Uart Flash Programmer</a> for UART boot instruction.</li>
<li>The command syntax is as follows: <div class="fragment"><div class="line">uart_flash_programmer.exe -d f29h85x -p &lt;COM port&gt; -k ram_based_uart_sbl.bin --hsmrt &lt;OTP Keywriter&gt; --hsmkeys &lt;User key&gt;</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>(Optional) Once SBL is loaded, if flash bank mode needs to be changed, select <b>Set bankmode</b>.<ul>
<li>Set bankmode is currently only available for HS-FS at the moment.</li>
<li>Bank mode changes will only be reflected upon device reset, user can check the bank mode via <b>Get Boot ROM Status</b> command.</li>
</ul>
</li>
<li><p class="startli">Select the option for <b>Loading HSM RAM Image</b>. The log should confirm that the OTP Keywriter service is active.</p>
<p class="startli"> <style>div.image img[src="hsmrt_otp_service.png"]{width:80%}</style> </p><div class="image">
<img src="hsmrt_otp_service.png" alt=""/>
<div class="caption">
RAM-based HSM Image OTP Keywriter Log</div></div>
</li>
<li>Next, select the option to <b>Load HSM Key</b>. After a successful key write, the device will be in HS-KP upon the next device reset. Do a power-on reset to prepare converting to HS-SE in the next section.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Due to ROM restriction, RAM-based HSM runtime images cannot be unloaded nor reloaded without a <b>power-on reset (PORSn)</b> . As such, power-on reset the device each time a HSM RAM image needs to be loaded, to avoid seeing the below error message.</dd></dl>
<p> <style>div.image img[src="hsmrt_error.png"]{width:80%}</style> </p><div class="image">
<img src="hsmrt_error.png" alt=""/>
<div class="caption">
RAM-based HSM Image Reload Error</div></div>
<h2><a class="anchor" id="autotoc_md618"></a>
Device Conversion from HS-KP to HS-SE</h2>
<p>Device conversion from HS-KP to HS-SE is done through Code Provision (CP).</p>
<p>A. Preparation:</p>
<p>First, prepare the following:</p><ol type="1">
<li><b>RAM-based SBL binary</b><ul>
<li>Can use either SECURE_KP_AND_CP or SECURE_ONLY_CP config</li>
<li>Prepended w/ X.509 cert</li>
<li>The certificate must be signed with the user key</li>
</ul>
</li>
<li><b>RAM-based HSM image</b> w/ CP services<ul>
<li>Prepended w/ X.509 cert</li>
<li>The certificate must be signed with the user key</li>
</ul>
</li>
<li><b>Sec Cfg image</b> <br  />
<ul>
<li>SSU security configuration</li>
<li>See #EXAMPLES_SSU_MODE2 post-build step on generating the Sec Cfg image</li>
<li>A pre-generated image with default settings and default mcu_custMek.pem is provided for checkout in F29H85X-SDK /source/defseccfgbin/</li>
</ul>
</li>
</ol>
<p>B. Run the UART Flash Programmer</p>
<ol type="1">
<li>After a power-on reset, load the RAM-based SBL.<ul>
<li>The command syntax is: <div class="fragment"><div class="line">uart_flash_programmer.exe -d f29h85x -p &lt;COM port&gt; -k ram_based_uart_sbl.bin --hsmrt &lt;CP services&gt; --cpseccfg &lt;sec cfg&gt; [optional parameter: --cpappcpu1 &lt;cpu1 flash img&gt; --cpappcpu3 &lt;cpu3 flash img&gt; --cpapphsm &lt;hsm flash img&gt;]</div>
</div><!-- fragment --></li>
</ul>
</li>
<li><p class="startli">Select the option for <b>Loading HSM RAM Image</b>. The log should confirm that the standard CP services are loaded.</p>
<p class="startli"> <style>div.image img[src="hsmrt_cp_service.png"]{width:80%}</style> </p><div class="image">
<img src="hsmrt_cp_service.png" alt=""/>
<div class="caption">
RAM-based HSM Image CP Services Log</div></div>
</li>
<li>Next, select the option to <b>PRogram Sec Cfg</b>, it is recommened to program Sec Cfg <em>before</em> other flash applications (CPU or HSM).</li>
<li>After successfully programming the Sec Cfg, you can proceed to program CPU1, CPU3 and HSM flash applications as needed.</li>
<li>Perform a final device reset. The device is now in HS-SE.<ul>
<li>All CP commands supports reprogrammed once in HS-SE, follow the same steps here for RAM-based SBL.</li>
</ul>
</li>
</ol>
<p>C. Verification:</p>
<p>One can verify the device status by reloading the SBL and using the utility commands.</p>
<ul>
<li><b>Get Boot ROM Status</b>: This will show the device type as HS_SE, SSU mode as the Sec Cfg setting and Sec Cfg has transitioned from "Default Active" to "Alternate Active" (or vise versa). The reset count will also be zeroed to indicate a device lifecycle transition.</li>
</ul>
<p> <style>div.image img[src="uart_seccfg_active.png"]{width:80%}</style> </p><div class="image">
<img src="uart_seccfg_active.png" alt=""/>
<div class="caption">
Boot ROM Status Log with HS_SE and Sec Cfg status</div></div>
<ul>
<li><b>Get SoC ID Info</b>: This will show that the Root-of-Trust is now active on the user S-Key with SMPK hash.</li>
</ul>
<p> <style>div.image img[src="socid_redacted.png"]{width:80%}</style> </p><div class="image">
<img src="socid_redacted.png" alt=""/>
<div class="caption">
SoC ID info with HSM key status</div></div>
<h1><a class="anchor" id="autotoc_md619"></a>
Addintional resource</h1>
<ul>
<li>Refer to <a href="https://www.ti.com/lit/pdf/spradn0">Serial Flash Programming for F29x Device</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md620"></a>
Help and Support</h1>
<p>For additional help and support, please visit <a href="https://e2e.ti.com/support/microcontrollers/c2000-microcontrollers-group/c2000/f/c2000-microcontrollers-forum" target="_blank"><em>E2E™ design support forum</em></a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
