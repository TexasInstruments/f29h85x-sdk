<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<title>F29H85x-SDK: CAN Flash Programmer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="F29H85x-SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F29H85x-SDK
   &#160;<span id="projectnumber">1.02.02.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <span id="MSearchSelectExt">&#160;</span>
              <input type="text" id="MSearchField" name="query" value="" placeholder="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('CAN_FLASH_PROGRAMMER_PAGE.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">CAN Flash Programmer</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md1254">Introduction</a></li>
<li class="level1"><a href="#autotoc_md1255">CAN Setting</a></li>
<li class="level1"><a href="#autotoc_md1256">Build from source</a></li>
<li class="level1"><a href="#autotoc_md1257">Precompiled executables</a></li>
<li class="level1"><a href="#autotoc_md1258">Device Types (Device Lifecycle)</a><ul><li class="level2"><a href="#autotoc_md1259">Device Conversion</a></li>
<li class="level2"><a href="#autotoc_md1260">KP &amp; CP</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md1261">Flash Bank Modes</a></li>
<li class="level1"><a href="#autotoc_md1262">DFU, FOTA and LFU</a></li>
<li class="level1"><a href="#autotoc_md1263">RAM vs Flash-based SBL</a></li>
<li class="level1"><a href="#autotoc_md1264">Running the program</a></li>
<li class="level1"><a href="#autotoc_md1265">Peripheral CAN boot</a></li>
<li class="level1"><a href="#autotoc_md1266">Generating Combined Image with X.509 Certificate</a></li>
<li class="level1"><a href="#autotoc_md1267">Flash Programmer Supported Parameters</a></li>
<li class="level1"><a href="#autotoc_md1268">Flash Programmer Operations</a></li>
<li class="level1"><a href="#autotoc_md1269">Changelog</a></li>
<li class="level1"><a href="#autotoc_md1270">Addintional resource</a></li>
<li class="level1"><a href="#autotoc_md1271">Help and Support</a></li>
<li class="level1"><a href="#autotoc_md1272">API usage</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_C_1_2anandyk_2C29_2SDK_2source__code_2c29__sdk__docs_2docs__src_2docs_2api__guide_2components_2tools_2can__flash__programmer"></a></p>
<p>Texas Instruments F29x CAN Flash Programmer CLI Example Package</p>
<p>Located in F29H85X-SDK /flash_programmers/can_flash_programmer</p>
<h1><a class="anchor" id="autotoc_md1254"></a>
Introduction</h1>
<p>This page provides a brief rundown of the F29x CAN Flash Programmer.</p>
<p>The CAN Flash Programmer is a command-line interface (CLI) tool that runs on a PC and communicates with an F29x device via MCAN. It can be used to load firmware<sup>1</sup> via CAN boot mode. It can also communicate with a CAN secondary bootloader (SBL) running on the device to perform more advanced operations, such as programming the device's flash memory. See <a class="el" href="EXAMPLES_DRIVERS_FLASH_BASED_CAN_SBL_WITH_FOTA.html">Flash-based CAN SBL</a> for more detail.</p>
<p>The Flash Programmer CLI is supported on Windows and Linux operating systems. Precompiled executables are included for Windows, and a CMake build script is provided for Linux.</p>
<blockquote class="doxtable">
<p>&zwj;1. In HS-FS (High Security - Field Securable) state, boot authorization is disabled, and a special mode called RAMOPEN is enforced, which prevents instructions from executing in flash. Therefore, RAM-based SBL is used for peripheral boot to receive and execute Flash Programmer commands.</p><ul>
<li>For more information, please see the "RAMOPEN Feature" of the ROM section in the F29H85x Technical Reference Manual (TRM). </li>
</ul>
</blockquote>
<h1><a class="anchor" id="autotoc_md1255"></a>
CAN Setting</h1>
<p>THe CAN Flash Programmer uses PCAN-Basic API from PEAK system. As such, a PEAK transceiver is required to connect the Host PC to the CAN Bus. The CAN Flash Programmer was tested using PCAN-USB FD, and the CAN channel was hardcoded to PCAN_USBBUS1.</p>
<p>If other PCAN interfaces were used, please adjust the settings in <a class="el" href="can__flash__programmer_8cpp.html" title="Host-side Flash Programmer cli for firmware upgrades and other uility options via CAN.">can_flash_programmer.cpp</a>, and follow the next section to build from source.</p>
<div class="fragment"><div class="line">can_flash_programmer.cpp</div>
<div class="line"> </div>
<div class="line">    //</div>
<div class="line">    // PCAN channel and CAN-FD parameter settings</div>
<div class="line">    //</div>
<div class="line">    TPCANHandle channel;</div>
<div class="line">    TPCANBitrateFD bitRateCanFD;</div>
<div class="line">    channel = PCAN_USBBUS1;</div>
<div class="line">    bitRateCanFD = (char*)&quot;f_clock_mhz=20, nom_brp=5, nom_tseg1=2, nom_tseg2=1, nom_sjw=1, data_brp=2, data_tseg1=3, data_tseg2=1, data_sjw=1&quot;; // Nomial 1Mbps and Data 2Mbps</div>
</div><!-- fragment --><p>Within the software, with the exception of the CAN Bootloader in <a class="el" href="CanDownload_8cpp.html" title="High-level CAN workflow (download host image to target)">CanDownload.cpp</a> (Boot ROM expects CAN Frame ID to be 1 with fixed attributes). The programmer sends its CAN frame with ID of 0xF in CAN_FD, and can be adjusted in <a class="el" href="CanInterface_8h.html" title="Includes low-level abstraction interface function to UART serial port.">include/CanInterface.h</a>.</p>
<div class="fragment"><div class="line">include/CanInterface.h</div>
<div class="line"> </div>
<div class="line">    // Change this setting to alter the properties of the can frame sent.</div>
<div class="line">    const TPCANMsgFD defaultCanFDMsgSetting = { .ID = 0xF , .MSGTYPE = PCAN_MESSAGE_STANDARD | PCAN_MESSAGE_FD | PCAN_MESSAGE_BRS };</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1256"></a>
Build from source</h1>
<p>Two methods are provided to compile the source code found under <code>/src</code> directory:</p>
<ul>
<li>(Windows only) VS Project : User should import <code>can_flash_programmer.sln</code> into Visual Studio and build the project.</li>
<li>(Linux &amp; Windows) CMake: A CMakeLists.txt file is provided to build the project using CMake.<ol type="1">
<li>Use <code>build_cmake.sh</code> to automate CMake build<ul>
<li>Do <code>chmod +x build_cmake.sh &amp;&amp; ./build_cmake.sh</code></li>
</ul>
</li>
<li>Manual instructions on building CMake:<ul>
<li>In the terminal, proceed to create a build folder and cd into folder via<ul>
<li><code>mkdir build &amp;&amp; cd build</code></li>
</ul>
</li>
<li>Generate CMake artifacts via<ul>
<li><code>cmake -S .. -DCMAKE_BUILD_TYPE={Debug/Release}</code></li>
</ul>
</li>
<li>Build the CMake project via<ul>
<li><code>cmake --build .</code></li>
</ul>
</li>
<li>The generated executable would be called <em>can_flash_programmer</em> under the build folder</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>The program requires the PCAN-basic dynamic library to be discoverable and loaded in runtime. Therefore, if the programmer CLI is to be moved to a different directory, then please do one of the following:</p><ul>
<li>Append the enviroment variable (<code>PATH</code> for Windows and <code>LB_LIBRARY_PATH</code> for Linux) with the path to the PCAN-basic.dll or libpcanbasic.so.</li>
<li>(Windows only) Have a copy of PCAN-basic.dll placed in the same folder as the exe</li>
<li>(Linux only) Set the program's RPATH to a static location by editing CMakeList.txt and add <code>set(CMAKE_INSTALL_RPATH "libpath"</code><ul>
<li>If a relative RPATH is desired, then format the path with <code>$\\{ORIGIN\\}/libpath</code> instead</li>
</ul>
</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>Even though a precompiled PCAN-Basic lib (x86_64) is provided in linux, it's recommeneded for users to download the PCAN-Linux driver <a href="https://www.peak-system.com/fileadmin/media/linux/index.php#Section_Driver-Proproetary" target="_blank"><em>here</em></a> and follow the package instruction to compile a PCAN-Basic lib using the <em>chardev API</em>.<ul>
<li>copy the generated <code>libpcanbasic.so.&lt;version&gt;</code> into <code>can_flash_programmer/src/lib/pcan_linux/lib/</code> folder</li>
<li>cd into the folder, and add symbolic link against existing libpcanbasic.so<ul>
<li>e.g. <code>ln -s libpcanbasic.so.* libpcanbasic.so</code></li>
</ul>
</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="autotoc_md1257"></a>
Precompiled executables</h1>
<p>Two versions of the precompiled Windows executable are provided for this example:</p><ul>
<li>CAN_flash_programmer.exe (x86_64)<ul>
<li>Peripheral(CAN) boot is <em><b>enabled</b></em> at startup<ul>
<li>The program will start by sending the RAM-based SBL image to the device in CAN boot mode, after which the ROM will hand off device control to the SBL. The user will then be prompted with options to communicate with the SBL running on the device.</li>
<li>Note: As dictated by the ROM flow, peripheral boot must occur before any subsequent HSM operations for Key Provisioning (KP) and Code Provisioning (CP) when using the RAM-based SBL. For more information on the ROM and its prerequisite setup, please refer to the "ROM bootloader" section of the Application Note.</li>
</ul>
</li>
<li>If a custom SBL is used without Flash Programmer's packet protocol, <em><code>--boot-only</code></em> parameter can be added to only load the SBL in CAN boot and exit.</li>
</ul>
</li>
<li>CAN_flash_programmer_appIn.exe (x86_64)<ul>
<li>Peripheral(CAN) boot is <em><b>disabled</b></em><ul>
<li>The program will bypass the peripheral boot step and directly prompt the user with the available options.</li>
<li>This requires that the SBL is already <b>running</b> on the device, such as Flash-based SBL.</li>
<li>To achieve this in a custom build, undefine the macro <em><code>ENABLE_PERIPHERAL_BOOT</code></em> in include/Common.h</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">include/Common.h</div>
<div class="line"> </div>
<div class="line">//</div>
<div class="line">// Define the macro to download ram-based sbl image to the device via periperial (CAN) boot mode. Occurs during program startup.</div>
<div class="line">// It&#39;s the only difference between (non-appIn vs appIn) precompiled executable</div>
<div class="line">//</div>
<div class="line">#define ENABLE_PERIPHERAL_BOOT</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Although precompiled executables are not provided for Linux, they can be easily generated by editing include/Common.h with the desired configuration and running the build_cmake.sh script as described previously.</dd></dl>
<h1><a class="anchor" id="autotoc_md1258"></a>
Device Types (Device Lifecycle)</h1>
<p>F29H85x device progress through a lifecycle defined by their security state. The following table lists the MCU device types (also known as device lifecycles) and their corresponding security policies:</p>
<table class="doxtable">
<tr>
<th colspan="2">F29x Device Type   </th></tr>
<tr>
<td><b>HS-FS</b> <br  />
 (High Security - Field Securable)  </td><td>• No authentication on device boot <br  />
 • No device security features are enforced except load HSM auth <br  />
 • No SSU Security Configuration protection  </td></tr>
<tr>
<td><b>HS-KP</b> <br  />
 (High Security - Key Provisioned)  </td><td>• Requires authentication on device boot <br  />
 • Device security features are enforced <br  />
 • SSU security configuration are cleared and uses default settings <br  />
 • A temporary state prior to HS-SE   </td></tr>
<tr>
<td><b>HS-SE</b> <br  />
 (High Security - Security Enforced)  </td><td>• Requires authentication on device boot <br  />
 • Device security features are enforced <br  />
 • SSU security configuration are configured and is protected by HSM<sup>2</sup> <br  />
 • Secure boot enabled and Root-of-Trust on user key  </td></tr>
</table>
<blockquote class="doxtable">
<p>&zwj;2. While the Hardware Security Module (HSM) is independent of the Safety and Security Unit (SSU), which governs the C29x CPU and memory security model via its security configuration, the HSM does validate and protect the Security Configuration when device security features are enabled. </p><blockquote class="doxtable">
<p>&zwj;For more information. Refer to the SSU section of the F29H85x TRM. </p>
</blockquote>
</blockquote>
<h2><a class="anchor" id="autotoc_md1259"></a>
Device Conversion</h2>
<p>By default, any out-of-the-box device is in the HS-FS state. This indicates that the device comes with the manufacturer's key, and no HSM security features are enforced. In the HS-FS state, the CPU is permitted to directly program its flash banks without the HSM, and is denoted as unsecure programming.</p>
<p>Device conversion from HS-FS to HS-SE is performed through provisioning, two operations must be conducted:</p>
<ol type="1">
<li>Provision the deivce with a custom key</li>
<li>Flash SSU Security Configuration (Sec Cfg BLOB)</li>
</ol>
<p>The first operation is known as Key Provisioning (KP), which converts an HS-FS device into a temporary HS-KP state.</p>
<p>The second operation is part of Code Provisioning (CP), which converts an HS-KP device into an HS-SE device with full device, CPU, and memory security enabled.</p>
<h2><a class="anchor" id="autotoc_md1260"></a>
KP &amp; CP</h2>
<p><em>Key Provision</em> (HS-FS to HS-KP):</p>
<p>&#160;&#160;&#160;&#160; During Key Provisioning, the user can replace the TI-provided key with a custom private key via OTP Keywriter service. Once a new custom key is provisioned successfully, the device converts to the HS-KP state after a power-on reset (PORSn). Authentication is now enforced, and the user must supply the correct X.509 certificate-appended binary images, security configurations, or keys to pass authentication for future operations.</p>
<p><em>Code Provision</em> (HS-KP/SE to HS-SE):</p>
<p>&#160;&#160;&#160;&#160; Code Provisioning encompasses the secure flashing of the Sec Cfg, CPU flash, and HSM flash, all of which require HSM authentication and validation. In the HS-KP state, successfully programming the Security Configuration will convert the device to HS-SE after a power-on reset (PORSn). Although the order of flashing operations is not strictly enforced, it is recommended to flash the Sec Cfg first, followed by the HSM flash and then the CPU flash. Code Provisioning supports all flash bank modes.</p>
<p>The CAN Flash Programmer CLI and RAM-based CAN SBL supports Key and Code Provisioning as available options.</p>
<dl class="section attention"><dt>Attention</dt><dd>For more information regarding HSM security software, security features, and the provisioning flow in detail, please request access to the TIFS-SDK for F29H85x , available on the same TI download page as the F29H85X-SDK for F29H85x .</dd></dl>
<h1><a class="anchor" id="autotoc_md1261"></a>
Flash Bank Modes</h1>
<p>The following is a brief summary of the F29H85x device flash bank modes:</p>
<p>(For F29H85x devices with smaller flash configurations, reduce each flash size by the same ratio.)</p>
<table class="doxtable">
<tr>
<th colspan="2">F29H85x Bank modes   </th></tr>
<tr>
<td>Mode 0 </td><td>• Bank swap disabled <br  />
 • CPU1 4MB flash <br  />
 • CPU3 flash disabled   </td></tr>
<tr>
<td>Mode 1 </td><td>• Bank swap enabled <br  />
 • CPU1 2MB flash <br  />
 • CPU3 flash disabled   </td></tr>
<tr>
<td>Mode 2 </td><td>• Bank swap disabled <br  />
 • CPU1 2MB flash <br  />
 • CPU3 2MB flash   </td></tr>
<tr>
<td>Mode 3 </td><td>• Bank swap enabled <br  />
 • CPU1 1MB flash <br  />
 • CPU3 1MB flash   </td></tr>
</table>
<p>By default, an out-of-box device is in mode 0.</p>
<dl class="section attention"><dt>Attention</dt><dd>For more information on flash bank modes and their allocated addresses, refer to the F29H85x device datasheet.</dd></dl>
<h1><a class="anchor" id="autotoc_md1262"></a>
DFU, FOTA and LFU</h1>
<p>Throughout various documents, these terms are used to represent different firmware upgrade terminologies. In the context of F29H85x , they are described as follows:</p>
<p><em>Device Firmware Upgrade (DFU)</em>:</p><ul>
<li>Programming directly to active flash banks. No firmware can run from flash during DFU.<ul>
<li>No flash bank mode restrictions</li>
</ul>
</li>
<li>Performs the firmware upgrade via a device reset (CPU1.WDRSn, CPU1.SYSRSn, XRSn, PORSn) in flash boot or a branch instruction to the flash entry point.<ul>
<li>Note: When using peripheral boot in the HS-FS state, RAMOPEN is enforced, which prevents instructions from executing in flash. Therefore, the user must perform a device reset.</li>
</ul>
</li>
</ul>
<p><em>Firmware Over-The-Air (FOTA)</em>:</p><ul>
<li>Programming to dormant flash whilst user application is running.<ul>
<li>Bank mode 1 &amp; 3 only</li>
</ul>
</li>
<li>Performs the firmware upgrade via a device reset (CPU1.WDRSn, CPU1.SYSRSn, XRSn, PORSn) in flash boot.</li>
</ul>
<p><em>Live Firmware Upgrade (LFU)</em>:</p><ul>
<li>Programming to dormant flash whilst user application is running.<ul>
<li>Bank mode 1 &amp; 3 only</li>
</ul>
</li>
<li>Performs the firmware upgrade whilst user application is running.<ul>
<li>Addintional restrictions apply due to timing constraint of live firmware switching.</li>
</ul>
</li>
</ul>
<p>The most relevant firmware upgrade method depends on the service model and end-user application requirements.</p>
<h1><a class="anchor" id="autotoc_md1263"></a>
RAM vs Flash-based SBL</h1>
<p>The CAN Flash Programmer can interface with either a RAM-based or a Flash-based CAN SBL. Their primary differences are outlined below:</p>
<table class="doxtable">
<tr>
<th colspan="3">SBL Comparison   </th></tr>
<tr>
<td bgcolor="#F0F0F0"></td><td bgcolor="#F0F0F0"><b>RAM-based SBL</b>  </td><td bgcolor="#F0F0F0"><b><a class="el" href="EXAMPLES_DRIVERS_FLASH_BASED_CAN_SBL_WITH_FOTA.html">Flash-based CAN SBL</a></b>  </td></tr>
<tr>
<td>Former name  </td><td>Flash Kernel  </td><td>Boot Manager   </td></tr>
<tr>
<td>Type  </td><td>Temporary, runs in RAM  </td><td>Persistent, resides alongside of user application   </td></tr>
<tr>
<td>Device boot  </td><td>SBL loads via: <br  />
 • Periperial CAN boot (.bin) <br  />
 • CCS Debug<sup>3</sup> (.out) </td><td>SBL loads via: <br  />
 • Flash boot (.bin) <br  />
 (programmed by RAM-based SBL) <br  />
 • CCS Flash<sup>3</sup> (.out) <br  />
 • Uniflash<sup>3</sup>(.out)   </td></tr>
<tr>
<td>Which programmer to use  </td><td>• CAN_flash_programmer.exe <br  />
 • build w/ ENABLE_PERIPHERAL_BOOT </td><td>• CAN_flash_programmer_appIn.exe <br  />
 • build w/o ENABLE_PERIPHERAL_BOOT  </td></tr>
<tr>
<td>Unsecure Programming <br  />
 (HS-FS only)  </td><td>DFU <br  />
 • Programs to active flash bank <br  />
 • supports all bankmode - 0,1,2,3 </td><td>FOTA <br  />
 • A/B partition, programs to dormant flash bank <br  />
 • supports bankmode 1 and 3   </td></tr>
<tr>
<td>Secure Programming  </td><td>Secure KP &amp; CP <br  />
 • Interface with OTP Keywriter <br  />
 • DFU in mode 0 and 2 <br  />
 • FOTA in mode 1 and 3 </td><td>Secure CP (HS-SE only) <br  />
 • FOTA  </td></tr>
<tr>
<td>HSM Firmware <br  />
 (Pre-req for secure programming) </td><td>RAM-based HSM runtime  </td><td>Flash-based HSM runtime   </td></tr>
<tr>
<td>Use case  </td><td>• Initial device bringup &amp; conversion <br  />
 • DFU service model  </td><td>• FOTA service model   </td></tr>
</table>
<p>As described, the primary purpose of the RAM-based SBL is for initial device bring-up, such as supporting KP to provision private keys, which converts the device to HS-KP and subsequently to HS-SE with CP commands.</p>
<p>In contrast, the Flash-based SBL is programmed by the RAM-based SBL and is part of the device firmware that activates upon receiving Flash Programmer commands. Its functionality is a streamlined version of the RAM-based SBL, tailored for FOTA. It requires the RAM-based SBL to set up the appropriate bank modes and security states before the Flash-based SBL can be booted.</p><ul>
<li>For more information, refer to EXAMPLES_DRIVERS_RAM_BASED_CAN_SBL and <a class="el" href="EXAMPLES_DRIVERS_FLASH_BASED_CAN_SBL_WITH_FOTA.html">Flash-based CAN SBL w/ Firmware Over-The-Air</a></li>
</ul>
<blockquote class="doxtable">
<p>&zwj;3. Only available in HS-FS (unsecure programming). This will not work in HS-KP or HS-SE, since boot authentication and the JTAG debug firewall are enabled by default. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md1264"></a>
Running the program</h1>
<p>The Flash Programmer is a command-line tool. Run it from a terminal with the required arugments.</p>
<p>Windows Example: </p><div class="fragment"><div class="line">CAN_flash_programmer.exe -d &lt;device&gt; -p &lt;COM_PORT&gt; [other options]</div>
</div><!-- fragment --><p>Linux Example: </p><div class="fragment"><div class="line">./CAN_flash_programmer -d &lt;device&gt; -p &lt;COM_PORT&gt; [other options]</div>
</div><!-- fragment --><p>The program can be run interactively, where it will prompt for operations and wait for user input, or in an automated mode using the <em><code>--input</code></em> parameter to provide a sequence of commands.</p>
<p>For details on peripheral boot and avilable commands, see the sections below.</p>
<h1><a class="anchor" id="autotoc_md1265"></a>
Peripheral CAN boot</h1>
<p>To load a RAM-based SBL via device peripheral, first set the device boot pin into CAN boot.</p>
<table class="doxtable">
<caption>TRM Section 4.3, Device Boot Modes </caption>
<tr>
<th colspan="3">F29H85x Default Boot Modes   </th></tr>
<tr>
<td bgcolor="#F0F0F0">Boot Mode </td><td bgcolor="#F0F0F0">GPIO72 <br  />
 (Default boot mode select pin 1)  </td><td bgcolor="#F0F0F0">GPIO84 <br  />
 (Default boot mode select pin 2)   </td></tr>
<tr>
<td>Parallel IO  </td><td>0  </td><td>0   </td></tr>
<tr>
<td>UART  </td><td>0  </td><td>1   </td></tr>
<tr>
<td>CAN  </td><td>1  </td><td>0   </td></tr>
<tr>
<td>Flash  </td><td>1  </td><td>1   </td></tr>
</table>
<p>Then reset / plug-in the device to the PC, so Boot ROM is in CAN Boot. And run the CAN Flash Programmer (can_flash_programmer.exe or build with <em><code>ENABLE_PERIPHERAL_BOOT</code></em>).</p>
<p>In CAN Boot, ROM will first send SoC ID strings via CAN, and then waits for incoming CAN data before timeout occurs(~2min) &amp; switches to Wait Boot. Once it receives CAN data, it'll echo back the data, or stops if something fails to validate. The flash programmer monitors the echo-back data and will exit with failure status if the echoed back does not match the expected data.</p>
<p>Therefore, if Flash Programmer receives an unmatched data and exits, simply reset the device (XRSn suffice) and retry again.</p>
<p>However, if a CAN bootload of an image is consistently stuck (ROM stopped echoing back data which stops programmer from progressing), user can visually observe where data transfer stopped and have a clue of what happened:</p>
<ul>
<li>ROM stops reading at 4th byte<ul>
<li>Improper certificate format</li>
<li>ROM expects X.509 certificate to always start with 0x3082</li>
</ul>
</li>
<li>ROM stops before 4096th bytes<ul>
<li>Certificate unmatched SMPK</li>
<li>Boot authentication is enabled and ROM couldn't verify the key (unmatched key hash)</li>
</ul>
</li>
<li>ROM stops at the end of image<ul>
<li>Unmatched signature</li>
<li>Boot authentication is enabled and ROM couldn't verify the image signature (unmatched signature)</li>
</ul>
</li>
</ul>
<p> <style>div.image img[src="rom_invalid_x509.png"]{width:50%}</style> </p><div class="image">
<img src="rom_invalid_x509.png" alt=""/>
<div class="caption">
BootROM Invalid Certificate Format</div></div>
<p>See the image above on an example of bootloading an example that has improper X.509 format.</p>
<p>/note Since ROM sends out SoCID string at the start of CAN Boot and CAN Flash Programmer monitors echo-back data for validation, while it is unlikely for a mannual run to experience the clash between the two, when automating the flow, please make sure device power-on/reset is at least 100ms apart from invoking the CAN Flash Programmer for CAN boot.</p>
<h1><a class="anchor" id="autotoc_md1266"></a>
Generating Combined Image with X.509 Certificate</h1>
<p>All application &amp; SBL images must be in binary format and be prepended with a X.509 certificate. Even in HS-FS where authentication is disabled, the ROM and SBL still use the length field of a dummy certificate to determine how many bytes to read.</p>
<p>To generate the combined image with an X.509 certificate, please refer to the post-build steps in the RAM/Flash-based SBL examples. (Note that the Flash-based SBL also incorporates additional steps to combine the bootloader code and application firmware).</p><ul>
<li>In CCS 20+, Post-build steps can be found under (Project) Properties-&gt;Build-&gt;Steps</li>
</ul>
<p>In addition, refer to the various signing scripts located in F29H85X-SDK /tools/boot/signing.</p>
<h1><a class="anchor" id="autotoc_md1267"></a>
Flash Programmer Supported Parameters</h1>
<div class="fragment"><div class="line">Syntax:</div>
<div class="line"> </div>
<div class="line">can_flash_programmer.exe -d f29h85x -p &lt;COM/tty Port&gt; -k &lt;Ram-based SBL image&gt;.bin</div>
<div class="line">-a1 &lt;Unsecure CPU1 application image&gt;.bin -sr &lt;Ram-based HSM runtime image&gt;.bin -sk &lt;user key&gt;.cert -s1 &lt;Secure CPU1 application image&gt;.bin</div>
<div class="line">-sh &lt;Flash-based HSM application image&gt;.bin -sc &lt;sec cfg image&gt;.bin -q -w</div>
<div class="line"> </div>
<div class="line">-k, --kernerl is not available for appIn.exe (w/o ENABLE_PERIPHERAL_BOOT)</div>
<div class="line">-hb, --hostbaud is not available for non-appIn.exe (w/ ENABLE_PERIPHERAL_BOOT)</div>
</div><!-- fragment --><p>Supply -h or &ndash;help as a parameter will prompt the following message: </p><pre class="fragment">    F29x CAN Firmware Programmer
    Supported parameters are:

    -d,  --device &lt;device&gt;     - The device family of the target device:
                                (f29h85x, f29p58x, f29p32x)
    -k,  --kernel    &lt;file&gt;    - File path for ram-based sbl (formerly flash kernel)
    -a1, --appcpu1   &lt;file&gt;    - File path for Flash-based C29 CPU1 application image (HS-FS Only)
    -a3, --appcpu3   &lt;file&gt;    - File path for Flash-based C29 CPU3 application image (HS-FS Only)
    -sr, --hsmrt     &lt;file&gt;    - File path for RAM-based HSM runtime (HSMRt) image    (Prerequisite for KP &amp; CP)
    -sk, --hsmkeys   &lt;file&gt;    - File path for HSM keys image                         (HS-KP key provision)
    -s1, --cpappcpu1 &lt;file&gt;    - File path for Flash-based C29 CPU1 application image (HS-SE code provision)
    -s3, --cpappcpu3 &lt;file&gt;    - File path for Flash-based C29 CPU3 application image (HS-SE code provision)
    -sh, --cpapphsm  &lt;file&gt;    - File path for Flash-based HSM application image      (HS-SE code provision)
    -sc, --cpseccfg  &lt;file&gt;    - File path for Sec Cfg program image                  (HS-SE code provision)
    -e1, --entryaddr &lt;hex_num&gt; - (optional) Override entry address of the C29 CPU1 application

    Note: -d is mandatory. -k is mandatory in non-appIn
        Images must be in binary format and includes an X.509 certificate.

    -i, --input &lt;,&gt;  - Provide command input options via parameter rather than keyboard input to the console
                    (format: comma-separated values &lt;num,num&gt;, for example "--input 3,4,11,15")
    --boot-only      - Only do peripheral boot and exits the program right after. Can be used to load any SBL without programmer's packet protocol support.

    -h, --help       - Show this help.
    -l, --log &lt;file&gt; - Log mode. Redirect all non-essential printouts to the specified file, will override -q mode
    -q, --quiet      - Quiet mode. Suppress all non-essential printouts
    -w               - Wait on keypress before exiting
    --version        - Display version information

    Syntax: -d f29h85x -k ram_based_can_sbl.bin --appcpu1 c29_cpu1_application.bin --entryaddr 10001000 --hsmrt HSM_runtimeImage.bin --hsmkeys HSM_customKeyCert.bin --cpseccfg sec_cfg_cert.bin --cpappcpu1 c29_cpu1_application.bin -cpapphsm hsm_application.bin -l output.log
</pre> <h1><a class="anchor" id="autotoc_md1268"></a>
Flash Programmer Operations</h1>
<p>When running the program, after the peripheral CAN boot (if applicable) , the user will be prompted with the following options:</p>
<p> <style>div.image img[src="flash_programmer_options.png"]{width:80%}</style> </p><div class="image">
<img src="flash_programmer_options.png" alt=""/>
<div class="caption">
Flash Programmer Command Options</div></div>
<p><b>Programming Commands</b>:</p>
<ul>
<li>1. CPU1 DFU/FOTA<ul>
<li>HS-FS only</li>
<li>If selected, the host will send the Flash-based CPU1 command and its application image to the SBL, which then programs it using the C29 Flash API. The default flash start address is 0x10000000.</li>
<li>Mandatory parameter: -a1 (&ndash;appcpu1)</li>
</ul>
</li>
<li>2. CPU3 DFU/FOTA<ul>
<li>HS-FS only</li>
<li>If selected, the host will send the Flash-based CPU3 command and its application image to the SBL, which then programs it using the C29 Flash API. The default flash start address is 0x10400000.</li>
<li>Mandatory parameter: -a3 (&ndash;appcpu3)</li>
</ul>
</li>
<li>3. Load HSM RAM Image<ul>
<li>Note: This step is the <b>prerequisite</b> for any RAM-based SBL's Key Provision &amp; Code Provision flow</li>
<li>If selected, host will send a RAM-based HSM runtime image to the device and subsequently boot the runtime image in HSM.</li>
<li>Mandatory parameter: -sr (&ndash;hsmrt)</li>
</ul>
</li>
<li>4. Load HSM Key<ul>
<li>This step transitions the device into HS-KP by burning a user key. The OTP Keywriter (in the form of a RAM-based HSM runtime) must be loaded prior to this operation.</li>
<li>If selected, the host will send the custom key to the SBL. The SBL then requests a keywriter service from the HSM. Upon success, a device reset transitions the device into HS-KP.</li>
<li>Mandatory parameter: -sk (&ndash;hsmkeys)</li>
</ul>
</li>
<li>5. Program Sec Cfg<ul>
<li>HS-KP or HS-SE</li>
<li>This step is needed to transition from HS-KP to HS-SE. Unlike other programming operations, the Sec Cfg sector image does not need to be prepended with an X.509 certificate, as it already contains one.<ul>
<li>For more on generating Sec Cfg sector image, see F29H85X-SDK /tools/misc/genSeccfgBin.py and Driverlib SSU examples that utilitizes the script to generate a sector image.</li>
</ul>
</li>
<li>If selected, host will send the sector image to program Sec Cfg sectors. If the device is in HS-KP, it'll convert into HS-SE upon success with a device reset.</li>
<li>Mandatory parameter: -sc (&ndash;cpseccfg)</li>
</ul>
</li>
<li>6. Load HSM Flash Image<ul>
<li>HS-KP or HS-SE</li>
<li>Note: This step is the <b>prerequisite</b> for any Flash-based SBL's Code Provision flow (Need to be loaded by RAM-based SBL).</li>
<li>If selected, host will send the Flash-based HSM application image to be programmed via HSM services.</li>
<li>Mandatory parameter: -sh (&ndash;cpapphsm)</li>
</ul>
</li>
<li>7. Load C29 CPU1 Image<ul>
<li>HS-KP or HS-SE</li>
<li>If selected, host will send the Flash-based CPU1 application image to be programmed via HSM services. The default start flash address is 0x10000000.</li>
<li>Mandatory parameter: -s1 (&ndash;cpappcpu1)</li>
</ul>
</li>
<li>8. Load C29 CPU3 Image<ul>
<li>HS-KP or HS-SE</li>
<li>If selected, host will send the Flash-based CPU3 application image to be programmed via HSM services. The default start flash address is 0x10400000.</li>
<li>Mandatory parameter: -s3 (&ndash;cpappcpu3)</li>
</ul>
</li>
</ul>
<p><b>Utility Commands</b>:</p>
<ul>
<li>10. Sync Device Status<ul>
<li>If selected, host will send command and wait for SBL response message.</li>
<li>Note: In Flash-based SBL, the response message will also indicate if the application firmware has been booted.</li>
</ul>
</li>
<li>11. Get SocID Info<ul>
<li>If selected, SBL will respond with SocID informations populated by ROM and parse it accordingly.</li>
<li>Contains ROM info, firmware version and HSM security info.</li>
</ul>
</li>
<li>12. Get Boot ROM Status<ul>
<li>If selected, SBL will respond with brom_status information populated by ROM and parse it accordingly.</li>
<li>Contains ROM runtime info, boot errors, NMI entries, SSU and Flash information</li>
<li>The status is not be up-to-date with run time status as ROM only populates it at boot time.</li>
</ul>
</li>
<li>13. Run CPU1<ul>
<li>If selected, CPU1 will either branch to the default entry address or to an alternate entry address if -e (&ndash;entryaddr) is provided.</li>
<li>Optional parameter: -e1 &ndash;entryaddr &lt; hex address &gt;</li>
</ul>
</li>
<li>14. Run CPU3<ul>
<li>If selected, CPU1 will configure CPU3 to bring it out of reset and load ram/flash entry address depending on the SBL type.</li>
</ul>
</li>
<li>15. Reset CPU1<ul>
<li>If selected, CPU1 will invoke watchdog timer and reset the CPUs &amp; HSM (CPU1.WDRSn).</li>
</ul>
</li>
<li>20. Set Bankmode 0<ul>
<li>If selected, SBL will attempt to set flash bank mode to 0.</li>
<li>HS-FS only, not yet implemented for CP.</li>
</ul>
</li>
<li>21. Set Bankmode 1<ul>
<li>If selected, SBL will attempt to set flash bank mode to 1.</li>
<li>HS-FS only, not yet implemented for CP.</li>
</ul>
</li>
<li>22. Set Bankmode 2<ul>
<li>If selected, SBL will attempt to set flash bank mode to 2.</li>
<li>HS-FS only, not yet implemented for CP.</li>
</ul>
</li>
<li>23. Set Bankmode 3<ul>
<li>If selected, SBL will attempt to set flash bank mode to 3.</li>
<li>HS-FS only, not yet implemented for CP.</li>
</ul>
</li>
<li>0. Done<ul>
<li>Exits the program with return status</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1269"></a>
Changelog</h1>
<p>Shown below lists all the software revision history for the CAN flash programmer:</p>
<table class="doxtable">
<tr>
<th>Software Version </th><th>SDK Release </th><th>Changelog  </th></tr>
<tr>
<td>v1.00.00 </td><td>1.02.02.00 </td><td>First release, in F29H85X-SDK   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md1270"></a>
Addintional resource</h1>
<ul>
<li>N/A</li>
</ul>
<h1><a class="anchor" id="autotoc_md1271"></a>
Help and Support</h1>
<p>For additional help and support, please visit <a href="https://e2e.ti.com/support/microcontrollers/c2000-microcontrollers-group/c2000/f/c2000-microcontrollers-forum" target="_blank"><em>E2E™ design support forum</em></a></p>
<h1><a class="anchor" id="autotoc_md1272"></a>
API usage</h1>
<p><a class="el" href="group__can__flash__programmer__api.html">APIs for CAN Flash Programmer</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
