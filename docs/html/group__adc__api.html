<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>F29H85x-SDK: ADC</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="F29H85x-SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F29H85x-SDK
   &#160;<span id="projectnumber">1.01.00.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__adc__api.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">ADC</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Introduction</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structADC__RepeaterConfig.html">ADC_RepeaterConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga29168166e5e8e7fbb6b7e37532cb3c95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga29168166e5e8e7fbb6b7e37532cb3c95">__attribute__</a> ((always_inline)) static inline void ADC_setPrescaler(uint32_t base</td></tr>
<tr class="memdesc:ga29168166e5e8e7fbb6b7e37532cb3c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops FLUSH pattern transmission.  <a href="group__adc__api.html#ga29168166e5e8e7fbb6b7e37532cb3c95">More...</a><br /></td></tr>
<tr class="separator:ga29168166e5e8e7fbb6b7e37532cb3c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga352d1d80342471169d3a0ee2827652a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga352d1d80342471169d3a0ee2827652a6">HWREGH</a> (base+ADC_O_CTL2)</td></tr>
<tr class="separator:ga352d1d80342471169d3a0ee2827652a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b0276e379a5a2f071b4794b75bc8411"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a> (ADC_isBaseValid(base))</td></tr>
<tr class="separator:ga3b0276e379a5a2f071b4794b75bc8411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82e04495547c44de1dd2fb5b57a5a015"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga82e04495547c44de1dd2fb5b57a5a015">ASSERT</a> ((<a class="el" href="group__adc__api.html#ga139e91afbb42ffe7b8e5d6b951c2e299">sampleWindow</a> &gt;=1U) &amp;&amp;(<a class="el" href="group__adc__api.html#ga139e91afbb42ffe7b8e5d6b951c2e299">sampleWindow</a>&lt;=512U))</td></tr>
<tr class="separator:ga82e04495547c44de1dd2fb5b57a5a015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaccbe2386a6a27cadaaa3afa23175d38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaaccbe2386a6a27cadaaa3afa23175d38">HWREG</a> (<a class="el" href="group__adc__api.html#ga42b7b3dd4778651a8203b5be9701dedf">ctlRegAddr</a>)</td></tr>
<tr class="separator:gaaccbe2386a6a27cadaaa3afa23175d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5411b1c1d3f7f9e716076d8a7400eb28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga5411b1c1d3f7f9e716076d8a7400eb28">ASSERT</a> (<a class="el" href="group__adc__api.html#gaff35d151ed6e343c03d4cefc467055ef">extChannel</a>&lt;=15U)</td></tr>
<tr class="separator:ga5411b1c1d3f7f9e716076d8a7400eb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0a16f59e0a70656a4c4f091d92c0954"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaa0a16f59e0a70656a4c4f091d92c0954">HWREGH</a> (<a class="el" href="group__adc__api.html#gab84a03b00f3c041fcca9687504b03a6a">regOffset</a>+ADC_O_REP1FRC)|</td></tr>
<tr class="separator:gaa0a16f59e0a70656a4c4f091d92c0954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea09d7aa46471f386381dad028facbe7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaea09d7aa46471f386381dad028facbe7">return</a> (<a class="el" href="group__xbar__api.html#gaea30ea7ef8d51d933a82ff1f684ee95f">HWREGH</a>(<a class="el" href="group__adc__api.html#gab84a03b00f3c041fcca9687504b03a6a">regOffset</a>+ADC_O_REP1CTL) &amp;<a class="el" href="group__adc__api.html#ga24bde289150fdfe7017a65d553223e99">ADC_REPSTATUS_MASK</a>)</td></tr>
<tr class="separator:gaea09d7aa46471f386381dad028facbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8093b760436a6b31ce12d6edcafd591"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaa8093b760436a6b31ce12d6edcafd591">if</a> (<a class="el" href="group__adc__api.html#ga89624cc1f9e5146db40bdc1d89e4e1a7">socNumber</a> &gt;=<a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a2c34128042a216aeca4d41d9221ccab6">ADC_SOC_NUMBER16</a>)</td></tr>
<tr class="separator:gaa8093b760436a6b31ce12d6edcafd591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e3e86936133b844bbbaccf33f6a7cb3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga9e3e86936133b844bbbaccf33f6a7cb3">HWREG</a> (base+<a class="el" href="group__adc__api.html#gab84a03b00f3c041fcca9687504b03a6a">regOffset</a>) = <a class="el" href="group__adc__api.html#ga0dba5e75536f43bd1303a498c93bcc52">socMask</a></td></tr>
<tr class="separator:ga9e3e86936133b844bbbaccf33f6a7cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa08f7eccbc6fdd0deb8ffdd71e3d4386"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaa08f7eccbc6fdd0deb8ffdd71e3d4386">return</a> ((<a class="el" href="group__xbar__api.html#gaea30ea7ef8d51d933a82ff1f684ee95f">HWREGH</a>(base+ADC_O_INTFLG) &amp;(1U&lt;&lt;((uint16_t) <a class="el" href="group__adc__api.html#gad38a5cb0fdd8e8a9d3ad3e631db6aebb">adcIntNum</a>+4U))) !=0U)</td></tr>
<tr class="separator:gaa08f7eccbc6fdd0deb8ffdd71e3d4386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga106b46b23fd24c86b843b45e768ebcd7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga106b46b23fd24c86b843b45e768ebcd7">return</a> ((<a class="el" href="group__xbar__api.html#gaea30ea7ef8d51d933a82ff1f684ee95f">HWREGH</a>(base+ADC_O_INTFLG) &amp;(1U&lt;&lt;(uint16_t) <a class="el" href="group__adc__api.html#gad38a5cb0fdd8e8a9d3ad3e631db6aebb">adcIntNum</a>)) !=0U)</td></tr>
<tr class="separator:ga106b46b23fd24c86b843b45e768ebcd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b71579c06dae1849ebfba59f4755774"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga5b71579c06dae1849ebfba59f4755774">return</a> ((<a class="el" href="group__xbar__api.html#gaea30ea7ef8d51d933a82ff1f684ee95f">HWREGH</a>(base+ADC_O_INTOVF) &amp;(1U&lt;&lt;(uint16_t) <a class="el" href="group__adc__api.html#gad38a5cb0fdd8e8a9d3ad3e631db6aebb">adcIntNum</a>)) !=0U)</td></tr>
<tr class="separator:ga5b71579c06dae1849ebfba59f4755774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e70bfddb8442905743fcbb7a548047"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga84e70bfddb8442905743fcbb7a548047">return</a> (<a class="el" href="group__xbar__api.html#gaea30ea7ef8d51d933a82ff1f684ee95f">HWREGH</a>(resultBase+(uint32_t) <a class="el" href="group__adc__api.html#gaa112157a688d3a93ad050744df519d8c">ADC_RESULTx_OFFSET_BASE</a>+(uint32_t) <a class="el" href="group__adc__api.html#ga89624cc1f9e5146db40bdc1d89e4e1a7">socNumber</a> *2U))</td></tr>
<tr class="separator:ga84e70bfddb8442905743fcbb7a548047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d4c1e9c1b468d52f813706bcf11f6fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga7d4c1e9c1b468d52f813706bcf11f6fe">ASSERT</a> (((uint16_t) <a class="el" href="group__epwm__api.html#ga0c3340352ff50bb2f9c5a64f95c018eb">trigger</a> &amp;~((uint16_t) 0x1FU))==0U)</td></tr>
<tr class="separator:ga7d4c1e9c1b468d52f813706bcf11f6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa41fbfdd613aa2a847dd86b5cbc1ce3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaaa41fbfdd613aa2a847dd86b5cbc1ce3">ASSERT</a> ((<a class="el" href="group__adc__api.html#ga89ada8f35c7000f6307974313149afa3">burstSize</a> &gt;=1U) &amp;&amp;(<a class="el" href="group__adc__api.html#ga89ada8f35c7000f6307974313149afa3">burstSize</a>&lt;=32U))</td></tr>
<tr class="separator:gaaa41fbfdd613aa2a847dd86b5cbc1ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc0d0fc14137db2949367140d6013e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga5cc0d0fc14137db2949367140d6013e1">ASSERT</a> ((<a class="el" href="group__fsi__api.html#gab8437a9efb8f45f84fc54073f06e1dc7">evtFlags</a> &amp;~0x7U)==0U)</td></tr>
<tr class="separator:ga5cc0d0fc14137db2949367140d6013e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61f892c4adb7f04881a8d54dc3f5de54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga61f892c4adb7f04881a8d54dc3f5de54">HWREGH</a> (base+ADC_O_EVTSEL) &amp;</td></tr>
<tr class="separator:ga61f892c4adb7f04881a8d54dc3f5de54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd51a8d9c150eea2da4d46554c8c9cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gabcd51a8d9c150eea2da4d46554c8c9cd">ASSERT</a> ((<a class="el" href="group__uart__api.html#ga725ce2418b983a338c5d58a9ca1baad6">intFlags</a> &amp;~0x7U)==0U)</td></tr>
<tr class="separator:gabcd51a8d9c150eea2da4d46554c8c9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bcf29a1c889be815fe0c8e786e16e83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga9bcf29a1c889be815fe0c8e786e16e83">return</a> ((<a class="el" href="group__xbar__api.html#gaea30ea7ef8d51d933a82ff1f684ee95f">HWREGH</a>(base+ADC_O_EVTSTAT) &gt;&gt;((uint16_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *4U)) &amp;0x7U)</td></tr>
<tr class="separator:ga9bcf29a1c889be815fe0c8e786e16e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedb1f991e6c34f5f0557fe50e2231516"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaedb1f991e6c34f5f0557fe50e2231516">ASSERT</a> (<a class="el" href="group__adc__api.html#ga6e8e21280adfab4d1a5b4275b3aea590">limit</a>&lt;=ADC_PPB1LIMIT_LIMIT_M)</td></tr>
<tr class="separator:gaedb1f991e6c34f5f0557fe50e2231516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba0ea9dcd05b06eedaeec20cf06d4d9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaba0ea9dcd05b06eedaeec20cf06d4d9f">return</a> (<a class="el" href="group__adc__api.html#ga6e8e21280adfab4d1a5b4275b3aea590">limit</a>)</td></tr>
<tr class="separator:gaba0ea9dcd05b06eedaeec20cf06d4d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6216ad4a333348b67164e3116ac97c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaa6216ad4a333348b67164e3116ac97c1">return</a> (<a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(base+(uint32_t) <a class="el" href="group__adc__api.html#ga437d861f409a157db3f2d9a07344dfca">ADC_PPBxPCOUNT_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *26UL *2UL)))</td></tr>
<tr class="separator:gaa6216ad4a333348b67164e3116ac97c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ce558cee36f8ce219c6380247c17c26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga0ce558cee36f8ce219c6380247c17c26">return</a> ((int32_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(base+(uint32_t) <a class="el" href="group__adc__api.html#ga0d1b5698287de79f5f1577fcda816386">ADC_PPBxPSUM_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *26UL *2UL)))</td></tr>
<tr class="separator:ga0ce558cee36f8ce219c6380247c17c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bb0fd4308afdd00d632e74df9675f46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga4bb0fd4308afdd00d632e74df9675f46">return</a> ((int32_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(base+(uint32_t) <a class="el" href="group__adc__api.html#ga9ef83b3a78d0983af6c5f2ab72833751">ADC_PPBxPMAX_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *26UL *2UL)))</td></tr>
<tr class="separator:ga4bb0fd4308afdd00d632e74df9675f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3905c9453aa39afcd6f15324aabd5a3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga3905c9453aa39afcd6f15324aabd5a3d">return</a> ((int32_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(base+(uint32_t) <a class="el" href="group__adc__api.html#gaaab63fb1795587086e1f46416864e2be">ADC_PPBxPMIN_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *26UL *2UL)))</td></tr>
<tr class="separator:ga3905c9453aa39afcd6f15324aabd5a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c8db963f4741895e55005cc35529bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga49c8db963f4741895e55005cc35529bd">return</a> ((uint16_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(base+(uint32_t) <a class="el" href="group__adc__api.html#gad02c12204c2dc93c27b2500530961b15">ADC_PPBxPMAXI_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *26UL *2UL)))</td></tr>
<tr class="separator:ga49c8db963f4741895e55005cc35529bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ef9958d8841f54c429ead3dbfa68e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gad4ef9958d8841f54c429ead3dbfa68e4">return</a> ((uint16_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(base+(uint32_t) <a class="el" href="group__adc__api.html#gadc8d0aced8122b23437d2ad4e1e143b7">ADC_PPBxPMINI_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *26UL *2UL)))</td></tr>
<tr class="separator:gad4ef9958d8841f54c429ead3dbfa68e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a97a6a3ceb1ad2ab0a07f5a441722eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga0a97a6a3ceb1ad2ab0a07f5a441722eb">ASSERT</a> (<a class="el" href="group__sent__api.html#ga3437693c30df099c987147d4b9ff3267">shiftVal</a>&lt;=10U)</td></tr>
<tr class="separator:ga0a97a6a3ceb1ad2ab0a07f5a441722eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2af6da15de4478d172a02b0ee5756cf3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga2af6da15de4478d172a02b0ee5756cf3">ASSERT</a> (<a class="el" href="group__adc__api.html#ga17b2a2e1d7f4b9777ad54abc5ecf334c">syncInput</a>&lt;=0x1DU)</td></tr>
<tr class="separator:ga2af6da15de4478d172a02b0ee5756cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga683b2bf6fb53eb073dd9713072678f14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga683b2bf6fb53eb073dd9713072678f14">ASSERT</a> (<a class="el" href="group__adc__api.html#ga55e53d6079bb80730928d367729ebb30">osIntSrc</a>&lt;=1U)</td></tr>
<tr class="separator:ga683b2bf6fb53eb073dd9713072678f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dcd5188270c4229abde65f3a7b209bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga9dcd5188270c4229abde65f3a7b209bb">ASSERT</a> (<a class="el" href="group__adc__api.html#ga28982f9c9b6a5958ae9fe5a706d3bf0e">compSrc</a>&lt;=2U)</td></tr>
<tr class="separator:ga9dcd5188270c4229abde65f3a7b209bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45597203f856cb2f176384658a10a8a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga45597203f856cb2f176384658a10a8a9">return</a> ((int32_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(resultBase+(uint32_t) <a class="el" href="group__adc__api.html#ga9d1b25bfa0a3e3943018cfb170511a04">ADC_PPBxSUM_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *4UL *2UL)))</td></tr>
<tr class="separator:ga45597203f856cb2f176384658a10a8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae528ab962c5c1b75597f8a4f4d8954ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gae528ab962c5c1b75597f8a4f4d8954ce">return</a> ((uint32_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(resultBase+(uint32_t) <a class="el" href="group__adc__api.html#ga5a70b72944ed25738a637efa0e0ee2e7">ADC_PPBxCOUNT_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *4UL *2UL)))</td></tr>
<tr class="separator:gae528ab962c5c1b75597f8a4f4d8954ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafaa5a107523c905ca25f72ab7cb339a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaafaa5a107523c905ca25f72ab7cb339a">return</a> ((int32_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(resultBase+(uint32_t) <a class="el" href="group__adc__api.html#ga7ca65192da9ebeda9cfd6a649f4ebb40">ADC_PPBxMAX_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *8UL *2UL)))</td></tr>
<tr class="separator:gaafaa5a107523c905ca25f72ab7cb339a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b7cfb35e4ea026cdf7e190d2c6442e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga9b7cfb35e4ea026cdf7e190d2c6442e0">return</a> ((int32_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(resultBase+(uint32_t) <a class="el" href="group__adc__api.html#ga1228b21a75ea02767101524fbc3d41d8">ADC_PPBxMIN_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *8UL *2UL)))</td></tr>
<tr class="separator:ga9b7cfb35e4ea026cdf7e190d2c6442e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0cc65462f7abafa3e77554910cb9e2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gab0cc65462f7abafa3e77554910cb9e2e">return</a> (<a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(resultBase+(uint32_t) <a class="el" href="group__adc__api.html#ga5092b64861c237074c57a7218890fc87">ADC_PPBxMAXI_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *8UL *2UL)))</td></tr>
<tr class="separator:gab0cc65462f7abafa3e77554910cb9e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a7c1e90449ef574b46129d3f73ddd7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gab3a7c1e90449ef574b46129d3f73ddd7">return</a> (<a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(resultBase+(uint32_t) <a class="el" href="group__adc__api.html#ga732d9c8c6ef51e36ad606c480c0908f7">ADC_PPBxMINI_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *8UL *2UL)))</td></tr>
<tr class="separator:gab3a7c1e90449ef574b46129d3f73ddd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5acbf69975cad1e5610d5b59e46a290"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gad5acbf69975cad1e5610d5b59e46a290">return</a> ((int32_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(resultBase+(uint32_t) <a class="el" href="group__adc__api.html#gab93b3d59039266605bee26e11b6077be">ADC_PPBxRESULT_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *4UL)))</td></tr>
<tr class="separator:gad5acbf69975cad1e5610d5b59e46a290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb0170d4f6e074a689abefb540bf355a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaeb0170d4f6e074a689abefb540bf355a">return</a> (<a class="el" href="group__xbar__api.html#gaea30ea7ef8d51d933a82ff1f684ee95f">HWREGH</a>(base+<a class="el" href="group__adc__api.html#ga5c1608f532c04cd01ed2f1a2497e84d0">ppbOffset</a>) &amp;ADC_PPB2STAMP_DLYSTAMP_M)</td></tr>
<tr class="separator:gaeb0170d4f6e074a689abefb540bf355a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe693c168f098da13939e38298d305f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gabe693c168f098da13939e38298d305f2">HWREG</a> (base+<a class="el" href="group__adc__api.html#ga5c1608f532c04cd01ed2f1a2497e84d0">ppbOffset</a>) &amp; = ~ECAP_MUNIT_1_CTL_DEBUG_RANGE_EN</td></tr>
<tr class="separator:gabe693c168f098da13939e38298d305f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaef5d28bb05e43ee59b57b4d58041a8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaaef5d28bb05e43ee59b57b4d58041a8b">HWREGH</a> (<a class="el" href="group__adc__api.html#gaf26a4c8dacfbaa9cb56118d0798b02ac">intRegAddr</a>)|</td></tr>
<tr class="separator:gaaef5d28bb05e43ee59b57b4d58041a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1b0332600fbe71eb791fb48b8c7dadd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gab1b0332600fbe71eb791fb48b8c7dadd">HWREGH</a> (<a class="el" href="group__adc__api.html#gaf26a4c8dacfbaa9cb56118d0798b02ac">intRegAddr</a>) &amp; = ~(ADC_INTSEL1N2_INT1CONT &lt;&lt; <a class="el" href="group__sent__api.html#ga3437693c30df099c987147d4b9ff3267">shiftVal</a>)</td></tr>
<tr class="separator:gab1b0332600fbe71eb791fb48b8c7dadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b38cd2f4d5acd8597da5fd7e7284803"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga6b38cd2f4d5acd8597da5fd7e7284803">if</a> (<a class="el" href="group__adc__api.html#ga0283977132d023294bd0a34faf61695c">refMode</a>==<a class="el" href="group__adc__api.html#ggad33ea1f3c3db73f25e0bdf15a86be959afbf176ce408c0621a20dd98442ac05ae">ADC_REFERENCE_INTERNAL</a>)</td></tr>
<tr class="separator:ga6b38cd2f4d5acd8597da5fd7e7284803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacedd9c80ea9283f370d77471a2e2f058"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gacedd9c80ea9283f370d77471a2e2f058">HWREGH</a> (scBase+ADC_O_RESSEL1+(uint16_t) <a class="el" href="group__adc__api.html#gafc980d327c8cc70836562b64b9e417fe">checkInst</a> *2U)</td></tr>
<tr class="separator:gacedd9c80ea9283f370d77471a2e2f058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22343e79baeff4af85e0dc0ce101ca97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga22343e79baeff4af85e0dc0ce101ca97">ASSERT</a> (<a class="el" href="group__adc__api.html#ga0c2bf3e18f553a6c2d34b58094ba5402">tolerance</a>&lt;=ADC_TOLERANCE_TOLERANCE_M)</td></tr>
<tr class="separator:ga22343e79baeff4af85e0dc0ce101ca97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00d2774a5fe75be9f44af822a6b4c4b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga00d2774a5fe75be9f44af822a6b4c4b3">HWREGH</a> (scBase+ADC_O_TOLERANCE)</td></tr>
<tr class="separator:ga00d2774a5fe75be9f44af822a6b4c4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef36cbbad38929ea296f4ee0175fe18f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaef36cbbad38929ea296f4ee0175fe18f">return</a> (<a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(scBase+ADC_O_CHECKRESULT1+(uint16_t) <a class="el" href="group__adc__api.html#gafc980d327c8cc70836562b64b9e417fe">checkInst</a> *2U) &amp;ADC_CHECKRESULT1_RESULT_M)</td></tr>
<tr class="separator:gaef36cbbad38929ea296f4ee0175fe18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec443b5c8199037ba0edd64de5c8bedb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaec443b5c8199037ba0edd64de5c8bedb">HWREG</a> (scIntEvtBase+ADC_O_CHECKEVT1SEL1+((uint32_t) <a class="el" href="group__adc__api.html#ga7a35b7eb8077674ad9084e6ff665f99f">checkEvent</a>+(uint32_t) <a class="el" href="group__adc__api.html#gaf1b4e5b69a7ac95f93c002311a6181c4">checkResult</a>) *2UL)|</td></tr>
<tr class="separator:gaec443b5c8199037ba0edd64de5c8bedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5020d6131f4b31d16b5858af635cc9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaa5020d6131f4b31d16b5858af635cc9f">HWREG</a> (scIntEvtBase+ADC_O_CHECKEVT1SEL1+((uint32_t) <a class="el" href="group__adc__api.html#ga7a35b7eb8077674ad9084e6ff665f99f">checkEvent</a>+(uint32_t) <a class="el" href="group__adc__api.html#gaf1b4e5b69a7ac95f93c002311a6181c4">checkResult</a>) *2UL) &amp;</td></tr>
<tr class="separator:gaa5020d6131f4b31d16b5858af635cc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1fafc7f856e9246f4426f3bed1ccf39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gad1fafc7f856e9246f4426f3bed1ccf39">HWREG</a> (scIntEvtBase+ADC_O_CHECKINTSEL1+(uint32_t) <a class="el" href="group__adc__api.html#gaf1b4e5b69a7ac95f93c002311a6181c4">checkResult</a> *2UL)|</td></tr>
<tr class="separator:gad1fafc7f856e9246f4426f3bed1ccf39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ee94f19506c2867c4b6e40be634d20a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga5ee94f19506c2867c4b6e40be634d20a">HWREG</a> (scIntEvtBase+ADC_O_CHECKINTSEL1+(uint32_t) <a class="el" href="group__adc__api.html#gaf1b4e5b69a7ac95f93c002311a6181c4">checkResult</a> *2UL) &amp;</td></tr>
<tr class="separator:ga5ee94f19506c2867c4b6e40be634d20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1730dc785e8cdba596e7d75ef35bc3b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga1730dc785e8cdba596e7d75ef35bc3b6">return</a> (<a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(scIntEvtBase+ADC_O_OOTFLG+(uint32_t) <a class="el" href="group__adc__api.html#gae4e0c18e893b7318af14779e8db7fdc1">checkerFlag</a> *2UL) &amp;(1U&lt;&lt;(uint32_t) <a class="el" href="group__adc__api.html#gaf6b93c709cbc4bc7f896eb20d9f82f70">checkerNumber</a>))</td></tr>
<tr class="separator:ga1730dc785e8cdba596e7d75ef35bc3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09ab9f0ec7c6c1c1f769ce284189ff70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga09ab9f0ec7c6c1c1f769ce284189ff70">HWREG</a> (scIntEvtBase+ADC_O_OOTFLGCLR+(uint32_t) <a class="el" href="group__adc__api.html#gae4e0c18e893b7318af14779e8db7fdc1">checkerFlag</a> *2UL)</td></tr>
<tr class="separator:ga09ab9f0ec7c6c1c1f769ce284189ff70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a0ec303eaada432c087317faeebe23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga16a0ec303eaada432c087317faeebe23">HWREG</a> (<a class="el" href="group__adc__api.html#gab84a03b00f3c041fcca9687504b03a6a">regOffset</a>+ADC_O_REP1CTL)</td></tr>
<tr class="separator:ga16a0ec303eaada432c087317faeebe23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f1b33eec6dbc5b65385e311b6a0511f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga3f1b33eec6dbc5b65385e311b6a0511f">return</a> (<a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(<a class="el" href="group__adc__api.html#gab84a03b00f3c041fcca9687504b03a6a">regOffset</a>+ADC_O_REP1CTL) &amp;(1U&lt;&lt; <a class="el" href="group__adc__api.html#ga869b25bb4e431bfcd0eb9e1665e89284">ADC_REP1CTL_ACTIVEMODE_S</a>))</td></tr>
<tr class="separator:ga3f1b33eec6dbc5b65385e311b6a0511f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad50918b02c2b62168201a89022b0f894"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gad50918b02c2b62168201a89022b0f894">return</a> (<a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(<a class="el" href="group__adc__api.html#gab84a03b00f3c041fcca9687504b03a6a">regOffset</a>+ADC_O_REP1CTL) &amp;(1U&lt;&lt; <a class="el" href="group__adc__api.html#gab842e8dcd72fbf8a8b0d2278ed737701">ADC_REP1CTL_MODULEBUSY_S</a>))</td></tr>
<tr class="separator:gad50918b02c2b62168201a89022b0f894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9be520d669cdc02fd357a5281f032884"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga9be520d669cdc02fd357a5281f032884">ASSERT</a> (<a class="el" href="group__adc__api.html#gace198ded246b134826243276d46384a1">repCount</a>&lt;=127U)</td></tr>
<tr class="separator:ga9be520d669cdc02fd357a5281f032884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a3111e591fb1bc4bb1d40487aff721f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga4a3111e591fb1bc4bb1d40487aff721f">ADC_configureRepeater</a> (uint32_t base, uint16_t <a class="el" href="group__adc__api.html#ga8cd5cacce3a01f77ac3c814e740d2632">repInstance</a>, <a class="el" href="structADC__RepeaterConfig.html">ADC_RepeaterConfig</a> *<a class="el" href="group__interrupt__api.html#ga1eaa747c28d66f8888d63df6dd02a77b">config</a>)</td></tr>
<tr class="separator:ga4a3111e591fb1bc4bb1d40487aff721f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82811db076d3d59caa26e85fe3f9e4a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga82811db076d3d59caa26e85fe3f9e4a9">ADC_setupSOCRefloChannel</a> (uint32_t base, <a class="el" href="group__adc__api.html#ga254fedc72090784dcfcdcebebdf3ea39">ADC_SOCNumber</a> <a class="el" href="group__adc__api.html#ga89624cc1f9e5146db40bdc1d89e4e1a7">socNumber</a>, <a class="el" href="group__adc__api.html#ga7973b7d12fc7bfb96bd276b0a5926834">ADC_Trigger</a> <a class="el" href="group__epwm__api.html#ga0c3340352ff50bb2f9c5a64f95c018eb">trigger</a>, uint32_t <a class="el" href="group__adc__api.html#ga139e91afbb42ffe7b8e5d6b951c2e299">sampleWindow</a>, <a class="el" href="group__adc__api.html#ga429dd4804497c259c3e869cbca38106c">ADC_ChannelType</a> channelType)</td></tr>
<tr class="separator:ga82811db076d3d59caa26e85fe3f9e4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6b5f4a6e28b845462cb44d00889a6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gac6b5f4a6e28b845462cb44d00889a6f9">ADC_setMode</a> (uint32_t base, <a class="el" href="group__adc__api.html#ga61bdbeb0bb5a4b445ba88d05a51c701b">ADC_Resolution</a> resolution, <a class="el" href="group__adc__api.html#gabb3445edb2b4d559233957cd6311d909">ADC_SignalMode</a> signalMode)</td></tr>
<tr class="separator:gac6b5f4a6e28b845462cb44d00889a6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe0d15283495abce50c21eb97a8491a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gabe0d15283495abce50c21eb97a8491a4">ADC_setOffsetTrim</a> (uint32_t base)</td></tr>
<tr class="separator:gabe0d15283495abce50c21eb97a8491a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga245251ff514fae5b6959e78842bec621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga245251ff514fae5b6959e78842bec621">ADC_setINLTrim</a> (uint32_t base)</td></tr>
<tr class="separator:ga245251ff514fae5b6959e78842bec621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga378cb44d8b8674121e44de0acf48006f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga378cb44d8b8674121e44de0acf48006f">ADC_setPPBTripLimits</a> (uint32_t base, <a class="el" href="group__adc__api.html#ga17f0c071ab2c71a40e3d95c9eeadf3b9">ADC_PPBNumber</a> <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a>, int32_t tripHiLimit, int32_t tripLoLimit)</td></tr>
<tr class="separator:ga378cb44d8b8674121e44de0acf48006f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga8d6ae5ac93027785bc422c07d87f4a5a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga8d6ae5ac93027785bc422c07d87f4a5a">ADC_ClkPrescale</a> { <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga8d6ae5ac93027785bc422c07d87f4a5aa3e33987cc2dd1ef61167608c18b28c21">ADC_CLK_DIV_1_0</a> = 0U
, <a class="el" href="group__adc__api.html#gga8d6ae5ac93027785bc422c07d87f4a5aa6c3a25aced6f3c35d1be5e21b1a6e8b1">ADC_CLK_DIV_2_0</a> = 2U
, <a class="el" href="group__adc__api.html#gga8d6ae5ac93027785bc422c07d87f4a5aa61dc1a46ec5ac11678b089db8cd709d1">ADC_CLK_DIV_2_5</a> = 3U
, <a class="el" href="group__adc__api.html#gga8d6ae5ac93027785bc422c07d87f4a5aaabdbcd923c3a6134c444faba022536aa">ADC_CLK_DIV_3_0</a> = 4U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga8d6ae5ac93027785bc422c07d87f4a5aa0e5d67b46514a35868245754a3d72ec3">ADC_CLK_DIV_3_5</a> = 5U
, <a class="el" href="group__adc__api.html#gga8d6ae5ac93027785bc422c07d87f4a5aafaeb50b93500d9e1b5f49a5ea23465d9">ADC_CLK_DIV_4_0</a> = 6U
, <a class="el" href="group__adc__api.html#gga8d6ae5ac93027785bc422c07d87f4a5aaddaf5682b390f7fcf31adc3abb6a2ca3">ADC_CLK_DIV_4_5</a> = 7U
, <a class="el" href="group__adc__api.html#gga8d6ae5ac93027785bc422c07d87f4a5aa99ab26b48430e29121d48445b17f922f">ADC_CLK_DIV_5_0</a> = 8U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga8d6ae5ac93027785bc422c07d87f4a5aa87a63f5b0d306bda18b5dd6aa76087e4">ADC_CLK_DIV_5_5</a> = 9U
, <a class="el" href="group__adc__api.html#gga8d6ae5ac93027785bc422c07d87f4a5aa5d738f4dbf1b69bcaf3820a96a7ab375">ADC_CLK_DIV_6_0</a> = 10U
, <a class="el" href="group__adc__api.html#gga8d6ae5ac93027785bc422c07d87f4a5aa69b20ca30cee7c2f341af1ff00ffd82f">ADC_CLK_DIV_6_5</a> = 11U
, <a class="el" href="group__adc__api.html#gga8d6ae5ac93027785bc422c07d87f4a5aa233be0327034ddd52c0bc1005173e819">ADC_CLK_DIV_7_0</a> = 12U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga8d6ae5ac93027785bc422c07d87f4a5aab9ca56b534ab8d4e7cc3d0ea775f6540">ADC_CLK_DIV_7_5</a> = 13U
, <a class="el" href="group__adc__api.html#gga8d6ae5ac93027785bc422c07d87f4a5aaa5e3810a6b7ac706ff7bec299842c211">ADC_CLK_DIV_8_0</a> = 14U
, <a class="el" href="group__adc__api.html#gga8d6ae5ac93027785bc422c07d87f4a5aad4c5ac99de171a9d1cda6572bea6e9f8">ADC_CLK_DIV_8_5</a> = 15U
<br />
 }</td></tr>
<tr class="separator:ga8d6ae5ac93027785bc422c07d87f4a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61bdbeb0bb5a4b445ba88d05a51c701b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga61bdbeb0bb5a4b445ba88d05a51c701b">ADC_Resolution</a> { <a class="el" href="group__adc__api.html#gga61bdbeb0bb5a4b445ba88d05a51c701bac002266035b9c3a14762154237da8e87">ADC_RESOLUTION_12BIT</a> = 0x00U
, <a class="el" href="group__adc__api.html#gga61bdbeb0bb5a4b445ba88d05a51c701ba5c3c11dff8c5b740d209faac34047aeb">ADC_RESOLUTION_16BIT</a> = 0x40U
 }</td></tr>
<tr class="separator:ga61bdbeb0bb5a4b445ba88d05a51c701b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb3445edb2b4d559233957cd6311d909"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gabb3445edb2b4d559233957cd6311d909">ADC_SignalMode</a> { <a class="el" href="group__adc__api.html#ggabb3445edb2b4d559233957cd6311d909a638bddbd35effd8c1545ed033883cc3b">ADC_MODE_SINGLE_ENDED</a> = 0x00U
, <a class="el" href="group__adc__api.html#ggabb3445edb2b4d559233957cd6311d909af44167a7d746d7ba0b56345deb686efd">ADC_MODE_DIFFERENTIAL</a> = 0x80U
 }</td></tr>
<tr class="separator:gabb3445edb2b4d559233957cd6311d909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7973b7d12fc7bfb96bd276b0a5926834"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga7973b7d12fc7bfb96bd276b0a5926834">ADC_Trigger</a> { <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a9b08ad6080adb6fb14f27aa9b983fb51">ADC_TRIGGER_SW_ONLY</a> = 0
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834ab0c33f3e6509025d9792afdce374a9fa">ADC_TRIGGER_CPU1_TINT0</a> = 1
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a4f6bcc25d7f13d1a9a10776faad46008">ADC_TRIGGER_CPU1_TINT1</a> = 2
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834ac891128b2fb71b4fa8b63ebf51f3790c">ADC_TRIGGER_CPU1_TINT2</a> = 3
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834aa38d4a5ab3ee5946465236aac1f26c76">ADC_TRIGGER_GPIO</a> = 4
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a98f0d3ecdf23823727fc64e3c0fbc240">ADC_TRIGGER_EPWM1_SOCA</a> = 5
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a88e3e1c6ffdb247df64badcf6ddccf86">ADC_TRIGGER_EPWM1_SOCB</a> = 6
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834aa927aace29b8499bb9414bf25aba6ccd">ADC_TRIGGER_EPWM2_SOCA</a> = 7
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834aa44a2d836c2201d011c01d51e137b7c8">ADC_TRIGGER_EPWM2_SOCB</a> = 8
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a07addb1ab145d808b7e8581e95f1f999">ADC_TRIGGER_EPWM3_SOCA</a> = 9
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a2c760a67cd78c33598afd9a0ba8d2200">ADC_TRIGGER_EPWM3_SOCB</a> = 10
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a45948585a29a620be07f4bdf1cf5a3f9">ADC_TRIGGER_EPWM4_SOCA</a> = 11
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a24733858882229d52bf4afdd8c853b1a">ADC_TRIGGER_EPWM4_SOCB</a> = 12
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a3b03ad1a0dd178e29a3a7fff0f24db4d">ADC_TRIGGER_EPWM5_SOCA</a> = 13
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a4f73a4cfeba5543682a1b2737ada1418">ADC_TRIGGER_EPWM5_SOCB</a> = 14
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a270cf6e4f0d41b89ad83b996fd3dec64">ADC_TRIGGER_EPWM6_SOCA</a> = 15
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a071f713674170e85db780f44999cab95">ADC_TRIGGER_EPWM6_SOCB</a> = 16
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a0a1c6af7b9fa97239ee71e499dfb8bb5">ADC_TRIGGER_EPWM7_SOCA</a> = 17
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834ab7756d56b7ef82b3596f6f5afda1a145">ADC_TRIGGER_EPWM7_SOCB</a> = 18
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a4fa0444f5c852d4f98e6592b8f6348b6">ADC_TRIGGER_EPWM8_SOCA</a> = 19
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834af129b09e91c4a845b538e1072d4e95f2">ADC_TRIGGER_EPWM8_SOCB</a> = 20
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834aff9f8fd1920ec9231734bb4612725af1">ADC_TRIGGER_EPWM9_SOCA</a> = 21
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a6cb5d624a0db72cde5f2ee5aa9150563">ADC_TRIGGER_EPWM9_SOCB</a> = 22
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a774c492308b970ee9de11974cdaad97a">ADC_TRIGGER_EPWM10_SOCA</a> = 23
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a3f26581b004d9d89a5523734df0c6395">ADC_TRIGGER_EPWM10_SOCB</a> = 24
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a81e561c6066b429bb273271e2d2151a3">ADC_TRIGGER_EPWM11_SOCA</a> = 25
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834aafc2be8e3549a2a223486ce722b386e0">ADC_TRIGGER_EPWM11_SOCB</a> = 26
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a0255c5db10382c3b21d4f9cea9704c1f">ADC_TRIGGER_EPWM12_SOCA</a> = 27
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a830f853186dd717d012dd20bbba33a47">ADC_TRIGGER_EPWM12_SOCB</a> = 28
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834aef5f39e65ea6b98b02ce86d74a36472f">ADC_TRIGGER_REPEATER1</a> = 40
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a4dcf733cfbe14011815e35ddf31c4ab9">ADC_TRIGGER_REPEATER2</a> = 41
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834aa870e9d8a6cacdddbed63e6351097e22">ADC_TRIGGER_CLB1_OUT27</a> = 72
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a75891e18664928b73e3c281211d09e59">ADC_TRIGGER_CLB2_OUT27</a> = 73
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834af50ba6d0a9cc137395df546143f19931">ADC_TRIGGER_CLB3_OUT27</a> = 74
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a36f7de570043490ff2824bd5c0a0787f">ADC_TRIGGER_CLB4_OUT27</a> = 75
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834ab83f3d16da43805f4a1a860cba3332e2">ADC_TRIGGER_CLB5_OUT27</a> = 76
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a9660d12e8ceb7af100005d17089a2c21">ADC_TRIGGER_CLB6_OUT27</a> = 77
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834ab0384657b4d68416c26981109d962710">ADC_TRIGGER_ECAP1</a> = 80
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834aaa57c39738f6e23f919eabadba8f6d2b">ADC_TRIGGER_ECAP2</a> = 81
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a549baabece9dc3ec051eb0435573678e">ADC_TRIGGER_ECAP3</a> = 82
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834adc005df5195fe80241d7abc07bd97c31">ADC_TRIGGER_ECAP4</a> = 83
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834aa9dbc1cdb91a69183a015237475c52ee">ADC_TRIGGER_ECAP5</a> = 84
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834ac2215d5a10fcc8741c1d769825e9dc61">ADC_TRIGGER_ECAP6</a> = 85
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834ae84037ce312680802ae23323c60aaa71">ADC_TRIGGER_EPWM13_SOCA</a> = 88
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834adacba370bd9c031054c8ad0ee52d4c2a">ADC_TRIGGER_EPWM13_SOCB</a> = 89
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a46888c7fb4c852cce01fb25d7ba2e4df">ADC_TRIGGER_EPWM14_SOCA</a> = 90
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a7f3e209ac9aad7a2b2b13693399fc9b2">ADC_TRIGGER_EPWM14_SOCB</a> = 91
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a75d760a92e81e491a670212a44c82ef3">ADC_TRIGGER_EPWM15_SOCA</a> = 92
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a5d6c786e521f688394f708f2e89c90a2">ADC_TRIGGER_EPWM15_SOCB</a> = 93
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a41c98135807712690ea04306c7752285">ADC_TRIGGER_EPWM16_SOCA</a> = 94
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a10937a9f51744920b42bcc4a67f82ea0">ADC_TRIGGER_EPWM16_SOCB</a> = 95
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a7be9fbf3b1e1810e122bcbccb13e0561">ADC_TRIGGER_EPWM17_SOCA</a> = 96
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a73d48bf55b4d309186ebd5a00d773526">ADC_TRIGGER_EPWM17_SOCB</a> = 97
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834addf4ddcc255dcb717be9b6eb5fda70e6">ADC_TRIGGER_EPWM18_SOCA</a> = 98
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834ac5b3d4ba84a039fa6dbe7a64aabd252f">ADC_TRIGGER_EPWM18_SOCB</a> = 99
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a59e82c524ee596ea784ce14970805528">ADC_TRIGGER_CPU2_TINT0</a> = 100
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a42499d98cf412b3c60b1cd81b66de17d">ADC_TRIGGER_CPU2_TINT1</a> = 101
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834ad08bb09fa74c1f24942cc8e431e34961">ADC_TRIGGER_CPU2_TINT2</a> = 102
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a437092f2e0aa50471d7ecc57057b75ed">ADC_TRIGGER_CPU3_TINT0</a> = 103
, <a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a70e88e48f11a7e708b6dc3b6688bb304">ADC_TRIGGER_CPU3_TINT1</a> = 104
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga7973b7d12fc7bfb96bd276b0a5926834a5ccefdaaccbf0c3726fae20d2a7efa0d">ADC_TRIGGER_CPU3_TINT2</a> = 105
<br />
 }</td></tr>
<tr class="separator:ga7973b7d12fc7bfb96bd276b0a5926834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b9fa1ae8a65e534cce7d26fa0984f6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gad7b9fa1ae8a65e534cce7d26fa0984f6">ADC_Channel</a> { <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6adf3fcf575362183753c35541c57214ec">ADC_CH_ADCIN0</a> = 0U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a1eb94448700a96e3d736df1c22a9024a">ADC_CH_ADCIN1</a> = 1U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6ab8c49d498941741257b1da57aec5e3ab">ADC_CH_ADCIN2</a> = 2U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a9faf1b6f5731d3d254aef3c61f3c5c63">ADC_CH_ADCIN3</a> = 3U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6ac8c4e9648bae64323935a75cbbb34556">ADC_CH_ADCIN4</a> = 4U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6adca7353a2c8bb18c5e0e54fb91863b3c">ADC_CH_ADCIN5</a> = 5U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6aebb29c83c442e7472261e1a3c652d64f">ADC_CH_ADCIN6</a> = 6U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a4389106875b6aab9b6fe8940bfe2d922">ADC_CH_ADCIN7</a> = 7U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a0cdf45e738b440e491d63c3e18987671">ADC_CH_ADCIN8</a> = 8U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6aef4dd01a0b2f4b0bf6a1ec9ce60cb88e">ADC_CH_ADCIN9</a> = 9U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a213b49d5ae49aca4068020771fecff4b">ADC_CH_ADCIN10</a> = 10U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a5a2482d45fdda131ce65d30fdee49d9e">ADC_CH_ADCIN11</a> = 11U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a695f52a73207a15b4e7c66184d955566">ADC_CH_ADCIN12</a> = 12U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6aea3d0820ce79591573ac87abb6834b9c">ADC_CH_ADCIN13</a> = 13U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6ad57e92e33ff745530fdab094baeedded">ADC_CH_ADCIN14</a> = 14U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a2d377b4128a4dd24e56a867f395110fc">ADC_CH_ADCIN15</a> = 15U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a0bf3f6d7920c89513793694d67870444">ADC_CH_ADCIN16</a> = 16U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a51b1dbf71808d2cf808b1e4feeb3684b">ADC_CH_ADCIN17</a> = 17U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a39af6e7b573f7ed2985726a914530a89">ADC_CH_ADCIN18</a> = 18U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a0c547d7955c51fc84bfeb8fd4e23ddc6">ADC_CH_ADCIN19</a> = 19U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a1f5be514575cda01b0f0ac2f5823ce0c">ADC_CH_ADCIN20</a> = 20U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a88273e5111fd705ca5cd1a10442e2d81">ADC_CH_ADCIN21</a> = 21U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a9276f8be27422aad47a184bb1f63d80a">ADC_CH_ADCIN22</a> = 22U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6acda3a3f6322dc89b62a45105a720ba8e">ADC_CH_ADCIN23</a> = 23U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a998b57980e387abf1e73fc4893d65b6a">ADC_CH_ADCIN24</a> = 24U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6aa50df941f03d8648f4a1a7f2f6652eb5">ADC_CH_ADCIN25</a> = 25U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6ac7117395296b76abd200bd59c509c24e">ADC_CH_ADCIN26</a> = 26U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a684cc9b9e08178303a9025ad908945dc">ADC_CH_ADCIN27</a> = 27U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6ab04847a0955f666f47c4e39a5d8fb161">ADC_CH_ADCIN28</a> = 28U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a6908d3cb5baa5450cd8b63653ab5576c">ADC_CH_ADCIN29</a> = 29U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6aa5b3e92d5058f1250dae7bf547779743">ADC_CH_ADCIN30</a> = 30U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a00f88fcf717e36448583392155cfe919">ADC_CH_ADCIN31</a> = 31U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a59f5571cd0c0df13e06cc92f34c559cc">ADC_CH_ADCIN0_ADCIN1</a> = 0U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6aa9df414fa035e94f2fe311d42a9a5fad">ADC_CH_ADCIN2_ADCIN3</a> = 2U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a594d49deb14638733b0e029948337393">ADC_CH_ADCIN4_ADCIN5</a> = 4U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a2fb2043cb6794eab3a38ee6e8964c8ff">ADC_CH_ADCIN6_ADCIN7</a> = 6U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6abfb5fe1d195ee900820fb233ee206483">ADC_CH_ADCIN8_ADCIN9</a> = 8U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6afb28842e60ffa58a521cf4a1ad5adc95">ADC_CH_ADCIN10_ADCIN11</a> = 10U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a19f426a6746efe0dc954a393b3fd5c67">ADC_CH_ADCIN12_ADCIN13</a> = 12U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6ab92df55c26e52d2fb81eba793ced73f3">ADC_CH_ADCIN14_ADCIN15</a> = 14U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a3da1106f4b92af5497b5c9ceb33fd34d">ADC_CH_ADCIN16_ADCIN17</a> = 16U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a554b4c50cf7bc3208dcc581db6bb5b87">ADC_CH_ADCIN18_ADCIN19</a> = 18U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a35989a30eda800eadb980ec9a2ffc48b">ADC_CH_ADCIN20_ADCIN21</a> = 20U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a24456fa4abce3d6b8bd6006abb8064f6">ADC_CH_ADCIN22_ADCIN23</a> = 22U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a96473a86b20b12de216191ac160050f4">ADC_CH_ADCIN24_ADCIN25</a> = 24U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a51e6293dea31490bcbfde77f219294bd">ADC_CH_ADCIN26_ADCIN27</a> = 26U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a1bab28c88c296421651e35cef46fb4dc">ADC_CH_ADCIN28_ADCIN29</a> = 28U
, <a class="el" href="group__adc__api.html#ggad7b9fa1ae8a65e534cce7d26fa0984f6a9ca4ac4c1ca17fbe6c90fd507206271d">ADC_CH_ADCIN30_ADCIN31</a> = 30U
<br />
 }</td></tr>
<tr class="separator:gad7b9fa1ae8a65e534cce7d26fa0984f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd907be60c59083e2bf41efcc36d4baf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gacd907be60c59083e2bf41efcc36d4baf">ADC_PulseMode</a> { <a class="el" href="group__adc__api.html#ggacd907be60c59083e2bf41efcc36d4bafa5c34190501b6d5ab20ff71972cf84fbd">ADC_PULSE_END_OF_ACQ_WIN</a> = 0x00U
, <a class="el" href="group__adc__api.html#ggacd907be60c59083e2bf41efcc36d4bafa5e8213d4f17b42a398ea39e0318606e2">ADC_PULSE_END_OF_CONV</a> = 0x04U
 }</td></tr>
<tr class="separator:gacd907be60c59083e2bf41efcc36d4baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cb95bd359b9df2dfd0977ce2020df06"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga2cb95bd359b9df2dfd0977ce2020df06">ADC_IntNumber</a> { <a class="el" href="group__adc__api.html#gga2cb95bd359b9df2dfd0977ce2020df06afa11dee02381f1e8e1a6c7474f5d9948">ADC_INT_NUMBER1</a> = 0U
, <a class="el" href="group__adc__api.html#gga2cb95bd359b9df2dfd0977ce2020df06a2971cc781b210a2fdb5100778ab39ab7">ADC_INT_NUMBER2</a> = 1U
, <a class="el" href="group__adc__api.html#gga2cb95bd359b9df2dfd0977ce2020df06ae8f41bdfcea215b0fe376f1b2c67bf2e">ADC_INT_NUMBER3</a> = 2U
, <a class="el" href="group__adc__api.html#gga2cb95bd359b9df2dfd0977ce2020df06ab01ee13f397ca14ebd27f74751c7a599">ADC_INT_NUMBER4</a> = 3U
 }</td></tr>
<tr class="separator:ga2cb95bd359b9df2dfd0977ce2020df06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17f0c071ab2c71a40e3d95c9eeadf3b9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga17f0c071ab2c71a40e3d95c9eeadf3b9">ADC_PPBNumber</a> { <a class="el" href="group__adc__api.html#gga17f0c071ab2c71a40e3d95c9eeadf3b9a3d5ab08197c2c052a70bbd9e11e3d85b">ADC_PPB_NUMBER1</a> = 0U
, <a class="el" href="group__adc__api.html#gga17f0c071ab2c71a40e3d95c9eeadf3b9a9bf980daa1de121251f266292f09184b">ADC_PPB_NUMBER2</a> = 1U
, <a class="el" href="group__adc__api.html#gga17f0c071ab2c71a40e3d95c9eeadf3b9a449772890acf04ae6376aa660f62acbb">ADC_PPB_NUMBER3</a> = 2U
, <a class="el" href="group__adc__api.html#gga17f0c071ab2c71a40e3d95c9eeadf3b9a98869b3648a71291ceeb5e095b4d3115">ADC_PPB_NUMBER4</a> = 3U
 }</td></tr>
<tr class="separator:ga17f0c071ab2c71a40e3d95c9eeadf3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga254fedc72090784dcfcdcebebdf3ea39"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga254fedc72090784dcfcdcebebdf3ea39">ADC_SOCNumber</a> { <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a13f3e19d5ee844b3a2eff08681becbb3">ADC_SOC_NUMBER0</a> = 0U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a59ed2ddcb0833aaa80234623679f25f2">ADC_SOC_NUMBER1</a> = 1U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a9efee36aa12204bd511fe602f86fb3c6">ADC_SOC_NUMBER2</a> = 2U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a8db276a4433b2be5934d7574feca8ea7">ADC_SOC_NUMBER3</a> = 3U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a39f5749e05562cc10e49c564b9b882f8">ADC_SOC_NUMBER4</a> = 4U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a6cdb8e506ca9a7824feee9777a5614d1">ADC_SOC_NUMBER5</a> = 5U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a78cc89a06b99db4baf8fc31f5e6c4266">ADC_SOC_NUMBER6</a> = 6U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39ab06f22bdc9d1c47c5f821e02509ceb43">ADC_SOC_NUMBER7</a> = 7U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a7516eb2cb9c101fbf83d0cf686b4131e">ADC_SOC_NUMBER8</a> = 8U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a5fdf20c2c172e83b96b13e6cbe780113">ADC_SOC_NUMBER9</a> = 9U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a91693adcb98cdb52520609381ae97d32">ADC_SOC_NUMBER10</a> = 10U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a24cd87237628ac79b2891574e0b2ca16">ADC_SOC_NUMBER11</a> = 11U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a74351fde1fcdcaa8748a395f988954c2">ADC_SOC_NUMBER12</a> = 12U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39ab5f9d250d79f83f71eb90ecc93fcde16">ADC_SOC_NUMBER13</a> = 13U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39ab87336c7e8a08b3f4676385f10f6e5b0">ADC_SOC_NUMBER14</a> = 14U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39ac8d4c48ec980b4cf3a20afcf5527d37b">ADC_SOC_NUMBER15</a> = 15U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a2c34128042a216aeca4d41d9221ccab6">ADC_SOC_NUMBER16</a> = 16U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39af7eb671d75bfa044ed425e463d3f1da7">ADC_SOC_NUMBER17</a> = 17U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39ab7dc3bd3c297e87342da57ca837ac940">ADC_SOC_NUMBER18</a> = 18U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a3191ae751bfe9c94c07cb58998c9a43a">ADC_SOC_NUMBER19</a> = 19U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a38e3e934f4912c0a1336e0f421c80d09">ADC_SOC_NUMBER20</a> = 20U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39ab0fc151334d8d4dcf18053b99d3127af">ADC_SOC_NUMBER21</a> = 21U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a12f3cfce1f0cd377e564480ff2ebe38c">ADC_SOC_NUMBER22</a> = 22U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a2da7db3567b3f288c7c1f57563768b26">ADC_SOC_NUMBER23</a> = 23U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a45a86fe81893eb13854e78c84c6a5f93">ADC_SOC_NUMBER24</a> = 24U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a1fb883a64a5d03ef5580f0cf536b6942">ADC_SOC_NUMBER25</a> = 25U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39ab2853bff633d2bd3de1c9a7f2e28b186">ADC_SOC_NUMBER26</a> = 26U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39aeb2f5462f92809dc5f1eb5953e4fcf4e">ADC_SOC_NUMBER27</a> = 27U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a7dd65f1a31b3d257e5aaf50f345d2393">ADC_SOC_NUMBER28</a> = 28U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39acb07c647438ceefa045472790ea644dc">ADC_SOC_NUMBER29</a> = 29U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a1194ffd9e76ba612a6e9031969b74a12">ADC_SOC_NUMBER30</a> = 30U
, <a class="el" href="group__adc__api.html#gga254fedc72090784dcfcdcebebdf3ea39a56db8aca15718bbcbd9e129205c19159">ADC_SOC_NUMBER31</a> = 31U
<br />
 }</td></tr>
<tr class="separator:ga254fedc72090784dcfcdcebebdf3ea39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga174a238f04d1d0ec1b89fdd7fed64716"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga174a238f04d1d0ec1b89fdd7fed64716">ADC_IntSOCTrigger</a> { <a class="el" href="group__adc__api.html#gga174a238f04d1d0ec1b89fdd7fed64716a4033eb805c2ff7c5c075dc9fa605e83c">ADC_INT_SOC_TRIGGER_NONE</a> = 0U
, <a class="el" href="group__adc__api.html#gga174a238f04d1d0ec1b89fdd7fed64716a39b229325d41b2005924aa16092f4a1b">ADC_INT_SOC_TRIGGER_ADCINT1</a> = 1U
, <a class="el" href="group__adc__api.html#gga174a238f04d1d0ec1b89fdd7fed64716a080ccc812e44c8e0810b21002f063441">ADC_INT_SOC_TRIGGER_ADCINT2</a> = 2U
 }</td></tr>
<tr class="separator:ga174a238f04d1d0ec1b89fdd7fed64716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f60e7ea55578eb4eb621f31b0b8d434"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga4f60e7ea55578eb4eb621f31b0b8d434">ADC_PriorityMode</a> { <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a297bc0c03e8352b0f234a141252dc7f3">ADC_PRI_ALL_ROUND_ROBIN</a> = 0x00
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434ae10aaea1f0763b40c298500b057774a8">ADC_PRI_SOC0_HIPRI</a> = 0x01
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a19a3f3c76a8963f876008710aeb3a5b5">ADC_PRI_THRU_SOC1_HIPRI</a> = 0x02
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a372fef4bd7fe8686df74123f40603d50">ADC_PRI_THRU_SOC2_HIPRI</a> = 0x03
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a1e43c265fd367fcad89ad2a896e29bd3">ADC_PRI_THRU_SOC3_HIPRI</a> = 0x04
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434adb7fd3d22b7a6b536bc47e7aa246989a">ADC_PRI_THRU_SOC4_HIPRI</a> = 0x05
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a55ed343f8dd4b373920daee023c03e48">ADC_PRI_THRU_SOC5_HIPRI</a> = 0x06
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a28b9206f25277389c69a842f4dea6940">ADC_PRI_THRU_SOC6_HIPRI</a> = 0x07
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a8e123710fcb95aa0a05c53259f1cf9c3">ADC_PRI_THRU_SOC7_HIPRI</a> = 0x08
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a6014c8669b5e453fdf3649217f70f443">ADC_PRI_THRU_SOC8_HIPRI</a> = 0x09
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a072852a73c92262b544f8d7af02bd27d">ADC_PRI_THRU_SOC9_HIPRI</a> = 0x0A
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434ab8bb4480710462a8e7a64fa3a116d7fb">ADC_PRI_THRU_SOC10_HIPRI</a> = 0x0B
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434abc2343f5f792f5790d5878f646ea894a">ADC_PRI_THRU_SOC11_HIPRI</a> = 0x0C
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a063bb00e48f66e0fa5c1f7973fee3887">ADC_PRI_THRU_SOC12_HIPRI</a> = 0x0D
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434aeac0757f770d9cc6ae33fd057eeae9c8">ADC_PRI_THRU_SOC13_HIPRI</a> = 0x0E
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a08bb1b8bfa841546c145ceba2ddea875">ADC_PRI_THRU_SOC14_HIPRI</a> = 0x0F
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434acdf39a98a8425182018a2f8e0162a5cb">ADC_PRI_THRU_SOC15_HIPRI</a> = 0x10
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434ac5c4f6f450e4f5916f4032d204fb88a9">ADC_PRI_THRU_SOC16_HIPRI</a> = 0x11
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a7d080b9b3471c061a39063acddd66481">ADC_PRI_THRU_SOC17_HIPRI</a> = 0x12
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a8bd9794635253ede2b433427da9e116b">ADC_PRI_THRU_SOC18_HIPRI</a> = 0x13
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a508c9be71fbca587c3c36817c0986f7e">ADC_PRI_THRU_SOC19_HIPRI</a> = 0x14
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a5ec5b8bc7d803416f4a7b27879ce1832">ADC_PRI_THRU_SOC20_HIPRI</a> = 0x15
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434aa46dcf49dfd0eb944e86fcf24ad60412">ADC_PRI_THRU_SOC21_HIPRI</a> = 0x16
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a7bda02181026be05358e68f52c6e76b2">ADC_PRI_THRU_SOC22_HIPRI</a> = 0x17
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a6bb56fad1c52471748b59de3e224e3d8">ADC_PRI_THRU_SOC23_HIPRI</a> = 0x18
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a460c9c0712039c569c4249957db3e77f">ADC_PRI_THRU_SOC24_HIPRI</a> = 0x19
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434ab632fa2399ef36729f1ce6ebb79bccae">ADC_PRI_THRU_SOC25_HIPRI</a> = 0x1A
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434af3ebad5908c6f8dab8b412f78e42b098">ADC_PRI_THRU_SOC26_HIPRI</a> = 0x1B
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a355740f3911647ce45fb7fd44f17bc76">ADC_PRI_THRU_SOC27_HIPRI</a> = 0x1C
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434ad72c5afb731cab6dfd17ae6b4035b4d8">ADC_PRI_THRU_SOC28_HIPRI</a> = 0x1D
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434a148f6936ef6ea6c934243eeb7877bbb9">ADC_PRI_THRU_SOC29_HIPRI</a> = 0x1E
, <a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434ad13d520e8911b242c44a6fe9f81e0518">ADC_PRI_THRU_SOC30_HIPRI</a> = 0x1F
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga4f60e7ea55578eb4eb621f31b0b8d434aeba70de1a0c4cefebc3d882eab391ec2">ADC_PRI_ALL_HIPRI</a> = 0x20
<br />
 }</td></tr>
<tr class="separator:ga4f60e7ea55578eb4eb621f31b0b8d434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad33ea1f3c3db73f25e0bdf15a86be959"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gad33ea1f3c3db73f25e0bdf15a86be959">ADC_ReferenceMode</a> { <a class="el" href="group__adc__api.html#ggad33ea1f3c3db73f25e0bdf15a86be959afbf176ce408c0621a20dd98442ac05ae">ADC_REFERENCE_INTERNAL</a> = 0U
, <a class="el" href="group__adc__api.html#ggad33ea1f3c3db73f25e0bdf15a86be959a0ee3dc6caaacf9fe3cd3122d5cba5ac3">ADC_REFERENCE_EXTERNAL</a> = 1U
 }</td></tr>
<tr class="separator:gad33ea1f3c3db73f25e0bdf15a86be959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1382e9ae48e28340cff1ea75f6f59ac8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga1382e9ae48e28340cff1ea75f6f59ac8">ADC_OSDetectMode</a> { <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga1382e9ae48e28340cff1ea75f6f59ac8a8b7b4cab894595c4d1056ef488ad50d2">ADC_OSDETECT_MODE_DISABLED</a> = 0x0U
, <a class="el" href="group__adc__api.html#gga1382e9ae48e28340cff1ea75f6f59ac8a0bc8c376217079542283f8c91774e536">ADC_OSDETECT_MODE_VSSA</a> = 0x1U
, <a class="el" href="group__adc__api.html#gga1382e9ae48e28340cff1ea75f6f59ac8ae10bc136097e9958d5b5617ba8428859">ADC_OSDETECT_MODE_VDDA</a> = 0x2U
, <a class="el" href="group__adc__api.html#gga1382e9ae48e28340cff1ea75f6f59ac8aec7f2b4f867bc685084680e5dbe67e22">ADC_OSDETECT_MODE_5BY12_VDDA</a> = 0x3U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga1382e9ae48e28340cff1ea75f6f59ac8a8a9ee2f5a0ea746b1fb8eee9863d1f58">ADC_OSDETECT_MODE_7BY12_VDDA</a> = 0x4U
, <a class="el" href="group__adc__api.html#gga1382e9ae48e28340cff1ea75f6f59ac8ab5a9dfa551c7bf77f6a820d52f87ec2b">ADC_OSDETECT_MODE_5K_PULLDOWN_TO_VSSA</a> = 0x5U
, <a class="el" href="group__adc__api.html#gga1382e9ae48e28340cff1ea75f6f59ac8a7b452e69971703733b16f83812f3b8f3">ADC_OSDETECT_MODE_5K_PULLUP_TO_VDDA</a> = 0x6U
, <a class="el" href="group__adc__api.html#gga1382e9ae48e28340cff1ea75f6f59ac8a942323fa80bf386ebfed4649d032ba9b">ADC_OSDETECT_MODE_7K_PULLDOWN_TO_VSSA</a> = 0x7U
<br />
 }</td></tr>
<tr class="separator:ga1382e9ae48e28340cff1ea75f6f59ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72acbe8c2b8c18788798e8d0e7655024"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga72acbe8c2b8c18788798e8d0e7655024">ADC_OffsetTrim</a> { <a class="el" href="group__adc__api.html#gga72acbe8c2b8c18788798e8d0e7655024ae3bdb98b7760c1978ae2bfde8f28cf6e">ADC_OFFSET_TRIM_COMMON</a> = 0x0000U
, <a class="el" href="group__adc__api.html#gga72acbe8c2b8c18788798e8d0e7655024abae2687c1d59856c487597a6e8cd510b">ADC_OFFSET_TRIM_INDIVIDUAL</a> = 0x0100U
 }</td></tr>
<tr class="separator:ga72acbe8c2b8c18788798e8d0e7655024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga429dd4804497c259c3e869cbca38106c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga429dd4804497c259c3e869cbca38106c">ADC_ChannelType</a> { <a class="el" href="group__adc__api.html#gga429dd4804497c259c3e869cbca38106ca22d9da0985e7e2b4c2bedc2310e3a33e">ADC_CHANNEL_ODD</a> = 0U
, <a class="el" href="group__adc__api.html#gga429dd4804497c259c3e869cbca38106ca13d9fe16f605bd2ff88ad0d9a70cc045">ADC_CHANNEL_EVEN</a> = 1U
 }</td></tr>
<tr class="separator:ga429dd4804497c259c3e869cbca38106c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ed1bc5073c7ef6394c3538b007e730"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga51ed1bc5073c7ef6394c3538b007e730">ADC_SyncInput</a> { <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a41950eda6b33032b1ed1796e261c5e46">ADC_SYNCIN_DISABLE</a> = 0x0
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730ae13163396045d4e31f09fd751fa0b642">ADC_SYNCIN_EPWM1SYNCOUT</a> = 0x1
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a48bb8988f5c66d84f13e43230820f9bc">ADC_SYNCIN_EPWM2SYNCOUT</a> = 0x2
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730afab12c263e64ed37f0807064415261f7">ADC_SYNCIN_EPWM3SYNCOUT</a> = 0x3
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a032c11920ea51a6977dc65ff6a6b068a">ADC_SYNCIN_EPWM4SYNCOUT</a> = 0x4
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a37e1396ad77a1d063c9a3996157c1a88">ADC_SYNCIN_EPWM5SYNCOUT</a> = 0x5
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a19bb46179ab36c9f2e646482ad8220a2">ADC_SYNCIN_EPWM6SYNCOUT</a> = 0x6
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a2021f7abe48e940eba39cbdf0925d980">ADC_SYNCIN_EPWM7SYNCOUT</a> = 0x7
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a87d80c9270c7df2ceb1e4b71580868a0">ADC_SYNCIN_EPWM8SYNCOUT</a> = 0x8
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a0cdf546ca57364be622725cdacdda4f0">ADC_SYNCIN_EPWM9SYNCOUT</a> = 0x9
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a1238097bb48d1a655449fe37f53babc5">ADC_SYNCIN_EPWM10SYNCOUT</a> = 0xA
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a2c33cae000e4b882a825c76087ed81c8">ADC_SYNCIN_EPWM11SYNCOUT</a> = 0xB
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a91468ed4784715bd54498ea7a9a7d6fd">ADC_SYNCIN_EPWM12SYNCOUT</a> = 0xC
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a9f46403397f2f69d6da86ae2be899e64">ADC_SYNCIN_EPWM13SYNCOUT</a> = 0xD
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a35eddfc6d1eaf07619ac1d0301523adf">ADC_SYNCIN_EPWM14SYNCOUT</a> = 0xE
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a6c2c37c0a77248fd7486e3c9509f9870">ADC_SYNCIN_EPWM15SYNCOUT</a> = 0xF
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a15d0dea52652bbae29f422096694ede3">ADC_SYNCIN_EPWM16SYNCOUT</a> = 0x10
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a2b0cccbe61bc6f46e60bd44f4234e956">ADC_SYNCIN_EPWM17SYNCOUT</a> = 0x11
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a18f4dc42ed32a13e328e471560e65b29">ADC_SYNCIN_EPWM18SYNCOUT</a> = 0x12
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730aeed5d2f93c9926d1a586c0fb65228e6c">ADC_SYNCIN_ECAP1YNCOUT</a> = 0x13
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a33b3645efef8b344382ef630fdcb0314">ADC_SYNCIN_ECAP2SYNCOUT</a> = 0x14
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730aa9ac95ebab6eeae932d28dd0e44396f6">ADC_SYNCIN_ECAP3SYNCOUT</a> = 0x15
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730aca2b3446ec558ca82fe014ce3c73dfe7">ADC_SYNCIN_ECAP4SYNCOUT</a> = 0x16
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730aaff6a489126a0c94de85c8e8ba4f0bd8">ADC_SYNCIN_ECAP5SYNCOUT</a> = 0x17
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a4d18ba2f47461645b6353702ad5e11ed">ADC_SYNCIN_ECAP6SYNCOUT</a> = 0x18
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a656ffa7dc83419044269a595880dc7b9">ADC_SYNCIN_INPUTXBAROUTPUT5</a> = 0x1A
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730a4237b3a4beb4c67e26ee2c3c28b33b74">ADC_SYNCIN_INPUTXBAROUTPUT6</a> = 0x1B
, <a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730ada6482130750544d41d4c06d7564efac">ADC_SYNCIN_EtherCATSYNC0</a> = 0x1C
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga51ed1bc5073c7ef6394c3538b007e730aab03988b39584201fd47805fb18e73fa">ADC_SYNCIN_EtherCATSYNC1</a> = 0x1D
<br />
 }</td></tr>
<tr class="separator:ga51ed1bc5073c7ef6394c3538b007e730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadae07564f94d93024778cb2e621781ae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gadae07564f94d93024778cb2e621781ae">ADC_PPBIntSrcSelect</a> { <a class="el" href="group__adc__api.html#ggadae07564f94d93024778cb2e621781aeae5cb2607a2c7d5dd5463e7dcf5cc51f3">ADC_PPB_OS_INT_1</a> = 0x0U
, <a class="el" href="group__adc__api.html#ggadae07564f94d93024778cb2e621781aeaa11f3a1099ed33a69feff17f86bf5c49">ADC_PPB_OS_INT_2</a> = 0x1U
 }</td></tr>
<tr class="separator:gadae07564f94d93024778cb2e621781ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac186093663d49a0c9d694073931f68f3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gac186093663d49a0c9d694073931f68f3">ADC_ExtChannel</a> { <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggac186093663d49a0c9d694073931f68f3ac0cdad9486484fc0d92bea2711f231f1">ADC_CH_ADCINX_0</a> = 0x0U
, <a class="el" href="group__adc__api.html#ggac186093663d49a0c9d694073931f68f3a3d194432508adef085ae548b88a6de61">ADC_CH_ADCINX_1</a> = 0x1U
, <a class="el" href="group__adc__api.html#ggac186093663d49a0c9d694073931f68f3a35f27ed6e41fa36261591477f2c93929">ADC_CH_ADCINX_2</a> = 0x2U
, <a class="el" href="group__adc__api.html#ggac186093663d49a0c9d694073931f68f3aeb956aab76588f8dcf0d373ee3fe3359">ADC_CH_ADCINX_3</a> = 0x3U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggac186093663d49a0c9d694073931f68f3a2b4747946f18c1d740903c59aa7d6f40">ADC_CH_ADCINX_4</a> = 0x4U
, <a class="el" href="group__adc__api.html#ggac186093663d49a0c9d694073931f68f3ab2da3d4ab7bec1dc3f6021cb7b30ec68">ADC_CH_ADCINX_5</a> = 0x5U
, <a class="el" href="group__adc__api.html#ggac186093663d49a0c9d694073931f68f3a7778298751055dba692682c8fb218ac9">ADC_CH_ADCINX_6</a> = 0x6U
, <a class="el" href="group__adc__api.html#ggac186093663d49a0c9d694073931f68f3a34b6586017e49cc72a1d540022c3270b">ADC_CH_ADCINX_7</a> = 0x7U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggac186093663d49a0c9d694073931f68f3a0fae55c47fe1a9ca40bdb58b3ee2d27d">ADC_CH_ADCINX_8</a> = 0x8U
, <a class="el" href="group__adc__api.html#ggac186093663d49a0c9d694073931f68f3af357aee792ce93d2212b7d9575242b27">ADC_CH_ADCINX_9</a> = 0x9U
, <a class="el" href="group__adc__api.html#ggac186093663d49a0c9d694073931f68f3ac29668b774b7862e859b8b7e0fd8e7d8">ADC_CH_ADCINX_10</a> = 0xAU
, <a class="el" href="group__adc__api.html#ggac186093663d49a0c9d694073931f68f3a2e2253862a5176525a3e3592669cfdcb">ADC_CH_ADCINX_11</a> = 0xBU
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggac186093663d49a0c9d694073931f68f3a4dd4f9ed02f0625cdca91a5fc1221983">ADC_CH_ADCINX_12</a> = 0xCU
, <a class="el" href="group__adc__api.html#ggac186093663d49a0c9d694073931f68f3a5937a03fe7104c7820cfd223dfdf04e6">ADC_CH_ADCINX_13</a> = 0xDU
, <a class="el" href="group__adc__api.html#ggac186093663d49a0c9d694073931f68f3a3faf5fd32b323c00dd7acee22ab4027b">ADC_CH_ADCINX_14</a> = 0xEU
, <a class="el" href="group__adc__api.html#ggac186093663d49a0c9d694073931f68f3a5cab692d00f1b78fd63a2fc392fbec66">ADC_CH_ADCINX_15</a> = 0xFU
<br />
 }</td></tr>
<tr class="separator:gac186093663d49a0c9d694073931f68f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4463487eb170cf7f23699e7f01407de"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gae4463487eb170cf7f23699e7f01407de">ADC_IntTrigger</a> { <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dead4acdf8ca5a203cf89c67c6d694b2571">ADC_INT_TRIGGER_EOC0</a> = 0x00
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407deaa0e0df9643f002c4d6c10e55c6d706e2">ADC_INT_TRIGGER_EOC1</a> = 0x01
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dead96d0ff5c846e3b6a1f261f9bb1bed7b">ADC_INT_TRIGGER_EOC2</a> = 0x02
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea8fe1c5a1301d86ff3a8c0ff5df0755e1">ADC_INT_TRIGGER_EOC3</a> = 0x03
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea5c8b209b2082703e8049a9274cfded31">ADC_INT_TRIGGER_EOC4</a> = 0x04
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea3cbd125de68d66ae2c85248a966dd38f">ADC_INT_TRIGGER_EOC5</a> = 0x05
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea7c24904e334f0fa486819ea7b784409c">ADC_INT_TRIGGER_EOC6</a> = 0x06
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407deaf6f18a3623bddd8b80311cfad41c6f46">ADC_INT_TRIGGER_EOC7</a> = 0x07
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea6a74db64e6456af9370382a7794388ab">ADC_INT_TRIGGER_EOC8</a> = 0x08
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea374338a5b0dcf9eccc5b1a4001919353">ADC_INT_TRIGGER_EOC9</a> = 0x09
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dead363cfbc6c9892cc0192d422d6ae12b7">ADC_INT_TRIGGER_EOC10</a> = 0x0A
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea2d3d9433df29fb7fa5a2ba0c0472eaed">ADC_INT_TRIGGER_EOC11</a> = 0x0B
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407deafc8eaf85e4437d37cf7269b0cd322d19">ADC_INT_TRIGGER_EOC12</a> = 0x0C
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea1821021d2f11ff390522e39ab01459ea">ADC_INT_TRIGGER_EOC13</a> = 0x0D
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea85901a0f3ca55488629c7fdd2236c83e">ADC_INT_TRIGGER_EOC14</a> = 0x0E
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea2beda0c3545710449cf83f72d188d8d6">ADC_INT_TRIGGER_EOC15</a> = 0x0F
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407deaf3562050107e667badd6bb16604e867b">ADC_INT_TRIGGER_EOC16</a> = 0x10
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea824cb0fdd7d1f6634eb6a6babcfe38f5">ADC_INT_TRIGGER_EOC17</a> = 0x11
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407deab327ccd869c6f93b76b5c2acf5082155">ADC_INT_TRIGGER_EOC18</a> = 0x12
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea71c1e5fe49d5eed2b5668dfc6b90afd5">ADC_INT_TRIGGER_EOC19</a> = 0x13
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dead98f93edc6cc8c66fb7c5df82bb0c740">ADC_INT_TRIGGER_EOC20</a> = 0x14
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407deaae00eb442b512f6ff46963fae3a607f2">ADC_INT_TRIGGER_EOC21</a> = 0x15
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea94928b762a977db6f3a5bfda3f881e02">ADC_INT_TRIGGER_EOC22</a> = 0x16
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea79f9371b37f92eab7c52abe9f175c844">ADC_INT_TRIGGER_EOC23</a> = 0x17
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407deae319ada4015d4af8da703544a4a5153e">ADC_INT_TRIGGER_EOC24</a> = 0x18
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea6cc98671377de577dee2ec8f1f482141">ADC_INT_TRIGGER_EOC25</a> = 0x19
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407deac3e3ef4763b8585b3a1dbe5b1d0c7682">ADC_INT_TRIGGER_EOC26</a> = 0x1A
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea939599e313e8fe46b07995f98d3af542">ADC_INT_TRIGGER_EOC27</a> = 0x1B
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea5f3d91ea8f8fa3c9982f8f757f6c1fcf">ADC_INT_TRIGGER_EOC28</a> = 0x1C
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea832e4585a3f48cdfe28d556bd1484f30">ADC_INT_TRIGGER_EOC29</a> = 0x1D
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea7e89b09471ea59d7f98e3bc60fd313aa">ADC_INT_TRIGGER_EOC30</a> = 0x1E
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea7231f8841a2f8c2d6dd93bcba143f077">ADC_INT_TRIGGER_EOC31</a> = 0x1F
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea6077eca8223871d0b5e08bf59dd5ac70">ADC_INT_TRIGGER_OSINT1</a> = 0x20
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dea4cedaff77ac3d94d4ef845f0e9ea37da">ADC_INT_TRIGGER_OSINT2</a> = 0x21
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407deabb84ea3813e57182fc573cbfbb299815">ADC_INT_TRIGGER_OSINT3</a> = 0x22
, <a class="el" href="group__adc__api.html#ggae4463487eb170cf7f23699e7f01407dead7a5eab7d36d3f6312cfe357dc8d44dd">ADC_INT_TRIGGER_OSINT4</a> = 0x23
<br />
 }</td></tr>
<tr class="separator:gae4463487eb170cf7f23699e7f01407de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0959e6a2d0772e9adc3327878252fe2a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga0959e6a2d0772e9adc3327878252fe2a">ADC_PPBCompSource</a> { <a class="el" href="group__adc__api.html#gga0959e6a2d0772e9adc3327878252fe2aa9adb1df4f3d9b2927906a8d086ec506f">ADC_PPB_COMPSOURCE_RESULT</a> = 0x0U
, <a class="el" href="group__adc__api.html#gga0959e6a2d0772e9adc3327878252fe2aaa889b4cd3438f66cf1bfcd99981fee73">ADC_PPB_COMPSOURCE_PSUM</a> = 0x1U
, <a class="el" href="group__adc__api.html#gga0959e6a2d0772e9adc3327878252fe2aac4553bb2628055d20ffa5c037fb58654">ADC_PPB_COMPSOURCE_SUM</a> = 0x2U
 }</td></tr>
<tr class="separator:ga0959e6a2d0772e9adc3327878252fe2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4f3f8888fe66b3d30d3947bee9dcbe8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaa4f3f8888fe66b3d30d3947bee9dcbe8">ADC_Select</a> { <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggaa4f3f8888fe66b3d30d3947bee9dcbe8ae398ae2c45d00fabcd33d7996ec25990">ADC_A</a> = 0U
, <a class="el" href="group__adc__api.html#ggaa4f3f8888fe66b3d30d3947bee9dcbe8a94bd2607f1acc7937a804fd453eea683">ADC_B</a> = 1U
, <a class="el" href="group__adc__api.html#ggaa4f3f8888fe66b3d30d3947bee9dcbe8a8750da840be0920a616b55bc5b5a3abd">ADC_C</a> = 2U
, <a class="el" href="group__adc__api.html#ggaa4f3f8888fe66b3d30d3947bee9dcbe8a090a86500ee6a10497c7856690f53f12">ADC_D</a> = 3U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#ggaa4f3f8888fe66b3d30d3947bee9dcbe8a2599993c48ae1cce505ccb134d7e9402">ADC_E</a> = 4U
<br />
 }</td></tr>
<tr class="separator:gaa4f3f8888fe66b3d30d3947bee9dcbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a948430846a59c84370fecfe2547790"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga0a948430846a59c84370fecfe2547790">ADC_ResultSelect</a> { <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790ae8905861fb673f5bfb763f9291ec351b">ADC_RESULT0</a> = 0U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a54a8927950a590489fc4568b4ac83bcc">ADC_RESULT1</a> = 1U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a93a9c52b65ac222370cc1f3c45d23071">ADC_RESULT2</a> = 2U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790abdf1cb92fc10946e401eb5f436a5c94d">ADC_RESULT3</a> = 3U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a8ea0ec67d0e95a959ee185b6f866eecc">ADC_RESULT4</a> = 4U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a3b18728c1d36ac406347211e764d8bcb">ADC_RESULT5</a> = 5U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790af167f4aa3414898fb963f29158b8a164">ADC_RESULT6</a> = 6U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790ad93dea9646ecb3acee631331603147b8">ADC_RESULT7</a> = 7U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a0145cc1be209224ea61bdbdd6c5def81">ADC_RESULT8</a> = 8U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a2ba9743d7e4b65467c16fb7d8de87f18">ADC_RESULT9</a> = 9U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a528ba67fe0f0e0e9dffe99f3afd0e04c">ADC_RESULT10</a> = 10U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790aadaf74c849446e6d815f02966ac21d06">ADC_RESULT11</a> = 11U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790ab12ca834d2057005807e8b9af6a5998e">ADC_RESULT12</a> = 12U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a8003eece708358f8f4306fe26aec9db7">ADC_RESULT13</a> = 13U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a4d25c0b90c49559be454d2ca634e16bc">ADC_RESULT14</a> = 14U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a69c7c0598f2534a1d4525952d017e6d2">ADC_RESULT15</a> = 15U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790af323af161149cf46bba7e6a3c0817ad2">ADC_RESULT16</a> = 16U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a4273d5df281a1e26512c127d36ad82d8">ADC_RESULT17</a> = 17U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a02394bc107d35852fe756434ce400aa4">ADC_RESULT18</a> = 18U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790ac73be1597ec5a1454f81e93d2ec6fb93">ADC_RESULT19</a> = 19U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a7df9ec9953bae63b428c80a4924b815e">ADC_RESULT20</a> = 20U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a8080662ed70239206a12ce6ad5429edf">ADC_RESULT21</a> = 21U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790aa223c0c03330d9f0e3a8136390442d08">ADC_RESULT22</a> = 22U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a23214c1fb684d15969ecb2e1220f2275">ADC_RESULT23</a> = 23U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790afbd1e6e4650146b2444908096264010d">ADC_RESULT24</a> = 24U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790ae4ac808643cb98647b8d3db0092b2677">ADC_RESULT25</a> = 25U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a285577e1420d1382e5cdeffac98dcfba">ADC_RESULT26</a> = 26U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790af402117a3cd5b5fcc14ca8453bc70c4b">ADC_RESULT27</a> = 27U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a09311a6786744c8fbc4ea3da3bccb0ec">ADC_RESULT28</a> = 28U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790aa166db34f918312891ea676bc4ae39d6">ADC_RESULT29</a> = 29U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a730928c4390939e519f132b059d59238">ADC_RESULT30</a> = 30U
, <a class="el" href="group__adc__api.html#gga0a948430846a59c84370fecfe2547790a9766cb00f5f99127f217e2546f6d3535">ADC_RESULT31</a> = 31U
<br />
 }</td></tr>
<tr class="separator:ga0a948430846a59c84370fecfe2547790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a99e2014f91f8a1542836553f3345d3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga9a99e2014f91f8a1542836553f3345d3">ADC_SafetyCheckerInput</a> { <a class="el" href="group__adc__api.html#gga9a99e2014f91f8a1542836553f3345d3a0d1d013975b50c7bea7925c77e4a0579">ADC_SAFETY_CHECKER_INPUT_DISABLE</a> = 0x0U
, <a class="el" href="group__adc__api.html#gga9a99e2014f91f8a1542836553f3345d3a1e0d07c76e8c5ecad787c243a6931129">ADC_SAFETY_CHECKER_INPUT_SOCx</a> = 0x1U
, <a class="el" href="group__adc__api.html#gga9a99e2014f91f8a1542836553f3345d3a88ed40901b2365c2694aa33fa571d5a1">ADC_SAFETY_CHECKER_INPUT_PPBx</a> = 0x2U
, <a class="el" href="group__adc__api.html#gga9a99e2014f91f8a1542836553f3345d3ad0617c4b6b1f6664307c3a3351890293">ADC_SAFETY_CHECKER_INPUT_PPBSUMx</a> = 0x3U
 }</td></tr>
<tr class="separator:ga9a99e2014f91f8a1542836553f3345d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0eaff3df07283db317190504ba7433c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaf0eaff3df07283db317190504ba7433c">ADC_SafetyCheckInst</a> { <a class="el" href="group__adc__api.html#ggaf0eaff3df07283db317190504ba7433ca5a9e1fb57d6252ee34238aa302aa4496">ADC_SAFETY_CHECK1</a> = 0x0U
, <a class="el" href="group__adc__api.html#ggaf0eaff3df07283db317190504ba7433ca7ecfbd9a593936234968e2514f1959cd">ADC_SAFETY_CHECK2</a> = 0x2U
 }</td></tr>
<tr class="separator:gaf0eaff3df07283db317190504ba7433c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga416fb154f5cfd167096b2968caa47a95"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga416fb154f5cfd167096b2968caa47a95">ADC_SafetyCheckEvent</a> { <a class="el" href="group__adc__api.html#gga416fb154f5cfd167096b2968caa47a95a14a0af99d06cf1395f0cb0df348e479b">ADC_SAFETY_CHECK_EVENT1</a> = 0U
, <a class="el" href="group__adc__api.html#gga416fb154f5cfd167096b2968caa47a95a34c053db7efd96686653ede1ed6d59ad">ADC_SAFETY_CHECK_EVENT2</a> = 8U
, <a class="el" href="group__adc__api.html#gga416fb154f5cfd167096b2968caa47a95a100ccd87db0ddd606c5dda4e79db4918">ADC_SAFETY_CHECK_EVENT3</a> = 16U
, <a class="el" href="group__adc__api.html#gga416fb154f5cfd167096b2968caa47a95a592cf6791472e192e999592526c908ef">ADC_SAFETY_CHECK_EVENT4</a> = 24U
 }</td></tr>
<tr class="separator:ga416fb154f5cfd167096b2968caa47a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe93f7735c9ef3508bb48319305ed633"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gafe93f7735c9ef3508bb48319305ed633">ADC_SafetyCheckResult</a> { <a class="el" href="group__adc__api.html#ggafe93f7735c9ef3508bb48319305ed633aa5bd5fbcfafc0667db3e0c0769b17336">ADC_SAFETY_CHECK_RES1OVF</a> = 0U
, <a class="el" href="group__adc__api.html#ggafe93f7735c9ef3508bb48319305ed633af5d963509a5649b28097ecc76fc30ac2">ADC_SAFETY_CHECK_RES2OVF</a> = 2U
, <a class="el" href="group__adc__api.html#ggafe93f7735c9ef3508bb48319305ed633a328fa625a01203a57bedeb211039b2fc">ADC_SAFETY_CHECK_OOT</a> = 4U
 }</td></tr>
<tr class="separator:gafe93f7735c9ef3508bb48319305ed633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67bf6616fde2efca32617144cb3f6d52"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga67bf6616fde2efca32617144cb3f6d52">ADC_Checker</a> { <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga67bf6616fde2efca32617144cb3f6d52ab0ab6f48b77203de324719ed5e592443">ADC_SAFETY_CHECKER1</a> = 0U
, <a class="el" href="group__adc__api.html#gga67bf6616fde2efca32617144cb3f6d52a476158cc78f35809881e98089f58c809">ADC_SAFETY_CHECKER2</a> = 1U
, <a class="el" href="group__adc__api.html#gga67bf6616fde2efca32617144cb3f6d52a46eeab673e58bcf1f7e1cc321045e9c8">ADC_SAFETY_CHECKER3</a> = 2U
, <a class="el" href="group__adc__api.html#gga67bf6616fde2efca32617144cb3f6d52a85c4cd65efd7c46736b5be790b23c7c8">ADC_SAFETY_CHECKER4</a> = 3U
, <br />
&#160;&#160;<a class="el" href="group__adc__api.html#gga67bf6616fde2efca32617144cb3f6d52add5be3934765579702c6b6becd4c2448">ADC_SAFETY_CHECKER5</a> = 4U
, <a class="el" href="group__adc__api.html#gga67bf6616fde2efca32617144cb3f6d52a7a1d842849506aa741b0fb7f1266e7d4">ADC_SAFETY_CHECKER6</a> = 5U
, <a class="el" href="group__adc__api.html#gga67bf6616fde2efca32617144cb3f6d52a6132cd35e92a4d95269b9b19f2587a40">ADC_SAFETY_CHECKER7</a> = 6U
, <a class="el" href="group__adc__api.html#gga67bf6616fde2efca32617144cb3f6d52a6594ccc5487bfe12fcd76fabe62e39be">ADC_SAFETY_CHECKER8</a> = 7U
<br />
 }</td></tr>
<tr class="separator:ga67bf6616fde2efca32617144cb3f6d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2e0c6a4e97d9e24868acc6adf7f97af"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaa2e0c6a4e97d9e24868acc6adf7f97af">ADC_SafetyCheckFlag</a> { <a class="el" href="group__adc__api.html#ggaa2e0c6a4e97d9e24868acc6adf7f97afa8c6978c1783e102d09b363a120d5d80c">ADC_SAFETY_CHECK_OOT_FLG</a> = 0U
, <a class="el" href="group__adc__api.html#ggaa2e0c6a4e97d9e24868acc6adf7f97afa6cb6fa00c2e2d1736c4bacdf63c1e605">ADC_SAFETY_CHECK_RES1OVF_FLG</a> = 4U
, <a class="el" href="group__adc__api.html#ggaa2e0c6a4e97d9e24868acc6adf7f97afa8c42a983bc073e705be431a71bcacfc4">ADC_SAFETY_CHECK_RES2OVF_FLG</a> = 8U
 }</td></tr>
<tr class="separator:gaa2e0c6a4e97d9e24868acc6adf7f97af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38766c01be33adece810b912d379bf31"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga38766c01be33adece810b912d379bf31">ADC_RepInstance</a> { <a class="el" href="group__adc__api.html#gga38766c01be33adece810b912d379bf31a7dc9a0cd69ba103a635dd46c7634a4d0">ADC_REPINST1</a> = 0x0U
, <a class="el" href="group__adc__api.html#gga38766c01be33adece810b912d379bf31a5758993fe56f6fd9c0f68eccee9ea3d7">ADC_REPINST2</a> = 0x1U
 }</td></tr>
<tr class="separator:ga38766c01be33adece810b912d379bf31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga697935a135bb2cea5c47e73dc37e2ba3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga697935a135bb2cea5c47e73dc37e2ba3">ADC_RepMode</a> { <a class="el" href="group__adc__api.html#gga697935a135bb2cea5c47e73dc37e2ba3a8e0aefa6cbb5b36a9d72ad780d0d862c">ADC_REPMODE_OVERSAMPLING</a> = 0x0U
, <a class="el" href="group__adc__api.html#gga697935a135bb2cea5c47e73dc37e2ba3aede1e148206378d0b048e8a6c24647a7">ADC_REPMODE_UNDERSAMPLING</a> = 0x1U
 }</td></tr>
<tr class="separator:ga697935a135bb2cea5c47e73dc37e2ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga88d04369ecd4b4f0d62689d85725c154"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga88d04369ecd4b4f0d62689d85725c154">ADC_NUM_INTERRUPTS</a>&#160;&#160;&#160;4U</td></tr>
<tr class="separator:ga88d04369ecd4b4f0d62689d85725c154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68f8653816fd2da9ed485b770ce4962f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga68f8653816fd2da9ed485b770ce4962f">ADC_SOCxCTL_OFFSET_BASE</a>&#160;&#160;&#160;ADC_O_SOC0CTL</td></tr>
<tr class="separator:ga68f8653816fd2da9ed485b770ce4962f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa112157a688d3a93ad050744df519d8c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaa112157a688d3a93ad050744df519d8c">ADC_RESULTx_OFFSET_BASE</a>&#160;&#160;&#160;ADC_O_RESULT0</td></tr>
<tr class="separator:gaa112157a688d3a93ad050744df519d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5080ff53784043785bca57fbef96203a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga5080ff53784043785bca57fbef96203a">ADC_INTSELxNy_OFFSET_BASE</a>&#160;&#160;&#160;ADC_O_INTSEL1N2</td></tr>
<tr class="separator:ga5080ff53784043785bca57fbef96203a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab93b3d59039266605bee26e11b6077be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gab93b3d59039266605bee26e11b6077be">ADC_PPBxRESULT_OFFSET_BASE</a>&#160;&#160;&#160;ADC_O_PPB1RESULT</td></tr>
<tr class="separator:gab93b3d59039266605bee26e11b6077be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga176a93bffba08939c5605585de69e991"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga176a93bffba08939c5605585de69e991">REPCTL_MASK</a></td></tr>
<tr class="separator:ga176a93bffba08939c5605585de69e991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1b5698287de79f5f1577fcda816386"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga0d1b5698287de79f5f1577fcda816386">ADC_PPBxPSUM_OFFSET_BASE</a>&#160;&#160;&#160;ADC_O_PPB1PSUM</td></tr>
<tr class="separator:ga0d1b5698287de79f5f1577fcda816386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga437d861f409a157db3f2d9a07344dfca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga437d861f409a157db3f2d9a07344dfca">ADC_PPBxPCOUNT_OFFSET_BASE</a>&#160;&#160;&#160;ADC_O_PPBP1PCOUNT</td></tr>
<tr class="separator:ga437d861f409a157db3f2d9a07344dfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ef83b3a78d0983af6c5f2ab72833751"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga9ef83b3a78d0983af6c5f2ab72833751">ADC_PPBxPMAX_OFFSET_BASE</a>&#160;&#160;&#160;ADC_O_PPB1PMAX</td></tr>
<tr class="separator:ga9ef83b3a78d0983af6c5f2ab72833751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaab63fb1795587086e1f46416864e2be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaaab63fb1795587086e1f46416864e2be">ADC_PPBxPMIN_OFFSET_BASE</a>&#160;&#160;&#160;ADC_O_PPB1PMIN</td></tr>
<tr class="separator:gaaab63fb1795587086e1f46416864e2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad02c12204c2dc93c27b2500530961b15"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gad02c12204c2dc93c27b2500530961b15">ADC_PPBxPMAXI_OFFSET_BASE</a>&#160;&#160;&#160;ADC_O_PPB1PMAXI</td></tr>
<tr class="separator:gad02c12204c2dc93c27b2500530961b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc8d0aced8122b23437d2ad4e1e143b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gadc8d0aced8122b23437d2ad4e1e143b7">ADC_PPBxPMINI_OFFSET_BASE</a>&#160;&#160;&#160;ADC_O_PPB1PMINI</td></tr>
<tr class="separator:gadc8d0aced8122b23437d2ad4e1e143b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2af0e663819cf9b1c812f40d2c39b9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaf2af0e663819cf9b1c812f40d2c39b9f">ADC_PPBxLIMIT_OFFSET_BASE</a>&#160;&#160;&#160;ADC_O_PPB1LIMIT</td></tr>
<tr class="separator:gaf2af0e663819cf9b1c812f40d2c39b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d1b25bfa0a3e3943018cfb170511a04"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga9d1b25bfa0a3e3943018cfb170511a04">ADC_PPBxSUM_OFFSET_BASE</a>&#160;&#160;&#160;ADC_O_PPB1SUM</td></tr>
<tr class="separator:ga9d1b25bfa0a3e3943018cfb170511a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a70b72944ed25738a637efa0e0ee2e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga5a70b72944ed25738a637efa0e0ee2e7">ADC_PPBxCOUNT_OFFSET_BASE</a>&#160;&#160;&#160;ADC_O_PPB1COUNT</td></tr>
<tr class="separator:ga5a70b72944ed25738a637efa0e0ee2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ca65192da9ebeda9cfd6a649f4ebb40"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga7ca65192da9ebeda9cfd6a649f4ebb40">ADC_PPBxMAX_OFFSET_BASE</a>&#160;&#160;&#160;ADC_O_PPB1MAX</td></tr>
<tr class="separator:ga7ca65192da9ebeda9cfd6a649f4ebb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1228b21a75ea02767101524fbc3d41d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga1228b21a75ea02767101524fbc3d41d8">ADC_PPBxMIN_OFFSET_BASE</a>&#160;&#160;&#160;ADC_O_PPB1MIN</td></tr>
<tr class="separator:ga1228b21a75ea02767101524fbc3d41d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5092b64861c237074c57a7218890fc87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga5092b64861c237074c57a7218890fc87">ADC_PPBxMAXI_OFFSET_BASE</a>&#160;&#160;&#160;ADC_O_PPB1MAXI</td></tr>
<tr class="separator:ga5092b64861c237074c57a7218890fc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga732d9c8c6ef51e36ad606c480c0908f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga732d9c8c6ef51e36ad606c480c0908f7">ADC_PPBxMINI_OFFSET_BASE</a>&#160;&#160;&#160;ADC_O_PPB1MINI</td></tr>
<tr class="separator:ga732d9c8c6ef51e36ad606c480c0908f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1d4cd59c8a2a2110cccb8e467d3e960"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gad1d4cd59c8a2a2110cccb8e467d3e960">ADC_PPBxLIMIT_STEP</a>&#160;&#160;&#160;(ADC_O_PPB2LIMIT - ADC_O_PPB1LIMIT)</td></tr>
<tr class="separator:gad1d4cd59c8a2a2110cccb8e467d3e960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80f6cf1c61ec2fd93b0144bef7f4309b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga80f6cf1c61ec2fd93b0144bef7f4309b">ADC_PPBxCONFIG2_STEP</a>&#160;&#160;&#160;(ADC_O_PPB2CONFIG2 - ADC_O_PPB1CONFIG2)</td></tr>
<tr class="separator:ga80f6cf1c61ec2fd93b0144bef7f4309b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18b630821695c4f84107fefaf46029fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga18b630821695c4f84107fefaf46029fd">ADC_REPxCTL_STEP</a>&#160;&#160;&#160;(ADC_O_REP2CTL - ADC_O_REP1CTL)</td></tr>
<tr class="separator:ga18b630821695c4f84107fefaf46029fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0167dca0841afbbc9e025637777f823"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gab0167dca0841afbbc9e025637777f823">ADC_REPxN_STEP</a>&#160;&#160;&#160;(ADC_O_REP2N - ADC_O_REP1N)</td></tr>
<tr class="separator:gab0167dca0841afbbc9e025637777f823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga195cf6f40375fe236fdee8ad5c518c05"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga195cf6f40375fe236fdee8ad5c518c05">ADC_REPxPHASE_STEP</a>&#160;&#160;&#160;(ADC_O_REP2PHASE - ADC_O_REP1PHASE)</td></tr>
<tr class="separator:ga195cf6f40375fe236fdee8ad5c518c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8cbd5f49478d43ffacae4dd6d7e455"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaee8cbd5f49478d43ffacae4dd6d7e455">ADC_REPxSPREAD_STEP</a>&#160;&#160;&#160;(ADC_O_REP2SPREAD - ADC_O_REP1SPREAD)</td></tr>
<tr class="separator:gaee8cbd5f49478d43ffacae4dd6d7e455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bafdd4dbb1a1d7b88cd2894021d35b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga5bafdd4dbb1a1d7b88cd2894021d35b6">ADC_PPBTRIP_MASK</a>&#160;&#160;&#160;(uint32_t)ADC_PPB1TRIPHI_LIMITHI_M</td></tr>
<tr class="separator:ga5bafdd4dbb1a1d7b88cd2894021d35b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed40a85717c6c033f8e14af8eadb00c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaed40a85717c6c033f8e14af8eadb00c1">ADC_PPBxTRIPLO2_STEP</a>&#160;&#160;&#160;(ADC_O_PPB2TRIPLO2 - ADC_O_PPB1TRIPLO2)</td></tr>
<tr class="separator:gaed40a85717c6c033f8e14af8eadb00c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc6bdbd41b411aac98ed70aae0409333"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gabc6bdbd41b411aac98ed70aae0409333">ADC_PPBxCONFIG_STEP</a>&#160;&#160;&#160;(ADC_O_PPB2CONFIG - ADC_O_PPB1CONFIG)</td></tr>
<tr class="separator:gabc6bdbd41b411aac98ed70aae0409333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa48fe3f2e0ef31a0b05a116c34893314"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaa48fe3f2e0ef31a0b05a116c34893314">ADC_PPBxTRIPHI_STEP</a>&#160;&#160;&#160;(ADC_O_PPB2TRIPHI - ADC_O_PPB1TRIPHI)</td></tr>
<tr class="separator:gaa48fe3f2e0ef31a0b05a116c34893314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae674bf5583947a8c5665cc2b908b3053"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gae674bf5583947a8c5665cc2b908b3053">ADC_PPBxTRIPLO_STEP</a>&#160;&#160;&#160;(ADC_O_PPB2TRIPLO - ADC_O_PPB1TRIPLO)</td></tr>
<tr class="separator:gae674bf5583947a8c5665cc2b908b3053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab26a0a07d759eecd3ab68b02eac12c27"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gab26a0a07d759eecd3ab68b02eac12c27">ADC_PPBxSTAMP_STEP</a>&#160;&#160;&#160;(ADC_O_PPB2STAMP - ADC_O_PPB1STAMP)</td></tr>
<tr class="separator:gab26a0a07d759eecd3ab68b02eac12c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga814daeb44e4839dce3066526745774aa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga814daeb44e4839dce3066526745774aa">ADC_PPBxOFFCAL_STEP</a>&#160;&#160;&#160;(ADC_O_PPB2OFFCAL - ADC_O_PPB1OFFCAL)</td></tr>
<tr class="separator:ga814daeb44e4839dce3066526745774aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35370a5262c1ac07f4632525cfb9a22d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga35370a5262c1ac07f4632525cfb9a22d">ADC_PPBxOFFREF_STEP</a>&#160;&#160;&#160;(ADC_O_PPB2OFFREF - ADC_O_PPB1OFFREF)</td></tr>
<tr class="separator:ga35370a5262c1ac07f4632525cfb9a22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97668ed9382ff2bb9394639953da28be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga97668ed9382ff2bb9394639953da28be">ADC_INT_REF_TSSLOPE</a>&#160;&#160;&#160;(*(int16_t *)((uintptr_t)0x20000FDC))</td></tr>
<tr class="separator:ga97668ed9382ff2bb9394639953da28be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36eb294ee1f115e334fc48af8cd63095"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga36eb294ee1f115e334fc48af8cd63095">ADC_INT_REF_TSOFFSET</a>&#160;&#160;&#160;(*(int16_t *)((uintptr_t)0x20000FE0))</td></tr>
<tr class="separator:ga36eb294ee1f115e334fc48af8cd63095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdf6f073dd1336bc9d4a386155bb53a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gacdf6f073dd1336bc9d4a386155bb53a3">ADC_EXT_REF_TSSLOPE</a>&#160;&#160;&#160;(*(int16_t *)((uintptr_t)0x20000FD4))</td></tr>
<tr class="separator:gacdf6f073dd1336bc9d4a386155bb53a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cd21facf4d774ca7afc43a915246fe7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga7cd21facf4d774ca7afc43a915246fe7">ADC_EXT_REF_TSOFFSET</a>&#160;&#160;&#160;(*(int16_t *)((uintptr_t)0x20000FD8))</td></tr>
<tr class="separator:ga7cd21facf4d774ca7afc43a915246fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55b4edea639bba1c6e05726b23aeaf3c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga55b4edea639bba1c6e05726b23aeaf3c">ADC_EVT_TRIPHI</a>&#160;&#160;&#160;0x0001U</td></tr>
<tr class="memdesc:ga55b4edea639bba1c6e05726b23aeaf3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trip High Event.  <a href="group__adc__api.html#ga55b4edea639bba1c6e05726b23aeaf3c">More...</a><br /></td></tr>
<tr class="separator:ga55b4edea639bba1c6e05726b23aeaf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fceea30c153bbc9d27c7097620dc958"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga8fceea30c153bbc9d27c7097620dc958">ADC_EVT_TRIPLO</a>&#160;&#160;&#160;0x0002U</td></tr>
<tr class="memdesc:ga8fceea30c153bbc9d27c7097620dc958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trip Low Event.  <a href="group__adc__api.html#ga8fceea30c153bbc9d27c7097620dc958">More...</a><br /></td></tr>
<tr class="separator:ga8fceea30c153bbc9d27c7097620dc958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbe53d8a8e55fff293d0642f9bea6c08"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gacbe53d8a8e55fff293d0642f9bea6c08">ADC_EVT_ZERO</a>&#160;&#160;&#160;0x0004U</td></tr>
<tr class="memdesc:gacbe53d8a8e55fff293d0642f9bea6c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero Crossing Event.  <a href="group__adc__api.html#gacbe53d8a8e55fff293d0642f9bea6c08">More...</a><br /></td></tr>
<tr class="separator:gacbe53d8a8e55fff293d0642f9bea6c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5546f06bbe099383e97e8b14c1d7a072"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga5546f06bbe099383e97e8b14c1d7a072">ADC_FORCE_SOC0</a>&#160;&#160;&#160;0x00000001U</td></tr>
<tr class="memdesc:ga5546f06bbe099383e97e8b14c1d7a072"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 0.  <a href="group__adc__api.html#ga5546f06bbe099383e97e8b14c1d7a072">More...</a><br /></td></tr>
<tr class="separator:ga5546f06bbe099383e97e8b14c1d7a072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a89bbd990a8266b5c104056b3a27e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga34a89bbd990a8266b5c104056b3a27e7">ADC_FORCE_SOC1</a>&#160;&#160;&#160;0x00000002U</td></tr>
<tr class="memdesc:ga34a89bbd990a8266b5c104056b3a27e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 1.  <a href="group__adc__api.html#ga34a89bbd990a8266b5c104056b3a27e7">More...</a><br /></td></tr>
<tr class="separator:ga34a89bbd990a8266b5c104056b3a27e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72f6effcfb943dcdae134673dff51598"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga72f6effcfb943dcdae134673dff51598">ADC_FORCE_SOC2</a>&#160;&#160;&#160;0x00000004U</td></tr>
<tr class="memdesc:ga72f6effcfb943dcdae134673dff51598"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 2.  <a href="group__adc__api.html#ga72f6effcfb943dcdae134673dff51598">More...</a><br /></td></tr>
<tr class="separator:ga72f6effcfb943dcdae134673dff51598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b66e439cf7b5b4d5e14ef0d7915e7ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga9b66e439cf7b5b4d5e14ef0d7915e7ed">ADC_FORCE_SOC3</a>&#160;&#160;&#160;0x00000008U</td></tr>
<tr class="memdesc:ga9b66e439cf7b5b4d5e14ef0d7915e7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 3.  <a href="group__adc__api.html#ga9b66e439cf7b5b4d5e14ef0d7915e7ed">More...</a><br /></td></tr>
<tr class="separator:ga9b66e439cf7b5b4d5e14ef0d7915e7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3486abfa85d7db062e93c79fd98108c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga3486abfa85d7db062e93c79fd98108c2">ADC_FORCE_SOC4</a>&#160;&#160;&#160;0x00000010U</td></tr>
<tr class="memdesc:ga3486abfa85d7db062e93c79fd98108c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 4.  <a href="group__adc__api.html#ga3486abfa85d7db062e93c79fd98108c2">More...</a><br /></td></tr>
<tr class="separator:ga3486abfa85d7db062e93c79fd98108c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga706eb5885d18f368a605395fef52f10e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga706eb5885d18f368a605395fef52f10e">ADC_FORCE_SOC5</a>&#160;&#160;&#160;0x00000020U</td></tr>
<tr class="memdesc:ga706eb5885d18f368a605395fef52f10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 5.  <a href="group__adc__api.html#ga706eb5885d18f368a605395fef52f10e">More...</a><br /></td></tr>
<tr class="separator:ga706eb5885d18f368a605395fef52f10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d517b84b7a0c2d9c86fe3cfaa4d58c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga45d517b84b7a0c2d9c86fe3cfaa4d58c">ADC_FORCE_SOC6</a>&#160;&#160;&#160;0x00000040U</td></tr>
<tr class="memdesc:ga45d517b84b7a0c2d9c86fe3cfaa4d58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 6.  <a href="group__adc__api.html#ga45d517b84b7a0c2d9c86fe3cfaa4d58c">More...</a><br /></td></tr>
<tr class="separator:ga45d517b84b7a0c2d9c86fe3cfaa4d58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03a41bc17f74223f884ab1d2b95fe202"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga03a41bc17f74223f884ab1d2b95fe202">ADC_FORCE_SOC7</a>&#160;&#160;&#160;0x00000080U</td></tr>
<tr class="memdesc:ga03a41bc17f74223f884ab1d2b95fe202"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 7.  <a href="group__adc__api.html#ga03a41bc17f74223f884ab1d2b95fe202">More...</a><br /></td></tr>
<tr class="separator:ga03a41bc17f74223f884ab1d2b95fe202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0374de833882347f3e55911739cf1af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gae0374de833882347f3e55911739cf1af">ADC_FORCE_SOC8</a>&#160;&#160;&#160;0x00000100U</td></tr>
<tr class="memdesc:gae0374de833882347f3e55911739cf1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 8.  <a href="group__adc__api.html#gae0374de833882347f3e55911739cf1af">More...</a><br /></td></tr>
<tr class="separator:gae0374de833882347f3e55911739cf1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d6649d983e8e3b4104e7e348d216512"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga6d6649d983e8e3b4104e7e348d216512">ADC_FORCE_SOC9</a>&#160;&#160;&#160;0x00000200U</td></tr>
<tr class="memdesc:ga6d6649d983e8e3b4104e7e348d216512"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 9.  <a href="group__adc__api.html#ga6d6649d983e8e3b4104e7e348d216512">More...</a><br /></td></tr>
<tr class="separator:ga6d6649d983e8e3b4104e7e348d216512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae035db14e59bc94f8a2cbe090310e789"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gae035db14e59bc94f8a2cbe090310e789">ADC_FORCE_SOC10</a>&#160;&#160;&#160;0x00000400U</td></tr>
<tr class="memdesc:gae035db14e59bc94f8a2cbe090310e789"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 10.  <a href="group__adc__api.html#gae035db14e59bc94f8a2cbe090310e789">More...</a><br /></td></tr>
<tr class="separator:gae035db14e59bc94f8a2cbe090310e789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccfc3b01bc20ec72c7c2f942e3ffd126"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaccfc3b01bc20ec72c7c2f942e3ffd126">ADC_FORCE_SOC11</a>&#160;&#160;&#160;0x00000800U</td></tr>
<tr class="memdesc:gaccfc3b01bc20ec72c7c2f942e3ffd126"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 11.  <a href="group__adc__api.html#gaccfc3b01bc20ec72c7c2f942e3ffd126">More...</a><br /></td></tr>
<tr class="separator:gaccfc3b01bc20ec72c7c2f942e3ffd126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5406d791b02b1a03113ad092df1c1d6b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga5406d791b02b1a03113ad092df1c1d6b">ADC_FORCE_SOC12</a>&#160;&#160;&#160;0x00001000U</td></tr>
<tr class="memdesc:ga5406d791b02b1a03113ad092df1c1d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 12.  <a href="group__adc__api.html#ga5406d791b02b1a03113ad092df1c1d6b">More...</a><br /></td></tr>
<tr class="separator:ga5406d791b02b1a03113ad092df1c1d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga508d12a6dce4ff635b1f4985a4c73586"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga508d12a6dce4ff635b1f4985a4c73586">ADC_FORCE_SOC13</a>&#160;&#160;&#160;0x00002000U</td></tr>
<tr class="memdesc:ga508d12a6dce4ff635b1f4985a4c73586"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 13.  <a href="group__adc__api.html#ga508d12a6dce4ff635b1f4985a4c73586">More...</a><br /></td></tr>
<tr class="separator:ga508d12a6dce4ff635b1f4985a4c73586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga879cfb1b496ef7148754cc51c623a2b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga879cfb1b496ef7148754cc51c623a2b2">ADC_FORCE_SOC14</a>&#160;&#160;&#160;0x00004000U</td></tr>
<tr class="memdesc:ga879cfb1b496ef7148754cc51c623a2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 14.  <a href="group__adc__api.html#ga879cfb1b496ef7148754cc51c623a2b2">More...</a><br /></td></tr>
<tr class="separator:ga879cfb1b496ef7148754cc51c623a2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ac4cb4163b351c54459f8fa4f6cb125"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga1ac4cb4163b351c54459f8fa4f6cb125">ADC_FORCE_SOC15</a>&#160;&#160;&#160;0x00008000U</td></tr>
<tr class="memdesc:ga1ac4cb4163b351c54459f8fa4f6cb125"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 15.  <a href="group__adc__api.html#ga1ac4cb4163b351c54459f8fa4f6cb125">More...</a><br /></td></tr>
<tr class="separator:ga1ac4cb4163b351c54459f8fa4f6cb125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ae8212cd502d31246bb2fb9f3d26881"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga5ae8212cd502d31246bb2fb9f3d26881">ADC_FORCE_SOC16</a>&#160;&#160;&#160;0x00010000U</td></tr>
<tr class="memdesc:ga5ae8212cd502d31246bb2fb9f3d26881"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 16.  <a href="group__adc__api.html#ga5ae8212cd502d31246bb2fb9f3d26881">More...</a><br /></td></tr>
<tr class="separator:ga5ae8212cd502d31246bb2fb9f3d26881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f780dd8fe40de9e50c060c799caff8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga88f780dd8fe40de9e50c060c799caff8">ADC_FORCE_SOC17</a>&#160;&#160;&#160;0x00020000U</td></tr>
<tr class="memdesc:ga88f780dd8fe40de9e50c060c799caff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 17.  <a href="group__adc__api.html#ga88f780dd8fe40de9e50c060c799caff8">More...</a><br /></td></tr>
<tr class="separator:ga88f780dd8fe40de9e50c060c799caff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c88ca9a825758b806e57397e0ef0db0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga8c88ca9a825758b806e57397e0ef0db0">ADC_FORCE_SOC18</a>&#160;&#160;&#160;0x00040000U</td></tr>
<tr class="memdesc:ga8c88ca9a825758b806e57397e0ef0db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 18.  <a href="group__adc__api.html#ga8c88ca9a825758b806e57397e0ef0db0">More...</a><br /></td></tr>
<tr class="separator:ga8c88ca9a825758b806e57397e0ef0db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa896c2174ff99227cb850e118d636f75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaa896c2174ff99227cb850e118d636f75">ADC_FORCE_SOC19</a>&#160;&#160;&#160;0x00080000U</td></tr>
<tr class="memdesc:gaa896c2174ff99227cb850e118d636f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 19.  <a href="group__adc__api.html#gaa896c2174ff99227cb850e118d636f75">More...</a><br /></td></tr>
<tr class="separator:gaa896c2174ff99227cb850e118d636f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9de3d8216ea0028eaa617184f61335"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga9f9de3d8216ea0028eaa617184f61335">ADC_FORCE_SOC20</a>&#160;&#160;&#160;0x00100000U</td></tr>
<tr class="memdesc:ga9f9de3d8216ea0028eaa617184f61335"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 20.  <a href="group__adc__api.html#ga9f9de3d8216ea0028eaa617184f61335">More...</a><br /></td></tr>
<tr class="separator:ga9f9de3d8216ea0028eaa617184f61335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc49093cf9409c7e8827e6d9e68005b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gacc49093cf9409c7e8827e6d9e68005b9">ADC_FORCE_SOC21</a>&#160;&#160;&#160;0x00200000U</td></tr>
<tr class="memdesc:gacc49093cf9409c7e8827e6d9e68005b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 21.  <a href="group__adc__api.html#gacc49093cf9409c7e8827e6d9e68005b9">More...</a><br /></td></tr>
<tr class="separator:gacc49093cf9409c7e8827e6d9e68005b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc914ca4900539cf2fe5125f8e6ab50d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gafc914ca4900539cf2fe5125f8e6ab50d">ADC_FORCE_SOC22</a>&#160;&#160;&#160;0x00400000U</td></tr>
<tr class="memdesc:gafc914ca4900539cf2fe5125f8e6ab50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 22.  <a href="group__adc__api.html#gafc914ca4900539cf2fe5125f8e6ab50d">More...</a><br /></td></tr>
<tr class="separator:gafc914ca4900539cf2fe5125f8e6ab50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga714080d7f318bad211c7551292e998c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga714080d7f318bad211c7551292e998c7">ADC_FORCE_SOC23</a>&#160;&#160;&#160;0x00800000U</td></tr>
<tr class="memdesc:ga714080d7f318bad211c7551292e998c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 23.  <a href="group__adc__api.html#ga714080d7f318bad211c7551292e998c7">More...</a><br /></td></tr>
<tr class="separator:ga714080d7f318bad211c7551292e998c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfb2ad31f9936deb1131dc2dcba7f35c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gacfb2ad31f9936deb1131dc2dcba7f35c">ADC_FORCE_SOC24</a>&#160;&#160;&#160;0x01000000U</td></tr>
<tr class="memdesc:gacfb2ad31f9936deb1131dc2dcba7f35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 24.  <a href="group__adc__api.html#gacfb2ad31f9936deb1131dc2dcba7f35c">More...</a><br /></td></tr>
<tr class="separator:gacfb2ad31f9936deb1131dc2dcba7f35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaace300ee445c0691e92b50e8a0ffc37f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaace300ee445c0691e92b50e8a0ffc37f">ADC_FORCE_SOC25</a>&#160;&#160;&#160;0x02000000U</td></tr>
<tr class="memdesc:gaace300ee445c0691e92b50e8a0ffc37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 25.  <a href="group__adc__api.html#gaace300ee445c0691e92b50e8a0ffc37f">More...</a><br /></td></tr>
<tr class="separator:gaace300ee445c0691e92b50e8a0ffc37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac32359c82fca03a4ba8ea219afa4ac55"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gac32359c82fca03a4ba8ea219afa4ac55">ADC_FORCE_SOC26</a>&#160;&#160;&#160;0x04000000U</td></tr>
<tr class="memdesc:gac32359c82fca03a4ba8ea219afa4ac55"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 26.  <a href="group__adc__api.html#gac32359c82fca03a4ba8ea219afa4ac55">More...</a><br /></td></tr>
<tr class="separator:gac32359c82fca03a4ba8ea219afa4ac55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad08030c86ba83810af4b4725b1a0d3c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gad08030c86ba83810af4b4725b1a0d3c1">ADC_FORCE_SOC27</a>&#160;&#160;&#160;0x08000000U</td></tr>
<tr class="memdesc:gad08030c86ba83810af4b4725b1a0d3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 27.  <a href="group__adc__api.html#gad08030c86ba83810af4b4725b1a0d3c1">More...</a><br /></td></tr>
<tr class="separator:gad08030c86ba83810af4b4725b1a0d3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafed6f010b9f5df13b2935f440f6f4898"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gafed6f010b9f5df13b2935f440f6f4898">ADC_FORCE_SOC28</a>&#160;&#160;&#160;0x10000000U</td></tr>
<tr class="memdesc:gafed6f010b9f5df13b2935f440f6f4898"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 28.  <a href="group__adc__api.html#gafed6f010b9f5df13b2935f440f6f4898">More...</a><br /></td></tr>
<tr class="separator:gafed6f010b9f5df13b2935f440f6f4898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66d27d72a84d22a7adaa5d0f765ad9a4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga66d27d72a84d22a7adaa5d0f765ad9a4">ADC_FORCE_SOC29</a>&#160;&#160;&#160;0x20000000U</td></tr>
<tr class="memdesc:ga66d27d72a84d22a7adaa5d0f765ad9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 29.  <a href="group__adc__api.html#ga66d27d72a84d22a7adaa5d0f765ad9a4">More...</a><br /></td></tr>
<tr class="separator:ga66d27d72a84d22a7adaa5d0f765ad9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga264974c0a10a96099b1553c3eec8d83a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga264974c0a10a96099b1553c3eec8d83a">ADC_FORCE_SOC30</a>&#160;&#160;&#160;0x40000000U</td></tr>
<tr class="memdesc:ga264974c0a10a96099b1553c3eec8d83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 30.  <a href="group__adc__api.html#ga264974c0a10a96099b1553c3eec8d83a">More...</a><br /></td></tr>
<tr class="separator:ga264974c0a10a96099b1553c3eec8d83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15c190f48b52b4d7017f09b75549d65d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga15c190f48b52b4d7017f09b75549d65d">ADC_FORCE_SOC31</a>&#160;&#160;&#160;0x80000000U</td></tr>
<tr class="memdesc:ga15c190f48b52b4d7017f09b75549d65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SW trigger ADC SOC 31.  <a href="group__adc__api.html#ga15c190f48b52b4d7017f09b75549d65d">More...</a><br /></td></tr>
<tr class="separator:ga15c190f48b52b4d7017f09b75549d65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c29fcb97890c54886e8148fcae13b0e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga0c29fcb97890c54886e8148fcae13b0e">ADC_REPEATER_MODULE_BUSY</a>&#160;&#160;&#160;ADC_REP1CTL_MODULEBUSY</td></tr>
<tr class="separator:ga0c29fcb97890c54886e8148fcae13b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb5b3d7ea7ba3956eb6d356713d97fb4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaeb5b3d7ea7ba3956eb6d356713d97fb4">ADC_REPEATER_PHASE_OVERFLOW</a>&#160;&#160;&#160;ADC_REP1CTL_PHASEOVF</td></tr>
<tr class="separator:gaeb5b3d7ea7ba3956eb6d356713d97fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67e90dbc3264701cb8fef3cd7e64ad5b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga67e90dbc3264701cb8fef3cd7e64ad5b">ADC_REPEATER_TRIGGER_OVERFLOW</a>&#160;&#160;&#160;ADC_REP1CTL_TRIGGEROVF</td></tr>
<tr class="separator:ga67e90dbc3264701cb8fef3cd7e64ad5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga869b25bb4e431bfcd0eb9e1665e89284"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga869b25bb4e431bfcd0eb9e1665e89284">ADC_REP1CTL_ACTIVEMODE_S</a>&#160;&#160;&#160;1U</td></tr>
<tr class="separator:ga869b25bb4e431bfcd0eb9e1665e89284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab842e8dcd72fbf8a8b0d2278ed737701"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gab842e8dcd72fbf8a8b0d2278ed737701">ADC_REP1CTL_MODULEBUSY_S</a>&#160;&#160;&#160;3U</td></tr>
<tr class="separator:gab842e8dcd72fbf8a8b0d2278ed737701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24bde289150fdfe7017a65d553223e99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga24bde289150fdfe7017a65d553223e99">ADC_REPSTATUS_MASK</a></td></tr>
<tr class="separator:ga24bde289150fdfe7017a65d553223e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4b4c23352d2de6c4bc59e178bfade2d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gaf4b4c23352d2de6c4bc59e178bfade2d">ADC_SAFECHECK_RESULT1_READY</a>&#160;&#160;&#160;ADC_CHECKSTATUS_RES1READY</td></tr>
<tr class="separator:gaf4b4c23352d2de6c4bc59e178bfade2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga666c9dd2e3e90aed82d5fb4bdda7d375"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga666c9dd2e3e90aed82d5fb4bdda7d375">ADC_SAFECHECK_RESULT2_READY</a>&#160;&#160;&#160;ADC_CHECKSTATUS_RES2READY</td></tr>
<tr class="separator:ga666c9dd2e3e90aed82d5fb4bdda7d375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd5c9b85d06443346e86a2774a99f146"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#gacd5c9b85d06443346e86a2774a99f146">ADC_SAFECHECK_RESULT_OOT</a>&#160;&#160;&#160;ADC_CHECKSTATUS_OOT</td></tr>
<tr class="separator:gacd5c9b85d06443346e86a2774a99f146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c7b38627e6d64398b4c067c1eba335e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc__api.html#ga4c7b38627e6d64398b4c067c1eba335e">ADC_SAFECHECK_STATUS_MASK</a></td></tr>
<tr class="separator:ga4c7b38627e6d64398b4c067c1eba335e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga88d04369ecd4b4f0d62689d85725c154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88d04369ecd4b4f0d62689d85725c154">&#9670;&nbsp;</a></span>ADC_NUM_INTERRUPTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_NUM_INTERRUPTS&#160;&#160;&#160;4U</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga68f8653816fd2da9ed485b770ce4962f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68f8653816fd2da9ed485b770ce4962f">&#9670;&nbsp;</a></span>ADC_SOCxCTL_OFFSET_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_SOCxCTL_OFFSET_BASE&#160;&#160;&#160;ADC_O_SOC0CTL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa112157a688d3a93ad050744df519d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa112157a688d3a93ad050744df519d8c">&#9670;&nbsp;</a></span>ADC_RESULTx_OFFSET_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_RESULTx_OFFSET_BASE&#160;&#160;&#160;ADC_O_RESULT0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5080ff53784043785bca57fbef96203a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5080ff53784043785bca57fbef96203a">&#9670;&nbsp;</a></span>ADC_INTSELxNy_OFFSET_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_INTSELxNy_OFFSET_BASE&#160;&#160;&#160;ADC_O_INTSEL1N2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab93b3d59039266605bee26e11b6077be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab93b3d59039266605bee26e11b6077be">&#9670;&nbsp;</a></span>ADC_PPBxRESULT_OFFSET_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxRESULT_OFFSET_BASE&#160;&#160;&#160;ADC_O_PPB1RESULT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga176a93bffba08939c5605585de69e991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga176a93bffba08939c5605585de69e991">&#9670;&nbsp;</a></span>REPCTL_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REPCTL_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                     (ADC_REP1CTL_MODE                        |\</div>
<div class="line">                                     ADC_REP1CTL_TRIGGER_M                   |\</div>
<div class="line">                                     ADC_REP1CTL_SYNCINSEL_M)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga0d1b5698287de79f5f1577fcda816386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d1b5698287de79f5f1577fcda816386">&#9670;&nbsp;</a></span>ADC_PPBxPSUM_OFFSET_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxPSUM_OFFSET_BASE&#160;&#160;&#160;ADC_O_PPB1PSUM</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga437d861f409a157db3f2d9a07344dfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga437d861f409a157db3f2d9a07344dfca">&#9670;&nbsp;</a></span>ADC_PPBxPCOUNT_OFFSET_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxPCOUNT_OFFSET_BASE&#160;&#160;&#160;ADC_O_PPBP1PCOUNT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9ef83b3a78d0983af6c5f2ab72833751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ef83b3a78d0983af6c5f2ab72833751">&#9670;&nbsp;</a></span>ADC_PPBxPMAX_OFFSET_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxPMAX_OFFSET_BASE&#160;&#160;&#160;ADC_O_PPB1PMAX</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaaab63fb1795587086e1f46416864e2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaab63fb1795587086e1f46416864e2be">&#9670;&nbsp;</a></span>ADC_PPBxPMIN_OFFSET_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxPMIN_OFFSET_BASE&#160;&#160;&#160;ADC_O_PPB1PMIN</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad02c12204c2dc93c27b2500530961b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad02c12204c2dc93c27b2500530961b15">&#9670;&nbsp;</a></span>ADC_PPBxPMAXI_OFFSET_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxPMAXI_OFFSET_BASE&#160;&#160;&#160;ADC_O_PPB1PMAXI</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gadc8d0aced8122b23437d2ad4e1e143b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc8d0aced8122b23437d2ad4e1e143b7">&#9670;&nbsp;</a></span>ADC_PPBxPMINI_OFFSET_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxPMINI_OFFSET_BASE&#160;&#160;&#160;ADC_O_PPB1PMINI</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf2af0e663819cf9b1c812f40d2c39b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2af0e663819cf9b1c812f40d2c39b9f">&#9670;&nbsp;</a></span>ADC_PPBxLIMIT_OFFSET_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxLIMIT_OFFSET_BASE&#160;&#160;&#160;ADC_O_PPB1LIMIT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9d1b25bfa0a3e3943018cfb170511a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d1b25bfa0a3e3943018cfb170511a04">&#9670;&nbsp;</a></span>ADC_PPBxSUM_OFFSET_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxSUM_OFFSET_BASE&#160;&#160;&#160;ADC_O_PPB1SUM</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5a70b72944ed25738a637efa0e0ee2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a70b72944ed25738a637efa0e0ee2e7">&#9670;&nbsp;</a></span>ADC_PPBxCOUNT_OFFSET_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxCOUNT_OFFSET_BASE&#160;&#160;&#160;ADC_O_PPB1COUNT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7ca65192da9ebeda9cfd6a649f4ebb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ca65192da9ebeda9cfd6a649f4ebb40">&#9670;&nbsp;</a></span>ADC_PPBxMAX_OFFSET_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxMAX_OFFSET_BASE&#160;&#160;&#160;ADC_O_PPB1MAX</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1228b21a75ea02767101524fbc3d41d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1228b21a75ea02767101524fbc3d41d8">&#9670;&nbsp;</a></span>ADC_PPBxMIN_OFFSET_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxMIN_OFFSET_BASE&#160;&#160;&#160;ADC_O_PPB1MIN</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5092b64861c237074c57a7218890fc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5092b64861c237074c57a7218890fc87">&#9670;&nbsp;</a></span>ADC_PPBxMAXI_OFFSET_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxMAXI_OFFSET_BASE&#160;&#160;&#160;ADC_O_PPB1MAXI</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga732d9c8c6ef51e36ad606c480c0908f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga732d9c8c6ef51e36ad606c480c0908f7">&#9670;&nbsp;</a></span>ADC_PPBxMINI_OFFSET_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxMINI_OFFSET_BASE&#160;&#160;&#160;ADC_O_PPB1MINI</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad1d4cd59c8a2a2110cccb8e467d3e960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1d4cd59c8a2a2110cccb8e467d3e960">&#9670;&nbsp;</a></span>ADC_PPBxLIMIT_STEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxLIMIT_STEP&#160;&#160;&#160;(ADC_O_PPB2LIMIT - ADC_O_PPB1LIMIT)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga80f6cf1c61ec2fd93b0144bef7f4309b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80f6cf1c61ec2fd93b0144bef7f4309b">&#9670;&nbsp;</a></span>ADC_PPBxCONFIG2_STEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxCONFIG2_STEP&#160;&#160;&#160;(ADC_O_PPB2CONFIG2 - ADC_O_PPB1CONFIG2)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga18b630821695c4f84107fefaf46029fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18b630821695c4f84107fefaf46029fd">&#9670;&nbsp;</a></span>ADC_REPxCTL_STEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_REPxCTL_STEP&#160;&#160;&#160;(ADC_O_REP2CTL - ADC_O_REP1CTL)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab0167dca0841afbbc9e025637777f823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0167dca0841afbbc9e025637777f823">&#9670;&nbsp;</a></span>ADC_REPxN_STEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_REPxN_STEP&#160;&#160;&#160;(ADC_O_REP2N - ADC_O_REP1N)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga195cf6f40375fe236fdee8ad5c518c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga195cf6f40375fe236fdee8ad5c518c05">&#9670;&nbsp;</a></span>ADC_REPxPHASE_STEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_REPxPHASE_STEP&#160;&#160;&#160;(ADC_O_REP2PHASE - ADC_O_REP1PHASE)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaee8cbd5f49478d43ffacae4dd6d7e455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee8cbd5f49478d43ffacae4dd6d7e455">&#9670;&nbsp;</a></span>ADC_REPxSPREAD_STEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_REPxSPREAD_STEP&#160;&#160;&#160;(ADC_O_REP2SPREAD - ADC_O_REP1SPREAD)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5bafdd4dbb1a1d7b88cd2894021d35b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bafdd4dbb1a1d7b88cd2894021d35b6">&#9670;&nbsp;</a></span>ADC_PPBTRIP_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBTRIP_MASK&#160;&#160;&#160;(uint32_t)ADC_PPB1TRIPHI_LIMITHI_M</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaed40a85717c6c033f8e14af8eadb00c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed40a85717c6c033f8e14af8eadb00c1">&#9670;&nbsp;</a></span>ADC_PPBxTRIPLO2_STEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxTRIPLO2_STEP&#160;&#160;&#160;(ADC_O_PPB2TRIPLO2 - ADC_O_PPB1TRIPLO2)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gabc6bdbd41b411aac98ed70aae0409333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc6bdbd41b411aac98ed70aae0409333">&#9670;&nbsp;</a></span>ADC_PPBxCONFIG_STEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxCONFIG_STEP&#160;&#160;&#160;(ADC_O_PPB2CONFIG - ADC_O_PPB1CONFIG)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa48fe3f2e0ef31a0b05a116c34893314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa48fe3f2e0ef31a0b05a116c34893314">&#9670;&nbsp;</a></span>ADC_PPBxTRIPHI_STEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxTRIPHI_STEP&#160;&#160;&#160;(ADC_O_PPB2TRIPHI - ADC_O_PPB1TRIPHI)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae674bf5583947a8c5665cc2b908b3053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae674bf5583947a8c5665cc2b908b3053">&#9670;&nbsp;</a></span>ADC_PPBxTRIPLO_STEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxTRIPLO_STEP&#160;&#160;&#160;(ADC_O_PPB2TRIPLO - ADC_O_PPB1TRIPLO)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab26a0a07d759eecd3ab68b02eac12c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab26a0a07d759eecd3ab68b02eac12c27">&#9670;&nbsp;</a></span>ADC_PPBxSTAMP_STEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxSTAMP_STEP&#160;&#160;&#160;(ADC_O_PPB2STAMP - ADC_O_PPB1STAMP)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga814daeb44e4839dce3066526745774aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga814daeb44e4839dce3066526745774aa">&#9670;&nbsp;</a></span>ADC_PPBxOFFCAL_STEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxOFFCAL_STEP&#160;&#160;&#160;(ADC_O_PPB2OFFCAL - ADC_O_PPB1OFFCAL)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga35370a5262c1ac07f4632525cfb9a22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35370a5262c1ac07f4632525cfb9a22d">&#9670;&nbsp;</a></span>ADC_PPBxOFFREF_STEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_PPBxOFFREF_STEP&#160;&#160;&#160;(ADC_O_PPB2OFFREF - ADC_O_PPB1OFFREF)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga97668ed9382ff2bb9394639953da28be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97668ed9382ff2bb9394639953da28be">&#9670;&nbsp;</a></span>ADC_INT_REF_TSSLOPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_INT_REF_TSSLOPE&#160;&#160;&#160;(*(int16_t *)((uintptr_t)0x20000FDC))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga36eb294ee1f115e334fc48af8cd63095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36eb294ee1f115e334fc48af8cd63095">&#9670;&nbsp;</a></span>ADC_INT_REF_TSOFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_INT_REF_TSOFFSET&#160;&#160;&#160;(*(int16_t *)((uintptr_t)0x20000FE0))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gacdf6f073dd1336bc9d4a386155bb53a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdf6f073dd1336bc9d4a386155bb53a3">&#9670;&nbsp;</a></span>ADC_EXT_REF_TSSLOPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_EXT_REF_TSSLOPE&#160;&#160;&#160;(*(int16_t *)((uintptr_t)0x20000FD4))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7cd21facf4d774ca7afc43a915246fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cd21facf4d774ca7afc43a915246fe7">&#9670;&nbsp;</a></span>ADC_EXT_REF_TSOFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_EXT_REF_TSOFFSET&#160;&#160;&#160;(*(int16_t *)((uintptr_t)0x20000FD8))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga55b4edea639bba1c6e05726b23aeaf3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55b4edea639bba1c6e05726b23aeaf3c">&#9670;&nbsp;</a></span>ADC_EVT_TRIPHI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_EVT_TRIPHI&#160;&#160;&#160;0x0001U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trip High Event. </p>

</div>
</div>
<a id="ga8fceea30c153bbc9d27c7097620dc958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fceea30c153bbc9d27c7097620dc958">&#9670;&nbsp;</a></span>ADC_EVT_TRIPLO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_EVT_TRIPLO&#160;&#160;&#160;0x0002U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trip Low Event. </p>

</div>
</div>
<a id="gacbe53d8a8e55fff293d0642f9bea6c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbe53d8a8e55fff293d0642f9bea6c08">&#9670;&nbsp;</a></span>ADC_EVT_ZERO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_EVT_ZERO&#160;&#160;&#160;0x0004U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zero Crossing Event. </p>

</div>
</div>
<a id="ga5546f06bbe099383e97e8b14c1d7a072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5546f06bbe099383e97e8b14c1d7a072">&#9670;&nbsp;</a></span>ADC_FORCE_SOC0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC0&#160;&#160;&#160;0x00000001U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 0. </p>

</div>
</div>
<a id="ga34a89bbd990a8266b5c104056b3a27e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34a89bbd990a8266b5c104056b3a27e7">&#9670;&nbsp;</a></span>ADC_FORCE_SOC1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC1&#160;&#160;&#160;0x00000002U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 1. </p>

</div>
</div>
<a id="ga72f6effcfb943dcdae134673dff51598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72f6effcfb943dcdae134673dff51598">&#9670;&nbsp;</a></span>ADC_FORCE_SOC2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC2&#160;&#160;&#160;0x00000004U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 2. </p>

</div>
</div>
<a id="ga9b66e439cf7b5b4d5e14ef0d7915e7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b66e439cf7b5b4d5e14ef0d7915e7ed">&#9670;&nbsp;</a></span>ADC_FORCE_SOC3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC3&#160;&#160;&#160;0x00000008U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 3. </p>

</div>
</div>
<a id="ga3486abfa85d7db062e93c79fd98108c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3486abfa85d7db062e93c79fd98108c2">&#9670;&nbsp;</a></span>ADC_FORCE_SOC4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC4&#160;&#160;&#160;0x00000010U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 4. </p>

</div>
</div>
<a id="ga706eb5885d18f368a605395fef52f10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga706eb5885d18f368a605395fef52f10e">&#9670;&nbsp;</a></span>ADC_FORCE_SOC5</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC5&#160;&#160;&#160;0x00000020U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 5. </p>

</div>
</div>
<a id="ga45d517b84b7a0c2d9c86fe3cfaa4d58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45d517b84b7a0c2d9c86fe3cfaa4d58c">&#9670;&nbsp;</a></span>ADC_FORCE_SOC6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC6&#160;&#160;&#160;0x00000040U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 6. </p>

</div>
</div>
<a id="ga03a41bc17f74223f884ab1d2b95fe202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03a41bc17f74223f884ab1d2b95fe202">&#9670;&nbsp;</a></span>ADC_FORCE_SOC7</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC7&#160;&#160;&#160;0x00000080U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 7. </p>

</div>
</div>
<a id="gae0374de833882347f3e55911739cf1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0374de833882347f3e55911739cf1af">&#9670;&nbsp;</a></span>ADC_FORCE_SOC8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC8&#160;&#160;&#160;0x00000100U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 8. </p>

</div>
</div>
<a id="ga6d6649d983e8e3b4104e7e348d216512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d6649d983e8e3b4104e7e348d216512">&#9670;&nbsp;</a></span>ADC_FORCE_SOC9</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC9&#160;&#160;&#160;0x00000200U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 9. </p>

</div>
</div>
<a id="gae035db14e59bc94f8a2cbe090310e789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae035db14e59bc94f8a2cbe090310e789">&#9670;&nbsp;</a></span>ADC_FORCE_SOC10</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC10&#160;&#160;&#160;0x00000400U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 10. </p>

</div>
</div>
<a id="gaccfc3b01bc20ec72c7c2f942e3ffd126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccfc3b01bc20ec72c7c2f942e3ffd126">&#9670;&nbsp;</a></span>ADC_FORCE_SOC11</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC11&#160;&#160;&#160;0x00000800U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 11. </p>

</div>
</div>
<a id="ga5406d791b02b1a03113ad092df1c1d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5406d791b02b1a03113ad092df1c1d6b">&#9670;&nbsp;</a></span>ADC_FORCE_SOC12</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC12&#160;&#160;&#160;0x00001000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 12. </p>

</div>
</div>
<a id="ga508d12a6dce4ff635b1f4985a4c73586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga508d12a6dce4ff635b1f4985a4c73586">&#9670;&nbsp;</a></span>ADC_FORCE_SOC13</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC13&#160;&#160;&#160;0x00002000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 13. </p>

</div>
</div>
<a id="ga879cfb1b496ef7148754cc51c623a2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga879cfb1b496ef7148754cc51c623a2b2">&#9670;&nbsp;</a></span>ADC_FORCE_SOC14</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC14&#160;&#160;&#160;0x00004000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 14. </p>

</div>
</div>
<a id="ga1ac4cb4163b351c54459f8fa4f6cb125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ac4cb4163b351c54459f8fa4f6cb125">&#9670;&nbsp;</a></span>ADC_FORCE_SOC15</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC15&#160;&#160;&#160;0x00008000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 15. </p>

</div>
</div>
<a id="ga5ae8212cd502d31246bb2fb9f3d26881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ae8212cd502d31246bb2fb9f3d26881">&#9670;&nbsp;</a></span>ADC_FORCE_SOC16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC16&#160;&#160;&#160;0x00010000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 16. </p>

</div>
</div>
<a id="ga88f780dd8fe40de9e50c060c799caff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88f780dd8fe40de9e50c060c799caff8">&#9670;&nbsp;</a></span>ADC_FORCE_SOC17</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC17&#160;&#160;&#160;0x00020000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 17. </p>

</div>
</div>
<a id="ga8c88ca9a825758b806e57397e0ef0db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c88ca9a825758b806e57397e0ef0db0">&#9670;&nbsp;</a></span>ADC_FORCE_SOC18</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC18&#160;&#160;&#160;0x00040000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 18. </p>

</div>
</div>
<a id="gaa896c2174ff99227cb850e118d636f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa896c2174ff99227cb850e118d636f75">&#9670;&nbsp;</a></span>ADC_FORCE_SOC19</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC19&#160;&#160;&#160;0x00080000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 19. </p>

</div>
</div>
<a id="ga9f9de3d8216ea0028eaa617184f61335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f9de3d8216ea0028eaa617184f61335">&#9670;&nbsp;</a></span>ADC_FORCE_SOC20</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC20&#160;&#160;&#160;0x00100000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 20. </p>

</div>
</div>
<a id="gacc49093cf9409c7e8827e6d9e68005b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc49093cf9409c7e8827e6d9e68005b9">&#9670;&nbsp;</a></span>ADC_FORCE_SOC21</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC21&#160;&#160;&#160;0x00200000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 21. </p>

</div>
</div>
<a id="gafc914ca4900539cf2fe5125f8e6ab50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc914ca4900539cf2fe5125f8e6ab50d">&#9670;&nbsp;</a></span>ADC_FORCE_SOC22</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC22&#160;&#160;&#160;0x00400000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 22. </p>

</div>
</div>
<a id="ga714080d7f318bad211c7551292e998c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga714080d7f318bad211c7551292e998c7">&#9670;&nbsp;</a></span>ADC_FORCE_SOC23</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC23&#160;&#160;&#160;0x00800000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 23. </p>

</div>
</div>
<a id="gacfb2ad31f9936deb1131dc2dcba7f35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfb2ad31f9936deb1131dc2dcba7f35c">&#9670;&nbsp;</a></span>ADC_FORCE_SOC24</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC24&#160;&#160;&#160;0x01000000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 24. </p>

</div>
</div>
<a id="gaace300ee445c0691e92b50e8a0ffc37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaace300ee445c0691e92b50e8a0ffc37f">&#9670;&nbsp;</a></span>ADC_FORCE_SOC25</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC25&#160;&#160;&#160;0x02000000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 25. </p>

</div>
</div>
<a id="gac32359c82fca03a4ba8ea219afa4ac55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac32359c82fca03a4ba8ea219afa4ac55">&#9670;&nbsp;</a></span>ADC_FORCE_SOC26</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC26&#160;&#160;&#160;0x04000000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 26. </p>

</div>
</div>
<a id="gad08030c86ba83810af4b4725b1a0d3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad08030c86ba83810af4b4725b1a0d3c1">&#9670;&nbsp;</a></span>ADC_FORCE_SOC27</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC27&#160;&#160;&#160;0x08000000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 27. </p>

</div>
</div>
<a id="gafed6f010b9f5df13b2935f440f6f4898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafed6f010b9f5df13b2935f440f6f4898">&#9670;&nbsp;</a></span>ADC_FORCE_SOC28</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC28&#160;&#160;&#160;0x10000000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 28. </p>

</div>
</div>
<a id="ga66d27d72a84d22a7adaa5d0f765ad9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66d27d72a84d22a7adaa5d0f765ad9a4">&#9670;&nbsp;</a></span>ADC_FORCE_SOC29</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC29&#160;&#160;&#160;0x20000000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 29. </p>

</div>
</div>
<a id="ga264974c0a10a96099b1553c3eec8d83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga264974c0a10a96099b1553c3eec8d83a">&#9670;&nbsp;</a></span>ADC_FORCE_SOC30</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC30&#160;&#160;&#160;0x40000000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 30. </p>

</div>
</div>
<a id="ga15c190f48b52b4d7017f09b75549d65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15c190f48b52b4d7017f09b75549d65d">&#9670;&nbsp;</a></span>ADC_FORCE_SOC31</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_FORCE_SOC31&#160;&#160;&#160;0x80000000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SW trigger ADC SOC 31. </p>

</div>
</div>
<a id="ga0c29fcb97890c54886e8148fcae13b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c29fcb97890c54886e8148fcae13b0e">&#9670;&nbsp;</a></span>ADC_REPEATER_MODULE_BUSY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_REPEATER_MODULE_BUSY&#160;&#160;&#160;ADC_REP1CTL_MODULEBUSY</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaeb5b3d7ea7ba3956eb6d356713d97fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb5b3d7ea7ba3956eb6d356713d97fb4">&#9670;&nbsp;</a></span>ADC_REPEATER_PHASE_OVERFLOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_REPEATER_PHASE_OVERFLOW&#160;&#160;&#160;ADC_REP1CTL_PHASEOVF</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga67e90dbc3264701cb8fef3cd7e64ad5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67e90dbc3264701cb8fef3cd7e64ad5b">&#9670;&nbsp;</a></span>ADC_REPEATER_TRIGGER_OVERFLOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_REPEATER_TRIGGER_OVERFLOW&#160;&#160;&#160;ADC_REP1CTL_TRIGGEROVF</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga869b25bb4e431bfcd0eb9e1665e89284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga869b25bb4e431bfcd0eb9e1665e89284">&#9670;&nbsp;</a></span>ADC_REP1CTL_ACTIVEMODE_S</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_REP1CTL_ACTIVEMODE_S&#160;&#160;&#160;1U</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab842e8dcd72fbf8a8b0d2278ed737701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab842e8dcd72fbf8a8b0d2278ed737701">&#9670;&nbsp;</a></span>ADC_REP1CTL_MODULEBUSY_S</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_REP1CTL_MODULEBUSY_S&#160;&#160;&#160;3U</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga24bde289150fdfe7017a65d553223e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24bde289150fdfe7017a65d553223e99">&#9670;&nbsp;</a></span>ADC_REPSTATUS_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_REPSTATUS_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                     (ADC_REP1CTL_MODULEBUSY                  |\</div>
<div class="line">                                     ADC_REP1CTL_PHASEOVF                    |\</div>
<div class="line">                                     ADC_REP1CTL_TRIGGEROVF)</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf4b4c23352d2de6c4bc59e178bfade2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4b4c23352d2de6c4bc59e178bfade2d">&#9670;&nbsp;</a></span>ADC_SAFECHECK_RESULT1_READY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_SAFECHECK_RESULT1_READY&#160;&#160;&#160;ADC_CHECKSTATUS_RES1READY</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga666c9dd2e3e90aed82d5fb4bdda7d375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga666c9dd2e3e90aed82d5fb4bdda7d375">&#9670;&nbsp;</a></span>ADC_SAFECHECK_RESULT2_READY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_SAFECHECK_RESULT2_READY&#160;&#160;&#160;ADC_CHECKSTATUS_RES2READY</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gacd5c9b85d06443346e86a2774a99f146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd5c9b85d06443346e86a2774a99f146">&#9670;&nbsp;</a></span>ADC_SAFECHECK_RESULT_OOT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_SAFECHECK_RESULT_OOT&#160;&#160;&#160;ADC_CHECKSTATUS_OOT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4c7b38627e6d64398b4c067c1eba335e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c7b38627e6d64398b4c067c1eba335e">&#9670;&nbsp;</a></span>ADC_SAFECHECK_STATUS_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_SAFECHECK_STATUS_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                     (<a class="code" href="group__adc__api.html#gaf4b4c23352d2de6c4bc59e178bfade2d">ADC_SAFECHECK_RESULT1_READY</a>             |\</div>
<div class="line">                                     ADC_SAFECHECK_RESULT2_READY             |\</div>
<div class="line">                                     ADC_SAFECHECK_RESULT_OOT)</div>
<div class="ttc" id="agroup__adc__api_html_gaf4b4c23352d2de6c4bc59e178bfade2d"><div class="ttname"><a href="group__adc__api.html#gaf4b4c23352d2de6c4bc59e178bfade2d">ADC_SAFECHECK_RESULT1_READY</a></div><div class="ttdeci">#define ADC_SAFECHECK_RESULT1_READY</div><div class="ttdef"><b>Definition:</b> adc.h:187</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga8d6ae5ac93027785bc422c07d87f4a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d6ae5ac93027785bc422c07d87f4a5a">&#9670;&nbsp;</a></span>ADC_ClkPrescale</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga8d6ae5ac93027785bc422c07d87f4a5a">ADC_ClkPrescale</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_setPrescaler() as the <em>clkPrescale</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8d6ae5ac93027785bc422c07d87f4a5aa3e33987cc2dd1ef61167608c18b28c21"></a>ADC_CLK_DIV_1_0&#160;</td><td class="fielddoc"><p>ADCCLK = (input clock) / 1.0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d6ae5ac93027785bc422c07d87f4a5aa6c3a25aced6f3c35d1be5e21b1a6e8b1"></a>ADC_CLK_DIV_2_0&#160;</td><td class="fielddoc"><p>ADCCLK = (input clock) / 2.0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d6ae5ac93027785bc422c07d87f4a5aa61dc1a46ec5ac11678b089db8cd709d1"></a>ADC_CLK_DIV_2_5&#160;</td><td class="fielddoc"><p>ADCCLK = (input clock) / 2.5. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d6ae5ac93027785bc422c07d87f4a5aaabdbcd923c3a6134c444faba022536aa"></a>ADC_CLK_DIV_3_0&#160;</td><td class="fielddoc"><p>ADCCLK = (input clock) / 3.0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d6ae5ac93027785bc422c07d87f4a5aa0e5d67b46514a35868245754a3d72ec3"></a>ADC_CLK_DIV_3_5&#160;</td><td class="fielddoc"><p>ADCCLK = (input clock) / 3.5. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d6ae5ac93027785bc422c07d87f4a5aafaeb50b93500d9e1b5f49a5ea23465d9"></a>ADC_CLK_DIV_4_0&#160;</td><td class="fielddoc"><p>ADCCLK = (input clock) / 4.0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d6ae5ac93027785bc422c07d87f4a5aaddaf5682b390f7fcf31adc3abb6a2ca3"></a>ADC_CLK_DIV_4_5&#160;</td><td class="fielddoc"><p>ADCCLK = (input clock) / 4.5. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d6ae5ac93027785bc422c07d87f4a5aa99ab26b48430e29121d48445b17f922f"></a>ADC_CLK_DIV_5_0&#160;</td><td class="fielddoc"><p>ADCCLK = (input clock) / 5.0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d6ae5ac93027785bc422c07d87f4a5aa87a63f5b0d306bda18b5dd6aa76087e4"></a>ADC_CLK_DIV_5_5&#160;</td><td class="fielddoc"><p>ADCCLK = (input clock) / 5.5. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d6ae5ac93027785bc422c07d87f4a5aa5d738f4dbf1b69bcaf3820a96a7ab375"></a>ADC_CLK_DIV_6_0&#160;</td><td class="fielddoc"><p>ADCCLK = (input clock) / 6.0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d6ae5ac93027785bc422c07d87f4a5aa69b20ca30cee7c2f341af1ff00ffd82f"></a>ADC_CLK_DIV_6_5&#160;</td><td class="fielddoc"><p>ADCCLK = (input clock) / 6.5. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d6ae5ac93027785bc422c07d87f4a5aa233be0327034ddd52c0bc1005173e819"></a>ADC_CLK_DIV_7_0&#160;</td><td class="fielddoc"><p>ADCCLK = (input clock) / 7.0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d6ae5ac93027785bc422c07d87f4a5aab9ca56b534ab8d4e7cc3d0ea775f6540"></a>ADC_CLK_DIV_7_5&#160;</td><td class="fielddoc"><p>ADCCLK = (input clock) / 7.5. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d6ae5ac93027785bc422c07d87f4a5aaa5e3810a6b7ac706ff7bec299842c211"></a>ADC_CLK_DIV_8_0&#160;</td><td class="fielddoc"><p>ADCCLK = (input clock) / 8.0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d6ae5ac93027785bc422c07d87f4a5aad4c5ac99de171a9d1cda6572bea6e9f8"></a>ADC_CLK_DIV_8_5&#160;</td><td class="fielddoc"><p>ADCCLK = (input clock) / 8.5. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga61bdbeb0bb5a4b445ba88d05a51c701b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61bdbeb0bb5a4b445ba88d05a51c701b">&#9670;&nbsp;</a></span>ADC_Resolution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga61bdbeb0bb5a4b445ba88d05a51c701b">ADC_Resolution</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to <a class="el" href="group__adc__api.html#gac6b5f4a6e28b845462cb44d00889a6f9">ADC_setMode()</a> as the <em>resolution</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga61bdbeb0bb5a4b445ba88d05a51c701bac002266035b9c3a14762154237da8e87"></a>ADC_RESOLUTION_12BIT&#160;</td><td class="fielddoc"><p>12-bit conversion resolution </p>
</td></tr>
<tr><td class="fieldname"><a id="gga61bdbeb0bb5a4b445ba88d05a51c701ba5c3c11dff8c5b740d209faac34047aeb"></a>ADC_RESOLUTION_16BIT&#160;</td><td class="fielddoc"><p>16-bit conversion resolution </p>
</td></tr>
</table>

</div>
</div>
<a id="gabb3445edb2b4d559233957cd6311d909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb3445edb2b4d559233957cd6311d909">&#9670;&nbsp;</a></span>ADC_SignalMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#gabb3445edb2b4d559233957cd6311d909">ADC_SignalMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to <a class="el" href="group__adc__api.html#gac6b5f4a6e28b845462cb44d00889a6f9">ADC_setMode()</a> as the <em>signalMode</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabb3445edb2b4d559233957cd6311d909a638bddbd35effd8c1545ed033883cc3b"></a>ADC_MODE_SINGLE_ENDED&#160;</td><td class="fielddoc"><p>Sample on single pin with VREFLO. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabb3445edb2b4d559233957cd6311d909af44167a7d746d7ba0b56345deb686efd"></a>ADC_MODE_DIFFERENTIAL&#160;</td><td class="fielddoc"><p>Sample on pair of pins. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga7973b7d12fc7bfb96bd276b0a5926834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7973b7d12fc7bfb96bd276b0a5926834">&#9670;&nbsp;</a></span>ADC_Trigger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga7973b7d12fc7bfb96bd276b0a5926834">ADC_Trigger</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_setupSOC() as the <em>trigger</em> parameter to specify the event that will trigger a conversion to start. It is also used with ADC_setBurstModeConfig() and ADC_triggerRepeaterSelect(). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a9b08ad6080adb6fb14f27aa9b983fb51"></a>ADC_TRIGGER_SW_ONLY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834ab0c33f3e6509025d9792afdce374a9fa"></a>ADC_TRIGGER_CPU1_TINT0&#160;</td><td class="fielddoc"><p>Software only. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a4f6bcc25d7f13d1a9a10776faad46008"></a>ADC_TRIGGER_CPU1_TINT1&#160;</td><td class="fielddoc"><p>CPU1 Timer 0, TINT0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834ac891128b2fb71b4fa8b63ebf51f3790c"></a>ADC_TRIGGER_CPU1_TINT2&#160;</td><td class="fielddoc"><p>CPU1 Timer 1, TINT1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834aa38d4a5ab3ee5946465236aac1f26c76"></a>ADC_TRIGGER_GPIO&#160;</td><td class="fielddoc"><p>CPU1 Timer 2, TINT2. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a98f0d3ecdf23823727fc64e3c0fbc240"></a>ADC_TRIGGER_EPWM1_SOCA&#160;</td><td class="fielddoc"><p>GPIO, ADCEXTSOC. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a88e3e1c6ffdb247df64badcf6ddccf86"></a>ADC_TRIGGER_EPWM1_SOCB&#160;</td><td class="fielddoc"><p>ePWM1, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834aa927aace29b8499bb9414bf25aba6ccd"></a>ADC_TRIGGER_EPWM2_SOCA&#160;</td><td class="fielddoc"><p>ePWM1, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834aa44a2d836c2201d011c01d51e137b7c8"></a>ADC_TRIGGER_EPWM2_SOCB&#160;</td><td class="fielddoc"><p>ePWM2, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a07addb1ab145d808b7e8581e95f1f999"></a>ADC_TRIGGER_EPWM3_SOCA&#160;</td><td class="fielddoc"><p>ePWM2, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a2c760a67cd78c33598afd9a0ba8d2200"></a>ADC_TRIGGER_EPWM3_SOCB&#160;</td><td class="fielddoc"><p>ePWM3, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a45948585a29a620be07f4bdf1cf5a3f9"></a>ADC_TRIGGER_EPWM4_SOCA&#160;</td><td class="fielddoc"><p>ePWM3, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a24733858882229d52bf4afdd8c853b1a"></a>ADC_TRIGGER_EPWM4_SOCB&#160;</td><td class="fielddoc"><p>ePWM4, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a3b03ad1a0dd178e29a3a7fff0f24db4d"></a>ADC_TRIGGER_EPWM5_SOCA&#160;</td><td class="fielddoc"><p>ePWM4, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a4f73a4cfeba5543682a1b2737ada1418"></a>ADC_TRIGGER_EPWM5_SOCB&#160;</td><td class="fielddoc"><p>ePWM5, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a270cf6e4f0d41b89ad83b996fd3dec64"></a>ADC_TRIGGER_EPWM6_SOCA&#160;</td><td class="fielddoc"><p>ePWM5, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a071f713674170e85db780f44999cab95"></a>ADC_TRIGGER_EPWM6_SOCB&#160;</td><td class="fielddoc"><p>ePWM6, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a0a1c6af7b9fa97239ee71e499dfb8bb5"></a>ADC_TRIGGER_EPWM7_SOCA&#160;</td><td class="fielddoc"><p>ePWM6, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834ab7756d56b7ef82b3596f6f5afda1a145"></a>ADC_TRIGGER_EPWM7_SOCB&#160;</td><td class="fielddoc"><p>ePWM7, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a4fa0444f5c852d4f98e6592b8f6348b6"></a>ADC_TRIGGER_EPWM8_SOCA&#160;</td><td class="fielddoc"><p>ePWM7, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834af129b09e91c4a845b538e1072d4e95f2"></a>ADC_TRIGGER_EPWM8_SOCB&#160;</td><td class="fielddoc"><p>ePWM8, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834aff9f8fd1920ec9231734bb4612725af1"></a>ADC_TRIGGER_EPWM9_SOCA&#160;</td><td class="fielddoc"><p>ePWM8, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a6cb5d624a0db72cde5f2ee5aa9150563"></a>ADC_TRIGGER_EPWM9_SOCB&#160;</td><td class="fielddoc"><p>ePWM9, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a774c492308b970ee9de11974cdaad97a"></a>ADC_TRIGGER_EPWM10_SOCA&#160;</td><td class="fielddoc"><p>ePWM9, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a3f26581b004d9d89a5523734df0c6395"></a>ADC_TRIGGER_EPWM10_SOCB&#160;</td><td class="fielddoc"><p>ePWM10, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a81e561c6066b429bb273271e2d2151a3"></a>ADC_TRIGGER_EPWM11_SOCA&#160;</td><td class="fielddoc"><p>ePWM10, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834aafc2be8e3549a2a223486ce722b386e0"></a>ADC_TRIGGER_EPWM11_SOCB&#160;</td><td class="fielddoc"><p>ePWM11, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a0255c5db10382c3b21d4f9cea9704c1f"></a>ADC_TRIGGER_EPWM12_SOCA&#160;</td><td class="fielddoc"><p>ePWM11, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a830f853186dd717d012dd20bbba33a47"></a>ADC_TRIGGER_EPWM12_SOCB&#160;</td><td class="fielddoc"><p>ePWM12, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834aef5f39e65ea6b98b02ce86d74a36472f"></a>ADC_TRIGGER_REPEATER1&#160;</td><td class="fielddoc"><p>ePWM12, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a4dcf733cfbe14011815e35ddf31c4ab9"></a>ADC_TRIGGER_REPEATER2&#160;</td><td class="fielddoc"><p>Repeater 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834aa870e9d8a6cacdddbed63e6351097e22"></a>ADC_TRIGGER_CLB1_OUT27&#160;</td><td class="fielddoc"><p>Repeater 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a75891e18664928b73e3c281211d09e59"></a>ADC_TRIGGER_CLB2_OUT27&#160;</td><td class="fielddoc"><p>CLB1 OUT27. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834af50ba6d0a9cc137395df546143f19931"></a>ADC_TRIGGER_CLB3_OUT27&#160;</td><td class="fielddoc"><p>CLB2 OUT27. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a36f7de570043490ff2824bd5c0a0787f"></a>ADC_TRIGGER_CLB4_OUT27&#160;</td><td class="fielddoc"><p>CLB3 OUT27. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834ab83f3d16da43805f4a1a860cba3332e2"></a>ADC_TRIGGER_CLB5_OUT27&#160;</td><td class="fielddoc"><p>CLB4 OUT27. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a9660d12e8ceb7af100005d17089a2c21"></a>ADC_TRIGGER_CLB6_OUT27&#160;</td><td class="fielddoc"><p>CLB5 OUT27. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834ab0384657b4d68416c26981109d962710"></a>ADC_TRIGGER_ECAP1&#160;</td><td class="fielddoc"><p>CLB6 OUT27. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834aaa57c39738f6e23f919eabadba8f6d2b"></a>ADC_TRIGGER_ECAP2&#160;</td><td class="fielddoc"><p>eCAP1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a549baabece9dc3ec051eb0435573678e"></a>ADC_TRIGGER_ECAP3&#160;</td><td class="fielddoc"><p>eCAP2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834adc005df5195fe80241d7abc07bd97c31"></a>ADC_TRIGGER_ECAP4&#160;</td><td class="fielddoc"><p>eCAP3 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834aa9dbc1cdb91a69183a015237475c52ee"></a>ADC_TRIGGER_ECAP5&#160;</td><td class="fielddoc"><p>eCAP4 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834ac2215d5a10fcc8741c1d769825e9dc61"></a>ADC_TRIGGER_ECAP6&#160;</td><td class="fielddoc"><p>eCAP5 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834ae84037ce312680802ae23323c60aaa71"></a>ADC_TRIGGER_EPWM13_SOCA&#160;</td><td class="fielddoc"><p>eCAP6 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834adacba370bd9c031054c8ad0ee52d4c2a"></a>ADC_TRIGGER_EPWM13_SOCB&#160;</td><td class="fielddoc"><p>ePWM13, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a46888c7fb4c852cce01fb25d7ba2e4df"></a>ADC_TRIGGER_EPWM14_SOCA&#160;</td><td class="fielddoc"><p>ePWM13, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a7f3e209ac9aad7a2b2b13693399fc9b2"></a>ADC_TRIGGER_EPWM14_SOCB&#160;</td><td class="fielddoc"><p>ePWM14, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a75d760a92e81e491a670212a44c82ef3"></a>ADC_TRIGGER_EPWM15_SOCA&#160;</td><td class="fielddoc"><p>ePWM14, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a5d6c786e521f688394f708f2e89c90a2"></a>ADC_TRIGGER_EPWM15_SOCB&#160;</td><td class="fielddoc"><p>ePWM15, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a41c98135807712690ea04306c7752285"></a>ADC_TRIGGER_EPWM16_SOCA&#160;</td><td class="fielddoc"><p>ePWM15, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a10937a9f51744920b42bcc4a67f82ea0"></a>ADC_TRIGGER_EPWM16_SOCB&#160;</td><td class="fielddoc"><p>ePWM16, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a7be9fbf3b1e1810e122bcbccb13e0561"></a>ADC_TRIGGER_EPWM17_SOCA&#160;</td><td class="fielddoc"><p>ePWM16, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a73d48bf55b4d309186ebd5a00d773526"></a>ADC_TRIGGER_EPWM17_SOCB&#160;</td><td class="fielddoc"><p>ePWM17, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834addf4ddcc255dcb717be9b6eb5fda70e6"></a>ADC_TRIGGER_EPWM18_SOCA&#160;</td><td class="fielddoc"><p>ePWM17, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834ac5b3d4ba84a039fa6dbe7a64aabd252f"></a>ADC_TRIGGER_EPWM18_SOCB&#160;</td><td class="fielddoc"><p>ePWM18, ADCSOCA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a59e82c524ee596ea784ce14970805528"></a>ADC_TRIGGER_CPU2_TINT0&#160;</td><td class="fielddoc"><p>ePWM18, ADCSOCB </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a42499d98cf412b3c60b1cd81b66de17d"></a>ADC_TRIGGER_CPU2_TINT1&#160;</td><td class="fielddoc"><p>CPU2 Timer 0, TINT0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834ad08bb09fa74c1f24942cc8e431e34961"></a>ADC_TRIGGER_CPU2_TINT2&#160;</td><td class="fielddoc"><p>CPU2 Timer 1, TINT1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a437092f2e0aa50471d7ecc57057b75ed"></a>ADC_TRIGGER_CPU3_TINT0&#160;</td><td class="fielddoc"><p>CPU2 Timer 2, TINT2. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a70e88e48f11a7e708b6dc3b6688bb304"></a>ADC_TRIGGER_CPU3_TINT1&#160;</td><td class="fielddoc"><p>CPU3 Timer 0, TINT0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7973b7d12fc7bfb96bd276b0a5926834a5ccefdaaccbf0c3726fae20d2a7efa0d"></a>ADC_TRIGGER_CPU3_TINT2&#160;</td><td class="fielddoc"><p>CPU3 Timer 1, TINT1. </p>
</td></tr>
</table>

</div>
</div>
<a id="gad7b9fa1ae8a65e534cce7d26fa0984f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7b9fa1ae8a65e534cce7d26fa0984f6">&#9670;&nbsp;</a></span>ADC_Channel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#gad7b9fa1ae8a65e534cce7d26fa0984f6">ADC_Channel</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_setupSOC() as the <em>channel</em> parameter. This is the input pin on which the signal to be converted is located. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6adf3fcf575362183753c35541c57214ec"></a>ADC_CH_ADCIN0&#160;</td><td class="fielddoc"><p>single-ended, ADCIN0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a1eb94448700a96e3d736df1c22a9024a"></a>ADC_CH_ADCIN1&#160;</td><td class="fielddoc"><p>single-ended, ADCIN1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6ab8c49d498941741257b1da57aec5e3ab"></a>ADC_CH_ADCIN2&#160;</td><td class="fielddoc"><p>single-ended, ADCIN2 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a9faf1b6f5731d3d254aef3c61f3c5c63"></a>ADC_CH_ADCIN3&#160;</td><td class="fielddoc"><p>single-ended, ADCIN3 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6ac8c4e9648bae64323935a75cbbb34556"></a>ADC_CH_ADCIN4&#160;</td><td class="fielddoc"><p>single-ended, ADCIN4 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6adca7353a2c8bb18c5e0e54fb91863b3c"></a>ADC_CH_ADCIN5&#160;</td><td class="fielddoc"><p>single-ended, ADCIN5 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6aebb29c83c442e7472261e1a3c652d64f"></a>ADC_CH_ADCIN6&#160;</td><td class="fielddoc"><p>single-ended, ADCIN6 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a4389106875b6aab9b6fe8940bfe2d922"></a>ADC_CH_ADCIN7&#160;</td><td class="fielddoc"><p>single-ended, ADCIN7 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a0cdf45e738b440e491d63c3e18987671"></a>ADC_CH_ADCIN8&#160;</td><td class="fielddoc"><p>single-ended, ADCIN8 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6aef4dd01a0b2f4b0bf6a1ec9ce60cb88e"></a>ADC_CH_ADCIN9&#160;</td><td class="fielddoc"><p>single-ended, ADCIN9 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a213b49d5ae49aca4068020771fecff4b"></a>ADC_CH_ADCIN10&#160;</td><td class="fielddoc"><p>single-ended, ADCIN10 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a5a2482d45fdda131ce65d30fdee49d9e"></a>ADC_CH_ADCIN11&#160;</td><td class="fielddoc"><p>single-ended, ADCIN11 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a695f52a73207a15b4e7c66184d955566"></a>ADC_CH_ADCIN12&#160;</td><td class="fielddoc"><p>single-ended, ADCIN12 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6aea3d0820ce79591573ac87abb6834b9c"></a>ADC_CH_ADCIN13&#160;</td><td class="fielddoc"><p>single-ended, ADCIN13 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6ad57e92e33ff745530fdab094baeedded"></a>ADC_CH_ADCIN14&#160;</td><td class="fielddoc"><p>single-ended, ADCIN14 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a2d377b4128a4dd24e56a867f395110fc"></a>ADC_CH_ADCIN15&#160;</td><td class="fielddoc"><p>single-ended, ADCIN15 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a0bf3f6d7920c89513793694d67870444"></a>ADC_CH_ADCIN16&#160;</td><td class="fielddoc"><p>single-ended, ADCIN16 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a51b1dbf71808d2cf808b1e4feeb3684b"></a>ADC_CH_ADCIN17&#160;</td><td class="fielddoc"><p>single-ended, ADCIN17 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a39af6e7b573f7ed2985726a914530a89"></a>ADC_CH_ADCIN18&#160;</td><td class="fielddoc"><p>single-ended, ADCIN18 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a0c547d7955c51fc84bfeb8fd4e23ddc6"></a>ADC_CH_ADCIN19&#160;</td><td class="fielddoc"><p>single-ended, ADCIN19 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a1f5be514575cda01b0f0ac2f5823ce0c"></a>ADC_CH_ADCIN20&#160;</td><td class="fielddoc"><p>single-ended, ADCIN20 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a88273e5111fd705ca5cd1a10442e2d81"></a>ADC_CH_ADCIN21&#160;</td><td class="fielddoc"><p>single-ended, ADCIN21 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a9276f8be27422aad47a184bb1f63d80a"></a>ADC_CH_ADCIN22&#160;</td><td class="fielddoc"><p>single-ended, ADCIN22 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6acda3a3f6322dc89b62a45105a720ba8e"></a>ADC_CH_ADCIN23&#160;</td><td class="fielddoc"><p>single-ended, ADCIN23 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a998b57980e387abf1e73fc4893d65b6a"></a>ADC_CH_ADCIN24&#160;</td><td class="fielddoc"><p>single-ended, ADCIN24 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6aa50df941f03d8648f4a1a7f2f6652eb5"></a>ADC_CH_ADCIN25&#160;</td><td class="fielddoc"><p>single-ended, ADCIN25 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6ac7117395296b76abd200bd59c509c24e"></a>ADC_CH_ADCIN26&#160;</td><td class="fielddoc"><p>single-ended, ADCIN26 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a684cc9b9e08178303a9025ad908945dc"></a>ADC_CH_ADCIN27&#160;</td><td class="fielddoc"><p>single-ended, ADCIN27 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6ab04847a0955f666f47c4e39a5d8fb161"></a>ADC_CH_ADCIN28&#160;</td><td class="fielddoc"><p>single-ended, ADCIN28 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a6908d3cb5baa5450cd8b63653ab5576c"></a>ADC_CH_ADCIN29&#160;</td><td class="fielddoc"><p>single-ended, ADCIN29 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6aa5b3e92d5058f1250dae7bf547779743"></a>ADC_CH_ADCIN30&#160;</td><td class="fielddoc"><p>single-ended, ADCIN30 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a00f88fcf717e36448583392155cfe919"></a>ADC_CH_ADCIN31&#160;</td><td class="fielddoc"><p>single-ended, ADCIN31 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a59f5571cd0c0df13e06cc92f34c559cc"></a>ADC_CH_ADCIN0_ADCIN1&#160;</td><td class="fielddoc"><p>differential, ADCIN0 and ADCIN1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6aa9df414fa035e94f2fe311d42a9a5fad"></a>ADC_CH_ADCIN2_ADCIN3&#160;</td><td class="fielddoc"><p>differential, ADCIN2 and ADCIN3 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a594d49deb14638733b0e029948337393"></a>ADC_CH_ADCIN4_ADCIN5&#160;</td><td class="fielddoc"><p>differential, ADCIN4 and ADCIN5 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a2fb2043cb6794eab3a38ee6e8964c8ff"></a>ADC_CH_ADCIN6_ADCIN7&#160;</td><td class="fielddoc"><p>differential, ADCIN6 and ADCIN7 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6abfb5fe1d195ee900820fb233ee206483"></a>ADC_CH_ADCIN8_ADCIN9&#160;</td><td class="fielddoc"><p>differential, ADCIN8 and ADCIN9 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6afb28842e60ffa58a521cf4a1ad5adc95"></a>ADC_CH_ADCIN10_ADCIN11&#160;</td><td class="fielddoc"><p>differential, ADCIN10 and ADCIN11 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a19f426a6746efe0dc954a393b3fd5c67"></a>ADC_CH_ADCIN12_ADCIN13&#160;</td><td class="fielddoc"><p>differential, ADCIN12 and ADCIN13 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6ab92df55c26e52d2fb81eba793ced73f3"></a>ADC_CH_ADCIN14_ADCIN15&#160;</td><td class="fielddoc"><p>differential, ADCIN14 and ADCIN15 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a3da1106f4b92af5497b5c9ceb33fd34d"></a>ADC_CH_ADCIN16_ADCIN17&#160;</td><td class="fielddoc"><p>differential, ADCIN16 and ADCIN17 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a554b4c50cf7bc3208dcc581db6bb5b87"></a>ADC_CH_ADCIN18_ADCIN19&#160;</td><td class="fielddoc"><p>differential, ADCIN18 and ADCIN19 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a35989a30eda800eadb980ec9a2ffc48b"></a>ADC_CH_ADCIN20_ADCIN21&#160;</td><td class="fielddoc"><p>differential, ADCIN20 and ADCIN21 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a24456fa4abce3d6b8bd6006abb8064f6"></a>ADC_CH_ADCIN22_ADCIN23&#160;</td><td class="fielddoc"><p>differential, ADCIN22 and ADCIN23 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a96473a86b20b12de216191ac160050f4"></a>ADC_CH_ADCIN24_ADCIN25&#160;</td><td class="fielddoc"><p>differential, ADCIN24 and ADCIN25 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a51e6293dea31490bcbfde77f219294bd"></a>ADC_CH_ADCIN26_ADCIN27&#160;</td><td class="fielddoc"><p>differential, ADCIN26 and ADCIN27 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a1bab28c88c296421651e35cef46fb4dc"></a>ADC_CH_ADCIN28_ADCIN29&#160;</td><td class="fielddoc"><p>differential, ADCIN28 and ADCIN29 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7b9fa1ae8a65e534cce7d26fa0984f6a9ca4ac4c1ca17fbe6c90fd507206271d"></a>ADC_CH_ADCIN30_ADCIN31&#160;</td><td class="fielddoc"><p>differential, ADCIN30 and ADCIN31 </p>
</td></tr>
</table>

</div>
</div>
<a id="gacd907be60c59083e2bf41efcc36d4baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd907be60c59083e2bf41efcc36d4baf">&#9670;&nbsp;</a></span>ADC_PulseMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#gacd907be60c59083e2bf41efcc36d4baf">ADC_PulseMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_setInterruptPulseMode() as the <em>pulseMode</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacd907be60c59083e2bf41efcc36d4bafa5c34190501b6d5ab20ff71972cf84fbd"></a>ADC_PULSE_END_OF_ACQ_WIN&#160;</td><td class="fielddoc"><p>Occurs at the end of the acquisition window. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd907be60c59083e2bf41efcc36d4bafa5e8213d4f17b42a398ea39e0318606e2"></a>ADC_PULSE_END_OF_CONV&#160;</td><td class="fielddoc"><p>Occurs at the end of the conversion. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2cb95bd359b9df2dfd0977ce2020df06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cb95bd359b9df2dfd0977ce2020df06">&#9670;&nbsp;</a></span>ADC_IntNumber</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga2cb95bd359b9df2dfd0977ce2020df06">ADC_IntNumber</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_enableInterrupt(), ADC_disableInterrupt(), and ADC_getInterruptStatus() as the <em>adcIntNum</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2cb95bd359b9df2dfd0977ce2020df06afa11dee02381f1e8e1a6c7474f5d9948"></a>ADC_INT_NUMBER1&#160;</td><td class="fielddoc"><p>ADCINT1 Interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2cb95bd359b9df2dfd0977ce2020df06a2971cc781b210a2fdb5100778ab39ab7"></a>ADC_INT_NUMBER2&#160;</td><td class="fielddoc"><p>ADCINT2 Interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2cb95bd359b9df2dfd0977ce2020df06ae8f41bdfcea215b0fe376f1b2c67bf2e"></a>ADC_INT_NUMBER3&#160;</td><td class="fielddoc"><p>ADCINT3 Interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2cb95bd359b9df2dfd0977ce2020df06ab01ee13f397ca14ebd27f74751c7a599"></a>ADC_INT_NUMBER4&#160;</td><td class="fielddoc"><p>ADCINT4 Interrupt. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga17f0c071ab2c71a40e3d95c9eeadf3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17f0c071ab2c71a40e3d95c9eeadf3b9">&#9670;&nbsp;</a></span>ADC_PPBNumber</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga17f0c071ab2c71a40e3d95c9eeadf3b9">ADC_PPBNumber</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed in as the <em>ppbNumber</em> parameter for several functions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga17f0c071ab2c71a40e3d95c9eeadf3b9a3d5ab08197c2c052a70bbd9e11e3d85b"></a>ADC_PPB_NUMBER1&#160;</td><td class="fielddoc"><p>Post-processing block 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga17f0c071ab2c71a40e3d95c9eeadf3b9a9bf980daa1de121251f266292f09184b"></a>ADC_PPB_NUMBER2&#160;</td><td class="fielddoc"><p>Post-processing block 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga17f0c071ab2c71a40e3d95c9eeadf3b9a449772890acf04ae6376aa660f62acbb"></a>ADC_PPB_NUMBER3&#160;</td><td class="fielddoc"><p>Post-processing block 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga17f0c071ab2c71a40e3d95c9eeadf3b9a98869b3648a71291ceeb5e095b4d3115"></a>ADC_PPB_NUMBER4&#160;</td><td class="fielddoc"><p>Post-processing block 4. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga254fedc72090784dcfcdcebebdf3ea39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga254fedc72090784dcfcdcebebdf3ea39">&#9670;&nbsp;</a></span>ADC_SOCNumber</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga254fedc72090784dcfcdcebebdf3ea39">ADC_SOCNumber</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed in as the <em>socNumber</em> parameter for several functions. This value identifies the start-of-conversion (SOC) that a function is configuring or accessing. Note that in some cases (for example, ADC_setInterruptSource()) <em>socNumber</em> is used to refer to the corresponding end-of-conversion (EOC). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a13f3e19d5ee844b3a2eff08681becbb3"></a>ADC_SOC_NUMBER0&#160;</td><td class="fielddoc"><p>SOC/EOC number 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a59ed2ddcb0833aaa80234623679f25f2"></a>ADC_SOC_NUMBER1&#160;</td><td class="fielddoc"><p>SOC/EOC number 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a9efee36aa12204bd511fe602f86fb3c6"></a>ADC_SOC_NUMBER2&#160;</td><td class="fielddoc"><p>SOC/EOC number 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a8db276a4433b2be5934d7574feca8ea7"></a>ADC_SOC_NUMBER3&#160;</td><td class="fielddoc"><p>SOC/EOC number 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a39f5749e05562cc10e49c564b9b882f8"></a>ADC_SOC_NUMBER4&#160;</td><td class="fielddoc"><p>SOC/EOC number 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a6cdb8e506ca9a7824feee9777a5614d1"></a>ADC_SOC_NUMBER5&#160;</td><td class="fielddoc"><p>SOC/EOC number 5. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a78cc89a06b99db4baf8fc31f5e6c4266"></a>ADC_SOC_NUMBER6&#160;</td><td class="fielddoc"><p>SOC/EOC number 6. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39ab06f22bdc9d1c47c5f821e02509ceb43"></a>ADC_SOC_NUMBER7&#160;</td><td class="fielddoc"><p>SOC/EOC number 7. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a7516eb2cb9c101fbf83d0cf686b4131e"></a>ADC_SOC_NUMBER8&#160;</td><td class="fielddoc"><p>SOC/EOC number 8. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a5fdf20c2c172e83b96b13e6cbe780113"></a>ADC_SOC_NUMBER9&#160;</td><td class="fielddoc"><p>SOC/EOC number 9. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a91693adcb98cdb52520609381ae97d32"></a>ADC_SOC_NUMBER10&#160;</td><td class="fielddoc"><p>SOC/EOC number 10. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a24cd87237628ac79b2891574e0b2ca16"></a>ADC_SOC_NUMBER11&#160;</td><td class="fielddoc"><p>SOC/EOC number 11. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a74351fde1fcdcaa8748a395f988954c2"></a>ADC_SOC_NUMBER12&#160;</td><td class="fielddoc"><p>SOC/EOC number 12. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39ab5f9d250d79f83f71eb90ecc93fcde16"></a>ADC_SOC_NUMBER13&#160;</td><td class="fielddoc"><p>SOC/EOC number 13. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39ab87336c7e8a08b3f4676385f10f6e5b0"></a>ADC_SOC_NUMBER14&#160;</td><td class="fielddoc"><p>SOC/EOC number 14. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39ac8d4c48ec980b4cf3a20afcf5527d37b"></a>ADC_SOC_NUMBER15&#160;</td><td class="fielddoc"><p>SOC/EOC number 15. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a2c34128042a216aeca4d41d9221ccab6"></a>ADC_SOC_NUMBER16&#160;</td><td class="fielddoc"><p>SOC/EOC number 16. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39af7eb671d75bfa044ed425e463d3f1da7"></a>ADC_SOC_NUMBER17&#160;</td><td class="fielddoc"><p>SOC/EOC number 17. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39ab7dc3bd3c297e87342da57ca837ac940"></a>ADC_SOC_NUMBER18&#160;</td><td class="fielddoc"><p>SOC/EOC number 18. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a3191ae751bfe9c94c07cb58998c9a43a"></a>ADC_SOC_NUMBER19&#160;</td><td class="fielddoc"><p>SOC/EOC number 19. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a38e3e934f4912c0a1336e0f421c80d09"></a>ADC_SOC_NUMBER20&#160;</td><td class="fielddoc"><p>SOC/EOC number 20. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39ab0fc151334d8d4dcf18053b99d3127af"></a>ADC_SOC_NUMBER21&#160;</td><td class="fielddoc"><p>SOC/EOC number 21. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a12f3cfce1f0cd377e564480ff2ebe38c"></a>ADC_SOC_NUMBER22&#160;</td><td class="fielddoc"><p>SOC/EOC number 22. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a2da7db3567b3f288c7c1f57563768b26"></a>ADC_SOC_NUMBER23&#160;</td><td class="fielddoc"><p>SOC/EOC number 23. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a45a86fe81893eb13854e78c84c6a5f93"></a>ADC_SOC_NUMBER24&#160;</td><td class="fielddoc"><p>SOC/EOC number 24. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a1fb883a64a5d03ef5580f0cf536b6942"></a>ADC_SOC_NUMBER25&#160;</td><td class="fielddoc"><p>SOC/EOC number 25. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39ab2853bff633d2bd3de1c9a7f2e28b186"></a>ADC_SOC_NUMBER26&#160;</td><td class="fielddoc"><p>SOC/EOC number 26. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39aeb2f5462f92809dc5f1eb5953e4fcf4e"></a>ADC_SOC_NUMBER27&#160;</td><td class="fielddoc"><p>SOC/EOC number 27. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a7dd65f1a31b3d257e5aaf50f345d2393"></a>ADC_SOC_NUMBER28&#160;</td><td class="fielddoc"><p>SOC/EOC number 28. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39acb07c647438ceefa045472790ea644dc"></a>ADC_SOC_NUMBER29&#160;</td><td class="fielddoc"><p>SOC/EOC number 29. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a1194ffd9e76ba612a6e9031969b74a12"></a>ADC_SOC_NUMBER30&#160;</td><td class="fielddoc"><p>SOC/EOC number 30. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga254fedc72090784dcfcdcebebdf3ea39a56db8aca15718bbcbd9e129205c19159"></a>ADC_SOC_NUMBER31&#160;</td><td class="fielddoc"><p>SOC/EOC number 31. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga174a238f04d1d0ec1b89fdd7fed64716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga174a238f04d1d0ec1b89fdd7fed64716">&#9670;&nbsp;</a></span>ADC_IntSOCTrigger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga174a238f04d1d0ec1b89fdd7fed64716">ADC_IntSOCTrigger</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed in as the <em>trigger</em> parameter for the ADC_setInterruptSOCTrigger() function. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga174a238f04d1d0ec1b89fdd7fed64716a4033eb805c2ff7c5c075dc9fa605e83c"></a>ADC_INT_SOC_TRIGGER_NONE&#160;</td><td class="fielddoc"><p>No ADCINT will trigger the SOC. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga174a238f04d1d0ec1b89fdd7fed64716a39b229325d41b2005924aa16092f4a1b"></a>ADC_INT_SOC_TRIGGER_ADCINT1&#160;</td><td class="fielddoc"><p>ADCINT1 will trigger the SOC. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga174a238f04d1d0ec1b89fdd7fed64716a080ccc812e44c8e0810b21002f063441"></a>ADC_INT_SOC_TRIGGER_ADCINT2&#160;</td><td class="fielddoc"><p>ADCINT2 will trigger the SOC. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4f60e7ea55578eb4eb621f31b0b8d434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f60e7ea55578eb4eb621f31b0b8d434">&#9670;&nbsp;</a></span>ADC_PriorityMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga4f60e7ea55578eb4eb621f31b0b8d434">ADC_PriorityMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_setSOCPriority() as the <em>priMode</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a297bc0c03e8352b0f234a141252dc7f3"></a>ADC_PRI_ALL_ROUND_ROBIN&#160;</td><td class="fielddoc"><p>Round robin mode is used for all. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434ae10aaea1f0763b40c298500b057774a8"></a>ADC_PRI_SOC0_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a19a3f3c76a8963f876008710aeb3a5b5"></a>ADC_PRI_THRU_SOC1_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-1 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a372fef4bd7fe8686df74123f40603d50"></a>ADC_PRI_THRU_SOC2_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-2 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a1e43c265fd367fcad89ad2a896e29bd3"></a>ADC_PRI_THRU_SOC3_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-3 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434adb7fd3d22b7a6b536bc47e7aa246989a"></a>ADC_PRI_THRU_SOC4_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-4 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a55ed343f8dd4b373920daee023c03e48"></a>ADC_PRI_THRU_SOC5_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-5 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a28b9206f25277389c69a842f4dea6940"></a>ADC_PRI_THRU_SOC6_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-6 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a8e123710fcb95aa0a05c53259f1cf9c3"></a>ADC_PRI_THRU_SOC7_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-7 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a6014c8669b5e453fdf3649217f70f443"></a>ADC_PRI_THRU_SOC8_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-8 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a072852a73c92262b544f8d7af02bd27d"></a>ADC_PRI_THRU_SOC9_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-9 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434ab8bb4480710462a8e7a64fa3a116d7fb"></a>ADC_PRI_THRU_SOC10_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-10 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434abc2343f5f792f5790d5878f646ea894a"></a>ADC_PRI_THRU_SOC11_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-11 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a063bb00e48f66e0fa5c1f7973fee3887"></a>ADC_PRI_THRU_SOC12_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-12 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434aeac0757f770d9cc6ae33fd057eeae9c8"></a>ADC_PRI_THRU_SOC13_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-13 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a08bb1b8bfa841546c145ceba2ddea875"></a>ADC_PRI_THRU_SOC14_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-14 hi pri, SOC15 in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434acdf39a98a8425182018a2f8e0162a5cb"></a>ADC_PRI_THRU_SOC15_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-15 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434ac5c4f6f450e4f5916f4032d204fb88a9"></a>ADC_PRI_THRU_SOC16_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-16 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a7d080b9b3471c061a39063acddd66481"></a>ADC_PRI_THRU_SOC17_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-17 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a8bd9794635253ede2b433427da9e116b"></a>ADC_PRI_THRU_SOC18_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-18 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a508c9be71fbca587c3c36817c0986f7e"></a>ADC_PRI_THRU_SOC19_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-19 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a5ec5b8bc7d803416f4a7b27879ce1832"></a>ADC_PRI_THRU_SOC20_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-20 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434aa46dcf49dfd0eb944e86fcf24ad60412"></a>ADC_PRI_THRU_SOC21_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-21 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a7bda02181026be05358e68f52c6e76b2"></a>ADC_PRI_THRU_SOC22_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-22 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a6bb56fad1c52471748b59de3e224e3d8"></a>ADC_PRI_THRU_SOC23_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-23 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a460c9c0712039c569c4249957db3e77f"></a>ADC_PRI_THRU_SOC24_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-24 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434ab632fa2399ef36729f1ce6ebb79bccae"></a>ADC_PRI_THRU_SOC25_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-25 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434af3ebad5908c6f8dab8b412f78e42b098"></a>ADC_PRI_THRU_SOC26_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-26 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a355740f3911647ce45fb7fd44f17bc76"></a>ADC_PRI_THRU_SOC27_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-27 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434ad72c5afb731cab6dfd17ae6b4035b4d8"></a>ADC_PRI_THRU_SOC28_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-28 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434a148f6936ef6ea6c934243eeb7877bbb9"></a>ADC_PRI_THRU_SOC29_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-29 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434ad13d520e8911b242c44a6fe9f81e0518"></a>ADC_PRI_THRU_SOC30_HIPRI&#160;</td><td class="fielddoc"><p>SOC 0-30 hi pri, others in round robin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4f60e7ea55578eb4eb621f31b0b8d434aeba70de1a0c4cefebc3d882eab391ec2"></a>ADC_PRI_ALL_HIPRI&#160;</td><td class="fielddoc"><p>All priorities based on SOC number. </p>
</td></tr>
</table>

</div>
</div>
<a id="gad33ea1f3c3db73f25e0bdf15a86be959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad33ea1f3c3db73f25e0bdf15a86be959">&#9670;&nbsp;</a></span>ADC_ReferenceMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#gad33ea1f3c3db73f25e0bdf15a86be959">ADC_ReferenceMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_getTemperatureC(), ADC_getTemperatureK(), ADC_setVREF() and ADC_setOffsetTrimAll() as the <em>refMode</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad33ea1f3c3db73f25e0bdf15a86be959afbf176ce408c0621a20dd98442ac05ae"></a>ADC_REFERENCE_INTERNAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggad33ea1f3c3db73f25e0bdf15a86be959a0ee3dc6caaacf9fe3cd3122d5cba5ac3"></a>ADC_REFERENCE_EXTERNAL&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga1382e9ae48e28340cff1ea75f6f59ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1382e9ae48e28340cff1ea75f6f59ac8">&#9670;&nbsp;</a></span>ADC_OSDetectMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga1382e9ae48e28340cff1ea75f6f59ac8">ADC_OSDetectMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_configOSDetectMode() as the <em>modeVal</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1382e9ae48e28340cff1ea75f6f59ac8a8b7b4cab894595c4d1056ef488ad50d2"></a>ADC_OSDETECT_MODE_DISABLED&#160;</td><td class="fielddoc"><p>Open/Shorts detection cir- cuit(O/S DC) is disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1382e9ae48e28340cff1ea75f6f59ac8a0bc8c376217079542283f8c91774e536"></a>ADC_OSDETECT_MODE_VSSA&#160;</td><td class="fielddoc"><p>O/S DC is enabled at zero scale </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1382e9ae48e28340cff1ea75f6f59ac8ae10bc136097e9958d5b5617ba8428859"></a>ADC_OSDETECT_MODE_VDDA&#160;</td><td class="fielddoc"><p>O/S DC is enabled at full scale </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1382e9ae48e28340cff1ea75f6f59ac8aec7f2b4f867bc685084680e5dbe67e22"></a>ADC_OSDETECT_MODE_5BY12_VDDA&#160;</td><td class="fielddoc"><p>O/S DC is enabled at 5/12 scale </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1382e9ae48e28340cff1ea75f6f59ac8a8a9ee2f5a0ea746b1fb8eee9863d1f58"></a>ADC_OSDETECT_MODE_7BY12_VDDA&#160;</td><td class="fielddoc"><p>O/S DC is enabled at 7/12 scale </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1382e9ae48e28340cff1ea75f6f59ac8ab5a9dfa551c7bf77f6a820d52f87ec2b"></a>ADC_OSDETECT_MODE_5K_PULLDOWN_TO_VSSA&#160;</td><td class="fielddoc"><p>O/S DC is enabled at 5K pulldown to VSSA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1382e9ae48e28340cff1ea75f6f59ac8a7b452e69971703733b16f83812f3b8f3"></a>ADC_OSDETECT_MODE_5K_PULLUP_TO_VDDA&#160;</td><td class="fielddoc"><p>O/S DC is enabled at 5K pullup to VDDA </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1382e9ae48e28340cff1ea75f6f59ac8a942323fa80bf386ebfed4649d032ba9b"></a>ADC_OSDETECT_MODE_7K_PULLDOWN_TO_VSSA&#160;</td><td class="fielddoc"><p>O/S DC is enabled at 7K pulldown to VSSA </p>
</td></tr>
</table>

</div>
</div>
<a id="ga72acbe8c2b8c18788798e8d0e7655024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72acbe8c2b8c18788798e8d0e7655024">&#9670;&nbsp;</a></span>ADC_OffsetTrim</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga72acbe8c2b8c18788798e8d0e7655024">ADC_OffsetTrim</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_selectOffsetTrimMode() as the <em>mode</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga72acbe8c2b8c18788798e8d0e7655024ae3bdb98b7760c1978ae2bfde8f28cf6e"></a>ADC_OFFSET_TRIM_COMMON&#160;</td><td class="fielddoc"><p>Common Trim register for all ADC modes </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72acbe8c2b8c18788798e8d0e7655024abae2687c1d59856c487597a6e8cd510b"></a>ADC_OFFSET_TRIM_INDIVIDUAL&#160;</td><td class="fielddoc"><p>Individual Trim registers for different ADC modes </p>
</td></tr>
</table>

</div>
</div>
<a id="ga429dd4804497c259c3e869cbca38106c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga429dd4804497c259c3e869cbca38106c">&#9670;&nbsp;</a></span>ADC_ChannelType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga429dd4804497c259c3e869cbca38106c">ADC_ChannelType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to <a class="el" href="group__adc__api.html#ga82811db076d3d59caa26e85fe3f9e4a9">ADC_setupSOCRefloChannel()</a> as the <em>channelType</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga429dd4804497c259c3e869cbca38106ca22d9da0985e7e2b4c2bedc2310e3a33e"></a>ADC_CHANNEL_ODD&#160;</td><td class="fielddoc"><p>ADC Odd Channel. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga429dd4804497c259c3e869cbca38106ca13d9fe16f605bd2ff88ad0d9a70cc045"></a>ADC_CHANNEL_EVEN&#160;</td><td class="fielddoc"><p>ADC Even Channel. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga51ed1bc5073c7ef6394c3538b007e730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51ed1bc5073c7ef6394c3538b007e730">&#9670;&nbsp;</a></span>ADC_SyncInput</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga51ed1bc5073c7ef6394c3538b007e730">ADC_SyncInput</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_selectPPBSyncInput() and ADC_triggerRepeaterSyncIn() as the <em>syncInput</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a41950eda6b33032b1ed1796e261c5e46"></a>ADC_SYNCIN_DISABLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730ae13163396045d4e31f09fd751fa0b642"></a>ADC_SYNCIN_EPWM1SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a48bb8988f5c66d84f13e43230820f9bc"></a>ADC_SYNCIN_EPWM2SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM1SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730afab12c263e64ed37f0807064415261f7"></a>ADC_SYNCIN_EPWM3SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM2SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a032c11920ea51a6977dc65ff6a6b068a"></a>ADC_SYNCIN_EPWM4SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM3SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a37e1396ad77a1d063c9a3996157c1a88"></a>ADC_SYNCIN_EPWM5SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM4SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a19bb46179ab36c9f2e646482ad8220a2"></a>ADC_SYNCIN_EPWM6SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM5SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a2021f7abe48e940eba39cbdf0925d980"></a>ADC_SYNCIN_EPWM7SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM6SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a87d80c9270c7df2ceb1e4b71580868a0"></a>ADC_SYNCIN_EPWM8SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM7SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a0cdf546ca57364be622725cdacdda4f0"></a>ADC_SYNCIN_EPWM9SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM8SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a1238097bb48d1a655449fe37f53babc5"></a>ADC_SYNCIN_EPWM10SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM9SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a2c33cae000e4b882a825c76087ed81c8"></a>ADC_SYNCIN_EPWM11SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM10SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a91468ed4784715bd54498ea7a9a7d6fd"></a>ADC_SYNCIN_EPWM12SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM11SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a9f46403397f2f69d6da86ae2be899e64"></a>ADC_SYNCIN_EPWM13SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM12SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a35eddfc6d1eaf07619ac1d0301523adf"></a>ADC_SYNCIN_EPWM14SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM13SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a6c2c37c0a77248fd7486e3c9509f9870"></a>ADC_SYNCIN_EPWM15SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM14SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a15d0dea52652bbae29f422096694ede3"></a>ADC_SYNCIN_EPWM16SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM15SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a2b0cccbe61bc6f46e60bd44f4234e956"></a>ADC_SYNCIN_EPWM17SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM16SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a18f4dc42ed32a13e328e471560e65b29"></a>ADC_SYNCIN_EPWM18SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM17SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730aeed5d2f93c9926d1a586c0fb65228e6c"></a>ADC_SYNCIN_ECAP1YNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is EPWM18SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a33b3645efef8b344382ef630fdcb0314"></a>ADC_SYNCIN_ECAP2SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is ECAP1YNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730aa9ac95ebab6eeae932d28dd0e44396f6"></a>ADC_SYNCIN_ECAP3SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is ECAP2SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730aca2b3446ec558ca82fe014ce3c73dfe7"></a>ADC_SYNCIN_ECAP4SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is ECAP3SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730aaff6a489126a0c94de85c8e8ba4f0bd8"></a>ADC_SYNCIN_ECAP5SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is ECAP4SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a4d18ba2f47461645b6353702ad5e11ed"></a>ADC_SYNCIN_ECAP6SYNCOUT&#160;</td><td class="fielddoc"><p>ADC Syncin is ECAP5SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a656ffa7dc83419044269a595880dc7b9"></a>ADC_SYNCIN_INPUTXBAROUTPUT5&#160;</td><td class="fielddoc"><p>ADC Syncin is ECAP6SYNCOUT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730a4237b3a4beb4c67e26ee2c3c28b33b74"></a>ADC_SYNCIN_INPUTXBAROUTPUT6&#160;</td><td class="fielddoc"><p>ADC Syncin is INPUTXBAROUTPUT5. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730ada6482130750544d41d4c06d7564efac"></a>ADC_SYNCIN_EtherCATSYNC0&#160;</td><td class="fielddoc"><p>ADC Syncin is INPUTXBAROUTPUT6. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga51ed1bc5073c7ef6394c3538b007e730aab03988b39584201fd47805fb18e73fa"></a>ADC_SYNCIN_EtherCATSYNC1&#160;</td><td class="fielddoc"><p>ADC Syncin is EtherCATSYNC0. </p>
</td></tr>
</table>

</div>
</div>
<a id="gadae07564f94d93024778cb2e621781ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadae07564f94d93024778cb2e621781ae">&#9670;&nbsp;</a></span>ADC_PPBIntSrcSelect</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#gadae07564f94d93024778cb2e621781ae">ADC_PPBIntSrcSelect</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_selectPPBOSINTSource() as the <em>osIntSrc</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadae07564f94d93024778cb2e621781aeae5cb2607a2c7d5dd5463e7dcf5cc51f3"></a>ADC_PPB_OS_INT_1&#160;</td><td class="fielddoc"><p>PCount generates PPB interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadae07564f94d93024778cb2e621781aeaa11f3a1099ed33a69feff17f86bf5c49"></a>ADC_PPB_OS_INT_2&#160;</td><td class="fielddoc"><p>PCount/Sync generates PPB interrupt. </p>
</td></tr>
</table>

</div>
</div>
<a id="gac186093663d49a0c9d694073931f68f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac186093663d49a0c9d694073931f68f3">&#9670;&nbsp;</a></span>ADC_ExtChannel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#gac186093663d49a0c9d694073931f68f3">ADC_ExtChannel</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_selectSOCExtChannel() as the <em>extChannel</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac186093663d49a0c9d694073931f68f3ac0cdad9486484fc0d92bea2711f231f1"></a>ADC_CH_ADCINX_0&#160;</td><td class="fielddoc"><p>ADCINX.0 is converted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac186093663d49a0c9d694073931f68f3a3d194432508adef085ae548b88a6de61"></a>ADC_CH_ADCINX_1&#160;</td><td class="fielddoc"><p>ADCINX.1 is converted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac186093663d49a0c9d694073931f68f3a35f27ed6e41fa36261591477f2c93929"></a>ADC_CH_ADCINX_2&#160;</td><td class="fielddoc"><p>ADCINX.2 is converted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac186093663d49a0c9d694073931f68f3aeb956aab76588f8dcf0d373ee3fe3359"></a>ADC_CH_ADCINX_3&#160;</td><td class="fielddoc"><p>ADCINX.3 is converted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac186093663d49a0c9d694073931f68f3a2b4747946f18c1d740903c59aa7d6f40"></a>ADC_CH_ADCINX_4&#160;</td><td class="fielddoc"><p>ADCINX.4 is converted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac186093663d49a0c9d694073931f68f3ab2da3d4ab7bec1dc3f6021cb7b30ec68"></a>ADC_CH_ADCINX_5&#160;</td><td class="fielddoc"><p>ADCINX.5 is converted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac186093663d49a0c9d694073931f68f3a7778298751055dba692682c8fb218ac9"></a>ADC_CH_ADCINX_6&#160;</td><td class="fielddoc"><p>ADCINX.6 is converted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac186093663d49a0c9d694073931f68f3a34b6586017e49cc72a1d540022c3270b"></a>ADC_CH_ADCINX_7&#160;</td><td class="fielddoc"><p>ADCINX.7 is converted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac186093663d49a0c9d694073931f68f3a0fae55c47fe1a9ca40bdb58b3ee2d27d"></a>ADC_CH_ADCINX_8&#160;</td><td class="fielddoc"><p>ADCINX.8 is converted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac186093663d49a0c9d694073931f68f3af357aee792ce93d2212b7d9575242b27"></a>ADC_CH_ADCINX_9&#160;</td><td class="fielddoc"><p>ADCINX.9 is converted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac186093663d49a0c9d694073931f68f3ac29668b774b7862e859b8b7e0fd8e7d8"></a>ADC_CH_ADCINX_10&#160;</td><td class="fielddoc"><p>ADCINX.10 is converted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac186093663d49a0c9d694073931f68f3a2e2253862a5176525a3e3592669cfdcb"></a>ADC_CH_ADCINX_11&#160;</td><td class="fielddoc"><p>ADCINX.11 is converted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac186093663d49a0c9d694073931f68f3a4dd4f9ed02f0625cdca91a5fc1221983"></a>ADC_CH_ADCINX_12&#160;</td><td class="fielddoc"><p>ADCINX.12 is converted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac186093663d49a0c9d694073931f68f3a5937a03fe7104c7820cfd223dfdf04e6"></a>ADC_CH_ADCINX_13&#160;</td><td class="fielddoc"><p>ADCINX.13 is converted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac186093663d49a0c9d694073931f68f3a3faf5fd32b323c00dd7acee22ab4027b"></a>ADC_CH_ADCINX_14&#160;</td><td class="fielddoc"><p>ADCINX.14 is converted. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac186093663d49a0c9d694073931f68f3a5cab692d00f1b78fd63a2fc392fbec66"></a>ADC_CH_ADCINX_15&#160;</td><td class="fielddoc"><p>ADCINX.15 is converted. </p>
</td></tr>
</table>

</div>
</div>
<a id="gae4463487eb170cf7f23699e7f01407de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4463487eb170cf7f23699e7f01407de">&#9670;&nbsp;</a></span>ADC_IntTrigger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#gae4463487eb170cf7f23699e7f01407de">ADC_IntTrigger</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_setInterruptSource() as the <em>intTrigger</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dead4acdf8ca5a203cf89c67c6d694b2571"></a>ADC_INT_TRIGGER_EOC0&#160;</td><td class="fielddoc"><p>SOC/EOC0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407deaa0e0df9643f002c4d6c10e55c6d706e2"></a>ADC_INT_TRIGGER_EOC1&#160;</td><td class="fielddoc"><p>SOC/EOC1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dead96d0ff5c846e3b6a1f261f9bb1bed7b"></a>ADC_INT_TRIGGER_EOC2&#160;</td><td class="fielddoc"><p>SOC/EOC2. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea8fe1c5a1301d86ff3a8c0ff5df0755e1"></a>ADC_INT_TRIGGER_EOC3&#160;</td><td class="fielddoc"><p>SOC/EOC3. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea5c8b209b2082703e8049a9274cfded31"></a>ADC_INT_TRIGGER_EOC4&#160;</td><td class="fielddoc"><p>SOC/EOC4. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea3cbd125de68d66ae2c85248a966dd38f"></a>ADC_INT_TRIGGER_EOC5&#160;</td><td class="fielddoc"><p>SOC/EOC5. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea7c24904e334f0fa486819ea7b784409c"></a>ADC_INT_TRIGGER_EOC6&#160;</td><td class="fielddoc"><p>SOC/EOC6. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407deaf6f18a3623bddd8b80311cfad41c6f46"></a>ADC_INT_TRIGGER_EOC7&#160;</td><td class="fielddoc"><p>SOC/EOC7. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea6a74db64e6456af9370382a7794388ab"></a>ADC_INT_TRIGGER_EOC8&#160;</td><td class="fielddoc"><p>SOC/EOC8. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea374338a5b0dcf9eccc5b1a4001919353"></a>ADC_INT_TRIGGER_EOC9&#160;</td><td class="fielddoc"><p>SOC/EOC9. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dead363cfbc6c9892cc0192d422d6ae12b7"></a>ADC_INT_TRIGGER_EOC10&#160;</td><td class="fielddoc"><p>SOC/EOC10. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea2d3d9433df29fb7fa5a2ba0c0472eaed"></a>ADC_INT_TRIGGER_EOC11&#160;</td><td class="fielddoc"><p>SOC/EOC11. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407deafc8eaf85e4437d37cf7269b0cd322d19"></a>ADC_INT_TRIGGER_EOC12&#160;</td><td class="fielddoc"><p>SOC/EOC12. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea1821021d2f11ff390522e39ab01459ea"></a>ADC_INT_TRIGGER_EOC13&#160;</td><td class="fielddoc"><p>SOC/EOC13. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea85901a0f3ca55488629c7fdd2236c83e"></a>ADC_INT_TRIGGER_EOC14&#160;</td><td class="fielddoc"><p>SOC/EOC14. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea2beda0c3545710449cf83f72d188d8d6"></a>ADC_INT_TRIGGER_EOC15&#160;</td><td class="fielddoc"><p>SOC/EOC15. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407deaf3562050107e667badd6bb16604e867b"></a>ADC_INT_TRIGGER_EOC16&#160;</td><td class="fielddoc"><p>SOC/EO16. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea824cb0fdd7d1f6634eb6a6babcfe38f5"></a>ADC_INT_TRIGGER_EOC17&#160;</td><td class="fielddoc"><p>SOC/EO17. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407deab327ccd869c6f93b76b5c2acf5082155"></a>ADC_INT_TRIGGER_EOC18&#160;</td><td class="fielddoc"><p>SOC/EO18. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea71c1e5fe49d5eed2b5668dfc6b90afd5"></a>ADC_INT_TRIGGER_EOC19&#160;</td><td class="fielddoc"><p>SOC/EOC19. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dead98f93edc6cc8c66fb7c5df82bb0c740"></a>ADC_INT_TRIGGER_EOC20&#160;</td><td class="fielddoc"><p>SOC/EOC20. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407deaae00eb442b512f6ff46963fae3a607f2"></a>ADC_INT_TRIGGER_EOC21&#160;</td><td class="fielddoc"><p>SOC/EOC21. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea94928b762a977db6f3a5bfda3f881e02"></a>ADC_INT_TRIGGER_EOC22&#160;</td><td class="fielddoc"><p>SOC/EOC22. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea79f9371b37f92eab7c52abe9f175c844"></a>ADC_INT_TRIGGER_EOC23&#160;</td><td class="fielddoc"><p>SOC/EOC23. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407deae319ada4015d4af8da703544a4a5153e"></a>ADC_INT_TRIGGER_EOC24&#160;</td><td class="fielddoc"><p>SOC/EOC24. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea6cc98671377de577dee2ec8f1f482141"></a>ADC_INT_TRIGGER_EOC25&#160;</td><td class="fielddoc"><p>SOC/EOC25. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407deac3e3ef4763b8585b3a1dbe5b1d0c7682"></a>ADC_INT_TRIGGER_EOC26&#160;</td><td class="fielddoc"><p>SOC/EOC26. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea939599e313e8fe46b07995f98d3af542"></a>ADC_INT_TRIGGER_EOC27&#160;</td><td class="fielddoc"><p>SOC/EOC27. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea5f3d91ea8f8fa3c9982f8f757f6c1fcf"></a>ADC_INT_TRIGGER_EOC28&#160;</td><td class="fielddoc"><p>SOC/EOC28. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea832e4585a3f48cdfe28d556bd1484f30"></a>ADC_INT_TRIGGER_EOC29&#160;</td><td class="fielddoc"><p>SOC/EOC29. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea7e89b09471ea59d7f98e3bc60fd313aa"></a>ADC_INT_TRIGGER_EOC30&#160;</td><td class="fielddoc"><p>SOC/EOC30. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea7231f8841a2f8c2d6dd93bcba143f077"></a>ADC_INT_TRIGGER_EOC31&#160;</td><td class="fielddoc"><p>SOC/EOC31. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea6077eca8223871d0b5e08bf59dd5ac70"></a>ADC_INT_TRIGGER_OSINT1&#160;</td><td class="fielddoc"><p>OSINT1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dea4cedaff77ac3d94d4ef845f0e9ea37da"></a>ADC_INT_TRIGGER_OSINT2&#160;</td><td class="fielddoc"><p>OSINT2. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407deabb84ea3813e57182fc573cbfbb299815"></a>ADC_INT_TRIGGER_OSINT3&#160;</td><td class="fielddoc"><p>OSINT3. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae4463487eb170cf7f23699e7f01407dead7a5eab7d36d3f6312cfe357dc8d44dd"></a>ADC_INT_TRIGGER_OSINT4&#160;</td><td class="fielddoc"><p>OSINT4. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga0959e6a2d0772e9adc3327878252fe2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0959e6a2d0772e9adc3327878252fe2a">&#9670;&nbsp;</a></span>ADC_PPBCompSource</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga0959e6a2d0772e9adc3327878252fe2a">ADC_PPBCompSource</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_selectPPBCompareSource() as the <em>compSrc</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0959e6a2d0772e9adc3327878252fe2aa9adb1df4f3d9b2927906a8d086ec506f"></a>ADC_PPB_COMPSOURCE_RESULT&#160;</td><td class="fielddoc"><p>PPB compare source is ADCRESULT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0959e6a2d0772e9adc3327878252fe2aaa889b4cd3438f66cf1bfcd99981fee73"></a>ADC_PPB_COMPSOURCE_PSUM&#160;</td><td class="fielddoc"><p>PPB compare source is PSUM. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0959e6a2d0772e9adc3327878252fe2aac4553bb2628055d20ffa5c037fb58654"></a>ADC_PPB_COMPSOURCE_SUM&#160;</td><td class="fielddoc"><p>PPB compare source is SUM. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa4f3f8888fe66b3d30d3947bee9dcbe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4f3f8888fe66b3d30d3947bee9dcbe8">&#9670;&nbsp;</a></span>ADC_Select</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#gaa4f3f8888fe66b3d30d3947bee9dcbe8">ADC_Select</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_configureSafetyChecker() as the <em>adcInst</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa4f3f8888fe66b3d30d3947bee9dcbe8ae398ae2c45d00fabcd33d7996ec25990"></a>ADC_A&#160;</td><td class="fielddoc"><p>Select ADCA instance. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa4f3f8888fe66b3d30d3947bee9dcbe8a94bd2607f1acc7937a804fd453eea683"></a>ADC_B&#160;</td><td class="fielddoc"><p>Select ADCB instance. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa4f3f8888fe66b3d30d3947bee9dcbe8a8750da840be0920a616b55bc5b5a3abd"></a>ADC_C&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggaa4f3f8888fe66b3d30d3947bee9dcbe8a090a86500ee6a10497c7856690f53f12"></a>ADC_D&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggaa4f3f8888fe66b3d30d3947bee9dcbe8a2599993c48ae1cce505ccb134d7e9402"></a>ADC_E&#160;</td><td class="fielddoc"><p>Select ADCC instance. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga0a948430846a59c84370fecfe2547790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a948430846a59c84370fecfe2547790">&#9670;&nbsp;</a></span>ADC_ResultSelect</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga0a948430846a59c84370fecfe2547790">ADC_ResultSelect</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_configureSafetyChecker() as the <em>adcResultInst</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790ae8905861fb673f5bfb763f9291ec351b"></a>ADC_RESULT0&#160;</td><td class="fielddoc"><p>Select ADC Result 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a54a8927950a590489fc4568b4ac83bcc"></a>ADC_RESULT1&#160;</td><td class="fielddoc"><p>Select ADC Result 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a93a9c52b65ac222370cc1f3c45d23071"></a>ADC_RESULT2&#160;</td><td class="fielddoc"><p>Select ADC Result 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790abdf1cb92fc10946e401eb5f436a5c94d"></a>ADC_RESULT3&#160;</td><td class="fielddoc"><p>Select ADC Result 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a8ea0ec67d0e95a959ee185b6f866eecc"></a>ADC_RESULT4&#160;</td><td class="fielddoc"><p>Select ADC Result 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a3b18728c1d36ac406347211e764d8bcb"></a>ADC_RESULT5&#160;</td><td class="fielddoc"><p>Select ADC Result 5. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790af167f4aa3414898fb963f29158b8a164"></a>ADC_RESULT6&#160;</td><td class="fielddoc"><p>Select ADC Result 6. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790ad93dea9646ecb3acee631331603147b8"></a>ADC_RESULT7&#160;</td><td class="fielddoc"><p>Select ADC Result 7. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a0145cc1be209224ea61bdbdd6c5def81"></a>ADC_RESULT8&#160;</td><td class="fielddoc"><p>Select ADC Result 8. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a2ba9743d7e4b65467c16fb7d8de87f18"></a>ADC_RESULT9&#160;</td><td class="fielddoc"><p>Select ADC Result 9. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a528ba67fe0f0e0e9dffe99f3afd0e04c"></a>ADC_RESULT10&#160;</td><td class="fielddoc"><p>Select ADC Result 10. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790aadaf74c849446e6d815f02966ac21d06"></a>ADC_RESULT11&#160;</td><td class="fielddoc"><p>Select ADC Result 11. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790ab12ca834d2057005807e8b9af6a5998e"></a>ADC_RESULT12&#160;</td><td class="fielddoc"><p>Select ADC Result 12. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a8003eece708358f8f4306fe26aec9db7"></a>ADC_RESULT13&#160;</td><td class="fielddoc"><p>Select ADC Result 13. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a4d25c0b90c49559be454d2ca634e16bc"></a>ADC_RESULT14&#160;</td><td class="fielddoc"><p>Select ADC Result 14. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a69c7c0598f2534a1d4525952d017e6d2"></a>ADC_RESULT15&#160;</td><td class="fielddoc"><p>Select ADC Result 15. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790af323af161149cf46bba7e6a3c0817ad2"></a>ADC_RESULT16&#160;</td><td class="fielddoc"><p>Select ADC Result 16. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a4273d5df281a1e26512c127d36ad82d8"></a>ADC_RESULT17&#160;</td><td class="fielddoc"><p>Select ADC Result 17. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a02394bc107d35852fe756434ce400aa4"></a>ADC_RESULT18&#160;</td><td class="fielddoc"><p>Select ADC Result 18. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790ac73be1597ec5a1454f81e93d2ec6fb93"></a>ADC_RESULT19&#160;</td><td class="fielddoc"><p>Select ADC Result 19. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a7df9ec9953bae63b428c80a4924b815e"></a>ADC_RESULT20&#160;</td><td class="fielddoc"><p>Select ADC Result 20. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a8080662ed70239206a12ce6ad5429edf"></a>ADC_RESULT21&#160;</td><td class="fielddoc"><p>Select ADC Result 21. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790aa223c0c03330d9f0e3a8136390442d08"></a>ADC_RESULT22&#160;</td><td class="fielddoc"><p>Select ADC Result 22. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a23214c1fb684d15969ecb2e1220f2275"></a>ADC_RESULT23&#160;</td><td class="fielddoc"><p>Select ADC Result 23. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790afbd1e6e4650146b2444908096264010d"></a>ADC_RESULT24&#160;</td><td class="fielddoc"><p>Select ADC Result 24. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790ae4ac808643cb98647b8d3db0092b2677"></a>ADC_RESULT25&#160;</td><td class="fielddoc"><p>Select ADC Result 25. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a285577e1420d1382e5cdeffac98dcfba"></a>ADC_RESULT26&#160;</td><td class="fielddoc"><p>Select ADC Result 26. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790af402117a3cd5b5fcc14ca8453bc70c4b"></a>ADC_RESULT27&#160;</td><td class="fielddoc"><p>Select ADC Result 27. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a09311a6786744c8fbc4ea3da3bccb0ec"></a>ADC_RESULT28&#160;</td><td class="fielddoc"><p>Select ADC Result 28. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790aa166db34f918312891ea676bc4ae39d6"></a>ADC_RESULT29&#160;</td><td class="fielddoc"><p>Select ADC Result 29. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a730928c4390939e519f132b059d59238"></a>ADC_RESULT30&#160;</td><td class="fielddoc"><p>Select ADC Result 30. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a948430846a59c84370fecfe2547790a9766cb00f5f99127f217e2546f6d3535"></a>ADC_RESULT31&#160;</td><td class="fielddoc"><p>Select ADC Result 31. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9a99e2014f91f8a1542836553f3345d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a99e2014f91f8a1542836553f3345d3">&#9670;&nbsp;</a></span>ADC_SafetyCheckerInput</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga9a99e2014f91f8a1542836553f3345d3">ADC_SafetyCheckerInput</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_configSOCSafetyCheckerInput() as the <em>scInput</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9a99e2014f91f8a1542836553f3345d3a0d1d013975b50c7bea7925c77e4a0579"></a>ADC_SAFETY_CHECKER_INPUT_DISABLE&#160;</td><td class="fielddoc"><p>Safety checker i/p disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a99e2014f91f8a1542836553f3345d3a1e0d07c76e8c5ecad787c243a6931129"></a>ADC_SAFETY_CHECKER_INPUT_SOCx&#160;</td><td class="fielddoc"><p>Safety checker i/p is SOCx. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a99e2014f91f8a1542836553f3345d3a88ed40901b2365c2694aa33fa571d5a1"></a>ADC_SAFETY_CHECKER_INPUT_PPBx&#160;</td><td class="fielddoc"><p>Safety checker i/p is PPBx. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a99e2014f91f8a1542836553f3345d3ad0617c4b6b1f6664307c3a3351890293"></a>ADC_SAFETY_CHECKER_INPUT_PPBSUMx&#160;</td><td class="fielddoc"><p>Safety checker i/p is PPBSUMx. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf0eaff3df07283db317190504ba7433c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0eaff3df07283db317190504ba7433c">&#9670;&nbsp;</a></span>ADC_SafetyCheckInst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#gaf0eaff3df07283db317190504ba7433c">ADC_SafetyCheckInst</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_getSafetyCheckerResult() as <em>checkInst</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf0eaff3df07283db317190504ba7433ca5a9e1fb57d6252ee34238aa302aa4496"></a>ADC_SAFETY_CHECK1&#160;</td><td class="fielddoc"><p>Safety Check Result 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf0eaff3df07283db317190504ba7433ca7ecfbd9a593936234968e2514f1959cd"></a>ADC_SAFETY_CHECK2&#160;</td><td class="fielddoc"><p>Safety Check Result 2. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga416fb154f5cfd167096b2968caa47a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga416fb154f5cfd167096b2968caa47a95">&#9670;&nbsp;</a></span>ADC_SafetyCheckEvent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga416fb154f5cfd167096b2968caa47a95">ADC_SafetyCheckEvent</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_enableSafetyCheckEvt() and ADC_disableSafetyCheckEvt() as <em>checkEvent</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga416fb154f5cfd167096b2968caa47a95a14a0af99d06cf1395f0cb0df348e479b"></a>ADC_SAFETY_CHECK_EVENT1&#160;</td><td class="fielddoc"><p>Safety Check Event 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga416fb154f5cfd167096b2968caa47a95a34c053db7efd96686653ede1ed6d59ad"></a>ADC_SAFETY_CHECK_EVENT2&#160;</td><td class="fielddoc"><p>Safety Check Event 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga416fb154f5cfd167096b2968caa47a95a100ccd87db0ddd606c5dda4e79db4918"></a>ADC_SAFETY_CHECK_EVENT3&#160;</td><td class="fielddoc"><p>Safety Check Event 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga416fb154f5cfd167096b2968caa47a95a592cf6791472e192e999592526c908ef"></a>ADC_SAFETY_CHECK_EVENT4&#160;</td><td class="fielddoc"><p>Safety Check Event 4. </p>
</td></tr>
</table>

</div>
</div>
<a id="gafe93f7735c9ef3508bb48319305ed633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe93f7735c9ef3508bb48319305ed633">&#9670;&nbsp;</a></span>ADC_SafetyCheckResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#gafe93f7735c9ef3508bb48319305ed633">ADC_SafetyCheckResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_enableSafetyCheckEvt(), ADC_disableSafetyCheckEvt(), ADC_enableSafetyCheckInt() and ADC_disableSafetyCheckInt() as <em>checkResult</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafe93f7735c9ef3508bb48319305ed633aa5bd5fbcfafc0667db3e0c0769b17336"></a>ADC_SAFETY_CHECK_RES1OVF&#160;</td><td class="fielddoc"><p>Safety Check Result1 Overflow. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafe93f7735c9ef3508bb48319305ed633af5d963509a5649b28097ecc76fc30ac2"></a>ADC_SAFETY_CHECK_RES2OVF&#160;</td><td class="fielddoc"><p>Safety Check Result2 Overflow. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafe93f7735c9ef3508bb48319305ed633a328fa625a01203a57bedeb211039b2fc"></a>ADC_SAFETY_CHECK_OOT&#160;</td><td class="fielddoc"><p>Safety Check OOT. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga67bf6616fde2efca32617144cb3f6d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67bf6616fde2efca32617144cb3f6d52">&#9670;&nbsp;</a></span>ADC_Checker</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga67bf6616fde2efca32617144cb3f6d52">ADC_Checker</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_enableSafetyCheckEvt(), ADC_disableSafetyCheckEvt(), ADC_enableSafetyCheckInt(), ADC_disableSafetyCheckInt(), ADC_getSafetyCheckStatus(), ADC_clearSafetyCheckStatus(), ADC_getSafetyCheckIntStatus() and ADC_clearSafetyCheckIntStatus() as <em>checkerNumber</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga67bf6616fde2efca32617144cb3f6d52ab0ab6f48b77203de324719ed5e592443"></a>ADC_SAFETY_CHECKER1&#160;</td><td class="fielddoc"><p>Safety Checker1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67bf6616fde2efca32617144cb3f6d52a476158cc78f35809881e98089f58c809"></a>ADC_SAFETY_CHECKER2&#160;</td><td class="fielddoc"><p>Safety Checker2. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67bf6616fde2efca32617144cb3f6d52a46eeab673e58bcf1f7e1cc321045e9c8"></a>ADC_SAFETY_CHECKER3&#160;</td><td class="fielddoc"><p>Safety Checker3. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67bf6616fde2efca32617144cb3f6d52a85c4cd65efd7c46736b5be790b23c7c8"></a>ADC_SAFETY_CHECKER4&#160;</td><td class="fielddoc"><p>Safety Checker4. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67bf6616fde2efca32617144cb3f6d52add5be3934765579702c6b6becd4c2448"></a>ADC_SAFETY_CHECKER5&#160;</td><td class="fielddoc"><p>Safety Checker5. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67bf6616fde2efca32617144cb3f6d52a7a1d842849506aa741b0fb7f1266e7d4"></a>ADC_SAFETY_CHECKER6&#160;</td><td class="fielddoc"><p>Safety Checker6. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67bf6616fde2efca32617144cb3f6d52a6132cd35e92a4d95269b9b19f2587a40"></a>ADC_SAFETY_CHECKER7&#160;</td><td class="fielddoc"><p>Safety Checker7. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga67bf6616fde2efca32617144cb3f6d52a6594ccc5487bfe12fcd76fabe62e39be"></a>ADC_SAFETY_CHECKER8&#160;</td><td class="fielddoc"><p>Safety Checker8. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa2e0c6a4e97d9e24868acc6adf7f97af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2e0c6a4e97d9e24868acc6adf7f97af">&#9670;&nbsp;</a></span>ADC_SafetyCheckFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#gaa2e0c6a4e97d9e24868acc6adf7f97af">ADC_SafetyCheckFlag</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to ADC_getSafetyCheckStatus() and ADC_clearSafetyCheckStatus(), as <em>checkerFlag</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa2e0c6a4e97d9e24868acc6adf7f97afa8c6978c1783e102d09b363a120d5d80c"></a>ADC_SAFETY_CHECK_OOT_FLG&#160;</td><td class="fielddoc"><p>Safety Check Out-of-Tolerance Flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2e0c6a4e97d9e24868acc6adf7f97afa6cb6fa00c2e2d1736c4bacdf63c1e605"></a>ADC_SAFETY_CHECK_RES1OVF_FLG&#160;</td><td class="fielddoc"><p>Safety Check Result1 Overflow Flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2e0c6a4e97d9e24868acc6adf7f97afa8c42a983bc073e705be431a71bcacfc4"></a>ADC_SAFETY_CHECK_RES2OVF_FLG&#160;</td><td class="fielddoc"><p>Safety Check Result2 Overflow Flag. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga38766c01be33adece810b912d379bf31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38766c01be33adece810b912d379bf31">&#9670;&nbsp;</a></span>ADC_RepInstance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga38766c01be33adece810b912d379bf31">ADC_RepInstance</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to <a class="el" href="group__adc__api.html#ga4a3111e591fb1bc4bb1d40487aff721f">ADC_configureRepeater()</a> as the <em>repInstance</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga38766c01be33adece810b912d379bf31a7dc9a0cd69ba103a635dd46c7634a4d0"></a>ADC_REPINST1&#160;</td><td class="fielddoc"><p>Select ADC repeater instance 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga38766c01be33adece810b912d379bf31a5758993fe56f6fd9c0f68eccee9ea3d7"></a>ADC_REPINST2&#160;</td><td class="fielddoc"><p>Select ADC repeater instance 2. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga697935a135bb2cea5c47e73dc37e2ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga697935a135bb2cea5c47e73dc37e2ba3">&#9670;&nbsp;</a></span>ADC_RepMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__adc__api.html#ga697935a135bb2cea5c47e73dc37e2ba3">ADC_RepMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values that can be passed to <a class="el" href="group__adc__api.html#ga4a3111e591fb1bc4bb1d40487aff721f">ADC_configureRepeater()</a> as the <em>config.repMode</em> and ADC_triggerRepeaterMode() as <em>mode</em> parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga697935a135bb2cea5c47e73dc37e2ba3a8e0aefa6cbb5b36a9d72ad780d0d862c"></a>ADC_REPMODE_OVERSAMPLING&#160;</td><td class="fielddoc"><p>ADC repeater mode is oversampling. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga697935a135bb2cea5c47e73dc37e2ba3aede1e148206378d0b048e8a6c24647a7"></a>ADC_REPMODE_UNDERSAMPLING&#160;</td><td class="fielddoc"><p>ADC repeater mode is undersampling. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga29168166e5e8e7fbb6b7e37532cb3c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29168166e5e8e7fbb6b7e37532cb3c95">&#9670;&nbsp;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(always_inline)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops FLUSH pattern transmission. </p>
<p>Disables the Rx Ping Broadcast Mode.</p>
<p>Enables the Rx Ping Broadcast Mode.</p>
<p>Disables the Rx Ping Compare Mode.</p>
<p>Enables the Rx Ping Compare Mode.</p>
<p>Returns the Rx Ping Tag Mask Value.</p>
<p>Sets the Rx Ping Tag Mask Value.</p>
<p>Returns the Rx Ping Reference Tag Value.</p>
<p>Sets the Rx Ping Tag Reference Value.</p>
<p>Disables the Rx Frame Broadcast Mode.</p>
<p>Enables the Rx Frame Broadcast Mode.</p>
<p>Disables the Rx Frame Compare Mode.</p>
<p>Enables the Rx Frame Compare Mode.</p>
<p>Returns the Rx Frame Tag Mask Value.</p>
<p>Sets the Rx Frame Tag Mask Value.</p>
<p>Returns the Rx Frame Reference Tag Value.</p>
<p>Sets the Rx Frame Reference Tag Value.</p>
<p>Returns address of Rx data buffer.</p>
<p>Let user disable interrupt generation on Rx events.</p>
<p>Let user generate interrupt on occurrence of Rx events.</p>
<p>Returns ECC Log details.</p>
<p>Returns ECC Corrected data.</p>
<p>Sets received ECC value on which ECC (SEC-DED) computaion logic runs.</p>
<p>Sets Rx ECC data on which ECC (SEC-DED) computaion logic runs.</p>
<p>Locks the control of all receive control registers, once locked further writes will not take effect until system reset occurs.</p>
<p>Returns the value of tag received for last ping frame.</p>
<p>Returns current value of ping watchdog counter.</p>
<p>Disables the ping watchdog counter logic.</p>
<p>Enables the ping watchdog counter logic and once the set time elapses it will indicate ping watchdog time-out has occurred.</p>
<p>Returns current value of frame watchdog counter.</p>
<p>Disables the frame watchdog counter logic.</p>
<p>Enables the frame watchdog counter logic to count every time it start to receive a frame.</p>
<p>Returns valid number of data words present in buffer which have not been read out yet.</p>
<p>Sets the value for receive buffer pointer at desired location.</p>
<p>Computes and returns CRC value for data received.</p>
<p>Returns CRC value received in data frame/frame.</p>
<p>Enables user to clear RX event/error flags.</p>
<p>Enables user to set RX event/error flags.</p>
<p>Returns current status of all the event/error flags.</p>
<p>Returns User-Data (8-bit) field for received data frame.</p>
<p>Returns Frame tag received for the last successful frame.</p>
<p>Disables the DMA event generation on completion of a successful frame reception.</p>
<p>Enables generation of DMA event on completion of a successful frame reception.</p>
<p>Gets frame type received in the last successful frame.</p>
<p>Disables SPI compatible mode in FSI Rx.</p>
<p>Enables SPI compatible mode in FSI Rx.</p>
<p>Selects number of data lines used for receiving.</p>
<p>Selects regular receive clock coming from the pins.</p>
<p>Receive clock is selected from the internal port coming from TX module.</p>
<p>Disables internal loopback where mux will not use internal pins coming from TX module.</p>
<p>Checks the FSI-Rx base address.</p>
<p>Returns address of Tx data buffer.</p>
<p>Enables user to disable generation interrupt on occurrence of FSI_TxEventList events.</p>
<p>Enables user to generate interrupt on occurrence of FSI_TxEventList events.</p>
<p>Returns ECC value evaluated for 16/32 bit data.</p>
<p>Sets data for ECC logic computaion.</p>
<p>Sets the CRC value to be picked transmission if transmission is configured to use user defined SW CRC.</p>
<p>Enables user to clear TX error flags.</p>
<p>Enables user to set TX error flags.</p>
<p>Returns current status of all the error flags.</p>
<p>Locks the control of all transmit control registers, once locked further writes will not take effect until system reset occurs.</p>
<p>Disable to generate DMA event on completion of a frame transfer.</p>
<p>Enables to generate DMA event on completion of a frame transfer.</p>
<p>Gives Current value of Ping Timeout Logic Counter.</p>
<p>Disables external trigger logic.</p>
<p>Enables external trigger to transmit a ping frame.</p>
<p>Disables ping timer logic.</p>
<p>Sets the ping tag value, used by either timeout counter initiated PING frame transfer or by external ping trigger input.</p>
<p>Enables ping timer logic and once set time elapses it sends signal to transmitter to send ping frame.</p>
<p>Returns valid number of data words present in buffer which have not been transmitted yet.</p>
<p>Returns current buffer pointer location.</p>
<p>Sets the value for transmit buffer pointer at desired location.</p>
<p>Sets user defined data for transmission It is an extra data field(8 bit) apart from regular data.</p>
<p>Sets frame tag for transmission.</p>
<p>Starts transmitting frames.</p>
<p>Sets the frame size if frame type is user/software defined frame.</p>
<p>Sets frame type for transmission.</p>
<p>Select between 16-bit and 32-bit ECC computation.</p>
<p>Disables forcing of CRC value of a data frame to zero.</p>
<p>Enables CRC value of a data frame to be forced to zero.</p>
<p>Sets a particular external input to trigger transmission.</p>
<p>Disables the Rx TDM mode.</p>
<p>Enables RX TDM as TDM source.</p>
<p>Disables the Tx TDM mode.</p>
<p>Enables the Tx TDM mode for multi-node configuration.</p>
<p>Setting for when Ping timeout can reset and restart.</p>
<p>Sets start mode for any frame transmission.</p>
<p>Disables SPI compatible mode.</p>
<p>Enables SPI compatible mode.</p>
<p>Sets data width for transmission.</p>
<p>Configures the prescalar clock keeping the transmit clock in reset.</p>
<p>Disables transmit clock.</p>
<p>Sets clock division prescalar and enables the transmit clock.</p>
<p>Selects PLL clock as source for clock dividers.</p>
<p>Configures the analog-to-digital converter module prescaler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">clkPrescale</td><td>is the ADC clock prescaler.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the ADC module's ADCCLK.</p>
<p>The <em>clkPrescale</em> parameter specifies the value by which the input clock is divided to make the ADCCLK. The clkPrescale value can be specified with any of the following enum values: <b>ADC_CLK_DIV_1_0</b>, <b>ADC_CLK_DIV_2_0</b>, <b>ADC_CLK_DIV_2_5</b>, ..., <b>ADC_CLK_DIV_7_5</b>, <b>ADC_CLK_DIV_8_0</b>, or <b>ADC_CLK_DIV_8_5</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures a start-of-conversion (SOC) in the ADC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">socNumber</td><td>is the number of the start-of-conversion. </td></tr>
    <tr><td class="paramname">trigger</td><td>the source that will cause the SOC. </td></tr>
    <tr><td class="paramname">channel</td><td>is the number associated with the input signal. </td></tr>
    <tr><td class="paramname">sampleWindow</td><td>is the acquisition window duration.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the a start-of-conversion (SOC) in the ADC module.</p>
<p>The <em>socNumber</em> number is a value <b>ADC_SOC_NUMBERX</b> where X is a number from 0 to 15 specifying which SOC is to be configured on the ADC module specified by <em>base</em>.</p>
<p>The <em>trigger</em> specifies the event that causes the SOC such as software, a timer interrupt, an ePWM event, or an ADC interrupt. It should be a value in the format of <b>ADC_TRIGGER_XXXX</b> where XXXX is the event such as <b>ADC_TRIGGER_SW_ONLY</b>, <b>ADC_TRIGGER_CPU1_TINT0</b>, <b>ADC_TRIGGER_GPIO</b>, <b>ADC_TRIGGER_EPWM1_SOCA</b>, and so on.</p>
<p>The <em>channel</em> parameter specifies the channel to be converted. In single-ended mode this is a single pin given by <b>ADC_CH_ADCINx</b> where x is the number identifying the pin between 0 and 31 inclusive. In differential mode, two pins are used as inputs and are passed in the <em>channel</em> parameter as <b>ADC_CH_ADCIN0_ADCIN1</b>, <b>ADC_CH_ADCIN2_ADCIN3</b>, ..., or <b>ADC_CH_ADCIN14_ADCIN15</b>.</p>
<p>The <em>sampleWindow</em> parameter is the acquisition window duration in SYSCLK cycles. It should be a value between 1 and 512 cycles inclusive. The selected duration must be at least as long as one ADCCLK cycle. Also, the datasheet will specify a minimum window duration requirement in nanoseconds.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable internal VREFLO connection.</p>
<p>This function disables the internal connection of VREFLO for the ADC.</p>
<dl class="section note"><dt>Note</dt><dd>This function disables the internal connections for VREFLO which is available through CMPSS module. To confiugre the internal connection for VREFLO, please refer <a class="el" href="group__adc__api.html#ga82811db076d3d59caa26e85fe3f9e4a9">ADC_setupSOCRefloChannel()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the external channel mux for an ADC SOC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">socNumber</td><td>is the number of the start-of-conversion. </td></tr>
    <tr><td class="paramname">extChannel</td><td>is the desired external channel.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the external channel for an SOC by configuring the external channel mux for an SOC.</p>
<p>The <em>socNumber</em> number is a value <b>ADC_SOC_NUMBERX</b> where X is a number from 0 to 15 specifying which SOC is to be configured on the ADC module specified by <em>base</em>.</p>
<p>The <em>extChannel</em> is the desired external channel. Valid values can be refered from the enum <em>ADC_ExtChannel</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Forces software trigger to ADC trigger repeater block</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">repInstance</td><td>is the repeater instance to be triggered.</td></tr>
  </table>
  </dd>
</dl>
<p>This function forces the selected ADC repeater block.</p>
<p>Valid values for <em>repInstance</em> parameter can be any of the individual ADC_REPEATER_INSTANCEx values defined by enum <em>ADC_RepInstance</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the current status for repeater block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">repInstance</td><td>is the repeater instance</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current status for the repeater block.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current event status, enumerated as a bit field of <b>ADC_REPEATER_MODULE_BUSY</b>, <b>ADC_REPEATER_PHASE_OVERFLOW</b>, and <b>ADC_REPEATER_TRIGGER_OVERFLOW</b>.</dd></dl>
<p>Configures the interrupt SOC trigger of an SOC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">socNumber</td><td>is the number of the start-of-conversion. </td></tr>
    <tr><td class="paramname">trigger</td><td>the interrupt source that will cause the SOC.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the interrupt start-of-conversion trigger in the ADC module.</p>
<p>The <em>socNumber</em> number is a value <b>ADC_SOC_NUMBERX</b> where X is a number from 0 to 15 specifying which SOC is to be configured on the ADC module specified by <em>base</em>.</p>
<p>The <em>trigger</em> specifies the interrupt that causes a start of conversion or none. It should be one of the following values.</p>
<ul>
<li><b>ADC_INT_SOC_TRIGGER_NONE</b> </li>
<li><b>ADC_INT_SOC_TRIGGER_ADCINT1</b> </li>
<li><b>ADC_INT_SOC_TRIGGER_ADCINT2</b> </li>
</ul>
<p>This functionality is useful for creating continuous conversions.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the timing of the end-of-conversion pulse</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">pulseMode</td><td>is the generation mode of the EOC pulse.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the end-of-conversion (EOC) pulse generated by ADC. This pulse will be generated either at the end of the acquisition window plus a number of SYSCLK cycles configured by ADC_setInterruptCycleOffset() (pass <b>ADC_PULSE_END_OF_ACQ_WIN</b> into <em>pulseMode</em>) or at the end of the voltage conversion, one cycle prior to the ADC result latching into it's result register (pass <b>ADC_PULSE_END_OF_CONV</b> into <em>pulseMode</em>).</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the timing of early interrupt generation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">cycleOffset</td><td>is the cycles from an SOC falling edge to an early interrupt pulse.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures cycle offset between the negative edge of a sample pulse and an early interrupt pulse being generated. This number of cycles is specified with the <em>cycleOffset</em> parameter.</p>
<p>This function only applies when early interrupt generation is enabled. That means the ADC_setInterruptPulseMode() function <em>pulseMode</em> parameter is configured as <b>ADC_PULSE_END_OF_ACQ_WIN</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables alternate timings for DMA trigger</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the alternate timings(tDMA) for DMA trigger. When enabled the DMA is always triggered at tDMA regardless of whether the ADC is in early interrupt mode or late interrupt mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables alternate timings for DMA trigger</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the alternate timings(tDMA) for DMA trigger. When disabled the DMA is triggered at the same time as the CPU interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables external channel mux preselection</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the preselection of external mux pins which is at the end of the S+H window of the previous conversion. This preselection allows some of the external mux settling time to be pipelined with previous conversion's conversion time and can be enabled if ADC SOC sequence is deterministic.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables external mux preselection</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the preselection of external mux pins as in ADCEXTMUX pins can only change at the beginning of S+H window of current conversion.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Selects the offset trim mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">mode</td><td>is the offset trim mode to be selected.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the offset trim mode for an ADC instance. This means that the offset trim to be used for an ADC mode would be specified by the <em>mode</em> parameter. Valid values for <em>mode</em> parameter are:</p><ul>
<li><em>ADC_OFFSET_TRIM_COMMON</em> - Offset trim will always be supplied from ADCOFFTRIM.OFFTRIM register field (Legacy mode)</li>
<li><em>ADC_OFFSET_TRIM_INDIVIDUAL</em> - offset trim will be supplied from individual registers based on the combination of resolution, signalmode, and capacitor bank related configurations.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the result ready status for ADC interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">adcIntNum</td><td>is interrupt number within the ADC wrapper.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the result ready status associated with the selected interrupt number within the ADC wrapper.</p>
<p><em>adcIntNum</em> takes a one of the values <b>ADC_INT_NUMBER1</b>, <b>ADC_INT_NUMBER2</b>, <b>ADC_INT_NUMBER3</b> or <b>ADC_INT_NUMBER4</b> to get the result ready status for the conversions associated with the given interrupt number.</p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the result is available for the selected interrupt and <b>false</b> if it is not.</dd></dl>
<p>Powers up the analog-to-digital converter core.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function powers up the analog circuitry inside the analog core.</p>
<dl class="section note"><dt>Note</dt><dd>Allow at least a 500us delay before sampling after calling this API. If you enable multiple ADCs, you can delay after they all have begun powering up.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Powers down the analog-to-digital converter module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function powers down the analog circuitry inside the analog core.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Forces a SOC flag to a 1 in the analog-to-digital converter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">socNumber</td><td>is the number of the start-of-conversion.</td></tr>
  </table>
  </dd>
</dl>
<p>This function forces the SOC flag associated with the SOC specified by <em>socNumber</em>. This initiates a conversion once that SOC is given priority. This software trigger can be used whether or not the SOC has been configured to accept some other specific trigger.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Forces multiple SOC flags to 1 in the analog-to-digital converter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">socMask</td><td>is the SOCs to be forced through software</td></tr>
  </table>
  </dd>
</dl>
<p>This function forces the SOCFRC1 flags associated with the SOCs specified by <em>socMask</em>. This initiates a conversion once the desired SOCs are given priority. This software trigger can be used whether or not the SOC has been configured to accept some other specific trigger. Valid values for <em>socMask</em> parameter can be any of the individual ADC_FORCE_SOCx values or any of their OR'd combination to trigger multiple SOCs.</p>
<dl class="section note"><dt>Note</dt><dd>To trigger SOC0, SOC1 and SOC2, value (ADC_FORCE_SOC0 | ADC_FORCE_SOC1 | ADC_FORCE_SOC2) should be passed as socMask.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the current ADC interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">adcIntNum</td><td>is interrupt number within the ADC wrapper.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the interrupt status for the analog-to-digital converter.</p>
<p><em>adcIntNum</em> takes a one of the values <b>ADC_INT_NUMBER1</b>, <b>ADC_INT_NUMBER2</b>, <b>ADC_INT_NUMBER3</b> or <b>ADC_INT_NUMBER4</b> to get the interrupt status for the given interrupt number of the ADC module.</p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the interrupt flag for the specified interrupt number is set and <b>false</b> if it is not.</dd></dl>
<p>Clears ADC interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">adcIntNum</td><td>is interrupt number within the ADC wrapper.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the specified ADC interrupt sources so that they no longer assert. If not in continuous mode, this function must be called before any further interrupt pulses may occur.</p>
<p><em>adcIntNum</em> takes a one of the values <b>ADC_INT_NUMBER1</b>, <b>ADC_INT_NUMBER2</b>, <b>ADC_INT_NUMBER3</b> or <b>ADC_INT_NUMBER4</b> to express which of the four interrupts of the ADC module should be cleared.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the current ADC interrupt overflow status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">adcIntNum</td><td>is interrupt number within the ADC wrapper.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the interrupt overflow status for the analog-to-digital converter. An overflow condition is generated irrespective of the continuous mode.</p>
<p><em>adcIntNum</em> takes a one of the values <b>ADC_INT_NUMBER1</b>, <b>ADC_INT_NUMBER2</b>, <b>ADC_INT_NUMBER3</b> or <b>ADC_INT_NUMBER4</b> to get the interrupt overflow status for the given interrupt number.</p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the interrupt overflow flag for the specified interrupt number is set and <b>false</b> if it is not.</dd></dl>
<p>Clears ADC interrupt overflow sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">adcIntNum</td><td>is interrupt number within the ADC wrapper.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the specified ADC interrupt overflow sources so that they no longer assert. If software tries to clear the overflow in the same cycle that hardware tries to set the overflow, then hardware has priority.</p>
<p><em>adcIntNum</em> takes a one of the values <b>ADC_INT_NUMBER1</b>, <b>ADC_INT_NUMBER2</b>, <b>ADC_INT_NUMBER3</b> or <b>ADC_INT_NUMBER4</b> to express which of the four interrupt overflow status of the ADC module should be cleared.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Reads the conversion result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resultBase</td><td>is the base address of the ADC results. </td></tr>
    <tr><td class="paramname">socNumber</td><td>is the number of the start-of-conversion.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the conversion result that corresponds to the base address passed into <em>resultBase</em> and the SOC passed into <em>socNumber</em>.</p>
<p>The <em>socNumber</em> number is a value <b>ADC_SOC_NUMBERX</b> where X is a number from 0 to 15 specifying which SOC's result is to be read.</p>
<dl class="section note"><dt>Note</dt><dd>Take care that you are using a base address for the result registers (ADCxRESULT_BASE) and not a base address for the control registers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the conversion result.</dd></dl>
<p>Determines whether the ADC is busy or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the caller to determine whether or not the ADC is busy and can sample another channel.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the ADC is sampling or <b>false</b> if all samples are complete.</dd></dl>
<p>Set SOC burst mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC. </td></tr>
    <tr><td class="paramname">trigger</td><td>the source that will cause the burst conversion sequence. </td></tr>
    <tr><td class="paramname">burstSize</td><td>is the number of SOCs converted during a burst sequence.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the burst trigger and burstSize of an ADC module. Burst mode allows a single trigger to walk through the round-robin SOCs one or more at a time. When burst mode is enabled, the trigger selected by the ADC_setupSOC() API will no longer have an effect on the SOCs in round-robin mode. Instead, the source specified through the <em>trigger</em> parameter will cause a burst of <em>burstSize</em> conversions to occur.</p>
<p>The <em>trigger</em> parameter takes the same values as the ADC_setupSOC() API The <em>burstSize</em> parameter should be a value between 1 and 16 inclusive.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables SOC burst mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables SOC burst mode operation of the ADC. Burst mode allows a single trigger to walk through the round-robin SOCs one or more at a time. When burst mode is enabled, the trigger selected by the ADC_setupSOC() API will no longer have an effect on the SOCs in round-robin mode. Use ADC_setBurstMode() to configure the burst trigger and size.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables SOC burst mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables SOC burst mode operation of the ADC. SOCs in round-robin mode will be triggered by the trigger configured using the ADC_setupSOC() API.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the priority mode of the SOCs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC. </td></tr>
    <tr><td class="paramname">priMode</td><td>is the priority mode of the SOCs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the priority mode of the SOCs. There are three main modes that can be passed in the <em>priMode</em> parameter</p>
<ul>
<li>All SOCs are in round-robin mode. This means no SOC has an inherent higher priority over another. This is selected by passing in the value <b>ADC_PRI_ALL_ROUND_ROBIN</b>.</li>
<li>All priorities are in high priority mode. This means that the priority of the SOC is determined by its SOC number. This option is selected by passing in the value <b>ADC_PRI_ALL_HIPRI</b>.</li>
<li>A range of SOCs are assigned high priority, with all others in round robin mode. High priority mode means that an SOC with high priority will interrupt the round robin wheel and insert itself as the next conversion. Passing in the value <b>ADC_PRI_SOC0_HIPRI</b> will make SOC0 highest priority, <b>ADC_PRI_THRU_SOC1_HIPRI</b> will put SOC0 and SOC 1 in high priority, and so on up to <b>ADC_PRI_THRU_SOC14_HIPRI</b> where SOCs 0 through 14 are in high priority.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures Open/Shorts Detection Circuit Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC. </td></tr>
    <tr><td class="paramname">modeVal</td><td>is the desired open/shorts detection circuit mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the open/shorts detection circuit mode of the ADC.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures a post-processing block (PPB) in the ADC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block. </td></tr>
    <tr><td class="paramname">socNumber</td><td>is the number of the start-of-conversion.</td></tr>
  </table>
  </dd>
</dl>
<p>This function associates a post-processing block with a SOC.</p>
<p>The <em>ppbNumber</em> is a value <b>ADC_PPB_NUMBERX</b> where X is a value from 1 to 4 inclusive that identifies a PPB to be configured. The <em>socNumber</em> number is a value <b>ADC_SOC_NUMBERX</b> where X is a number from 0 to 15 specifying which SOC is to be configured on the ADC module specified by <em>base</em>.</p>
<dl class="section note"><dt>Note</dt><dd>You can have more that one PPB associated with the same SOC, but a PPB can only be configured to correspond to one SOC at a time. Also note that when you have multiple PPBs for the same SOC, the calibration offset that actually gets applied will be that of the PPB with the highest number. Since SOC0 is the default for all PPBs, look out for unintentional overwriting of a lower numbered PPB's offset.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables individual ADC PPB event sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block. </td></tr>
    <tr><td class="paramname">evtFlags</td><td>is a bit mask of the event sources to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated ADC PPB event sources. This will allow the specified events to propagate through the X-BAR to a pin or to an ePWM module. The <em>evtFlags</em> parameter can be any of the <b>ADC_EVT_TRIPHI</b>, <b>ADC_EVT_TRIPLO</b>, or <b>ADC_EVT_ZERO</b> values.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables individual ADC PPB event sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block. </td></tr>
    <tr><td class="paramname">evtFlags</td><td>is a bit mask of the event sources to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated ADC PPB event sources. This will stop the specified events from propagating through the X-BAR to other modules. The <em>evtFlags</em> parameter can be any of the <b>ADC_EVT_TRIPHI</b>, <b>ADC_EVT_TRIPLO</b>, or <b>ADC_EVT_ZERO</b> values.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables individual ADC PPB event interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is a bit mask of the interrupt sources to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated ADC PPB interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt. Disabled sources have no effect on the processor. The <em>intFlags</em> parameter can be any of the <b>ADC_EVT_TRIPHI</b>, <b>ADC_EVT_TRIPLO</b>, or <b>ADC_EVT_ZERO</b> values.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables individual ADC PPB event interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is a bit mask of the interrupt source to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated ADC PPB interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt. Disabled sources have no effect on the processor. The <em>intFlags</em> parameter can be any of the <b>ADC_EVT_TRIPHI</b>, <b>ADC_EVT_TRIPLO</b>, or <b>ADC_EVT_ZERO</b> values.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the current ADC event status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the event status for the analog-to-digital converter.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current event status, enumerated as a bit field of <b>ADC_EVT_TRIPHI</b>, <b>ADC_EVT_TRIPLO</b>, and <b>ADC_EVT_ZERO</b>.</dd></dl>
<p>Clears ADC event flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block. </td></tr>
    <tr><td class="paramname">evtFlags</td><td>is a bit mask of the event source to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the indicated ADC PPB event flags. After an event occurs this function must be called to allow additional events to be produced. The <em>evtFlags</em> parameter can be any of the <b>ADC_EVT_TRIPHI</b>, <b>ADC_EVT_TRIPLO</b>, or <b>ADC_EVT_ZERO</b> values.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables cycle-by-cycle clear of ADC PPB event flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the automatic cycle-by-cycle clear of ADC PPB event flags. When enabled, the desired PPB event flags are automatically cleared on the next PPBxRESULT load, unless a set condition is also occurring at the same time, in which case the set takes precedence.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables cycle-by-cycle clear of ADC PPB event flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the cycle-by-cycle clear of ADC PPB event flags. When disabled, the desired PPB event flags are to be cleared explicitly in software inorder to generate next set of interrupts/events.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures PPB count limit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block. </td></tr>
    <tr><td class="paramname">limit</td><td>is the desired PPB count limit.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the PPB oversampling count limit which defines the number of ADC conversions to accumulate before partial sum is automatically loaded to the sum registes.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Returns the PPB count limit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the PPB oversampling count limit which defines the number of ADC conversions to accumulate before partial sum is automatically loaded to the sum registes.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the PPB count limit.</dd></dl>
<p>Reads the oversampled partial count from the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the oversampled partial count that corresponds to the base address passed into <em>base</em> and the PPB passed into <em>ppbNumber</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the oversampled partial count value.</dd></dl>
<p>Reads the oversampled partial sum from the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the oversampled partial sum of PPB results that corresponds to the base address passed into <em>base</em> and the PPB passed into <em>ppbNumber</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the oversampled partial sum value.</dd></dl>
<p>Reads the processed conversion result's partial maximum value from the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the oversampled partial maximum that corresponds to the base address passed into <em>base</em> and the PPB passed into <em>ppbNumber</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the oversampled partial maximum value.</dd></dl>
<p>Reads the processed conversion result's partial minimum value from the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the oversampled partial minimum that corresponds to the base address passed into <em>base</em> and the PPB passed into <em>ppbNumber</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the oversampled partial minimum value.</dd></dl>
<p>Reads the index of the result with partial maximum value from the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the index of the oversampled partial maximum value that corresponds to the base address passed into <em>base</em> and the PPB passed into <em>ppbNumber</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the index of the oversampled partial maximum value.</dd></dl>
<p>Reads the index of the result with partial minimum value from the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the index of the oversampled partial minimum value that corresponds to the base address passed into <em>base</em> and the PPB passed into <em>ppbNumber</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the index of the oversampled partial minimum value.</dd></dl>
<p>Enables absolute value capability in the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the absolute value functionality in the post- processing block specified by the <em>ppbNumber</em> parameter. When enabled, absolute value calculation would be done on the ADC Result associated with the selected SOC. In other words, the PPB result will calculated as shown below: (ADCPPBxRESULT = abs(ADCRESULTx - ADCPPBxOFFREF))</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Disables absolute value capability in the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the absolute value functionality in the post- processing block specified by the <em>ppbNumber</em> parameter. When disabled, absolute value calculation would be done on the ADC Result associated with the selected SOC. In other words, the PPB result will calculated as shown below: (ADCPPBxRESULT = ADCRESULTx - ADCPPBxOFFREF)</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Configures PPB shift value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block. </td></tr>
    <tr><td class="paramname">shiftVal</td><td>is the number of bits to right shift PSUM before loading to final PPB SUM.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configured the shift value required to right shift the PPB PSUM before loading into the final PPB SUM.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Configures PPB sync input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block. </td></tr>
    <tr><td class="paramname">syncInput</td><td>is the desired sync event to transfer partial registers to final registers and reset the partial registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures desired sync event to transfer partial registers to final registers and reset the partial registers. For valid values of <em>syncInput</em> refer to enum <em>ADC_SyncInput</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Forces PPB software sync.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function forces the software sync for the desired PPB.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Configures PPB interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block. </td></tr>
    <tr><td class="paramname">osIntSrc</td><td>selects PPB interrupt source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets which oversampling event is the source of a PPB intterupt.</p>
<p>For valid values of <em>osIntSrc</em> refer to enum <em>ADC_PPBIntSrcSelect</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Configures PPB compare source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block. </td></tr>
    <tr><td class="paramname">compSrc</td><td>is the desired source to be used for zero crossing detect logic and threshold compare.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the desired source to be used for zero crossing detect logic and threshold compare. For valid values of <em>compSrc</em> refer to enum <em>ADC_PPBCompSource</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Reads the oversampled final sum from the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resultBase</td><td>is the base address of the ADC results. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the processed sum of results that corresponds to the base address passed into <em>resultBase</em> and the PPB passed into <em>ppbNumber</em>.</p>
<dl class="section note"><dt>Note</dt><dd>Take care that you are using a base address for the result registers (ADCxRESULT_BASE) and not a base address for the control registers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the oversampled final sum value.</dd></dl>
<p>Reads the oversampled final count from the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resultBase</td><td>is the base address of the ADC results. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the oversampled final count that corresponds to the base address passed into <em>resultBase</em> and the PPB passed into <em>ppbNumber</em>.</p>
<dl class="section note"><dt>Note</dt><dd>Take care that you are using a base address for the result registers (ADCxRESULT_BASE) and not a base address for the control registers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the oversampled final count value.</dd></dl>
<p>Reads the processed conversion result's maximum value from the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resultBase</td><td>is the base address of the ADC results. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the oversampled final maximum that corresponds to the base address passed into <em>resultBase</em> and the PPB passed into <em>ppbNumber</em>.</p>
<dl class="section note"><dt>Note</dt><dd>Take care that you are using a base address for the result registers (ADCxRESULT_BASE) and not a base address for the control registers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the oversampled final maximum value.</dd></dl>
<p>Reads the processed conversion result's minimum value from the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resultBase</td><td>is the base address of the ADC results. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the processed conversion result that corresponds to the base address passed into <em>resultBase</em> and the PPB passed into <em>ppbNumber</em>.</p>
<dl class="section note"><dt>Note</dt><dd>Take care that you are using a base address for the result registers (ADCxRESULT_BASE) and not a base address for the control registers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the signed 32-bit conversion result.</dd></dl>
<p>Reads the index of the result with maximum value from the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resultBase</td><td>is the base address of the ADC results. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the index of the processed conversion's maximum value that corresponds to the base address passed into <em>resultBase</em> and the PPB passed into <em>ppbNumber</em>.</p>
<dl class="section note"><dt>Note</dt><dd>Take care that you are using a base address for the result registers (ADCxRESULT_BASE) and not a base address for the control registers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index of the result with maximum value.</dd></dl>
<p>Reads the index of the result with minimum value from the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resultBase</td><td>is the base address of the ADC results. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the index of the processed conversion's minimum value that corresponds to the base address passed into <em>resultBase</em> and the PPB passed into <em>ppbNumber</em>.</p>
<dl class="section note"><dt>Note</dt><dd>Take care that you are using a base address for the result registers (ADCxRESULT_BASE) and not a base address for the control registers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index of the result with final minimum value.</dd></dl>
<p>Reads the processed conversion result from the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resultBase</td><td>is the base address of the ADC results. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the processed conversion result that corresponds to the base address passed into <em>resultBase</em> and the PPB passed into <em>ppbNumber</em>.</p>
<dl class="section note"><dt>Note</dt><dd>Take care that you are using a base address for the result registers (ADCxRESULT_BASE) and not a base address for the control registers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the signed 32-bit conversion result.</dd></dl>
<p>Reads sample delay time stamp from a PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the sample delay time stamp. This delay is the number of system clock cycles between the SOC being triggered and when it began converting.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the delay time stamp.</dd></dl>
<p>Sets the post processing block offset correction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block. </td></tr>
    <tr><td class="paramname">offset</td><td>is the 10-bit signed value subtracted from ADC the output.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the PPB offset correction value. This value can be used to digitally remove any system-level offset inherent in the ADCIN circuit before it is stored in the appropriate result register. The <em>offset</em> parameter is <b>subtracted</b> from the ADC output and is a signed value from -512 to 511 inclusive. For example, when <em>offset</em> = 1, ADCRESULT = ADC output - 1. When <em>offset</em> = -512, ADCRESULT = ADC output - (-512) or ADC output + 512.</p>
<p>Passing a zero in to the <em>offset</em> parameter will effectively disable the calculation, allowing the raw ADC result to be passed unchanged into the result register.</p>
<dl class="section note"><dt>Note</dt><dd>If multiple PPBs are applied to the same SOC, the offset that will be applied will be that of the PPB with the highest number.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Sets the post processing block reference offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block. </td></tr>
    <tr><td class="paramname">offset</td><td>is the 16-bit unsigned value subtracted from ADC the output.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the PPB reference offset value. This can be used to either calculate the feedback error or convert a unipolar signal to bipolar by subtracting a reference value. The result will be stored in the appropriate PPB result register which can be read using ADC_readPPBResult().</p>
<p>Passing a zero in to the <em>offset</em> parameter will effectively disable the calculation and will pass the ADC result to the PPB result register unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>If in 12-bit mode, you may only pass a 12-bit value into the <em>offset</em> parameter.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Enables two's complement capability in the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables two's complement in the post-processing block specified by the <em>ppbNumber</em> parameter. When enabled, a two's complement will be performed on the output of the offset subtraction before it is stored in the appropriate PPB result register. In other words, the PPB result will be the reference offset value minus the the ADC result value (ADCPPBxRESULT = ADCSOCxOFFREF - ADCRESULTx).</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Disables two's complement capability in the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables two's complement in the post-processing block specified by the <em>ppbNumber</em> parameter. When disabled, a two's complement will <b>NOT</b> be performed on the output of the offset subtraction before it is stored in the appropriate PPB result register. In other words, the PPB result will be the ADC result value minus the reference offset value (ADCPPBxRESULT = ADCRESULTx - ADCSOCxOFFREF).</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Enables the extended low limit in the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the low limit for PPB by allowing the PPB low limit to be set by ADCPPBxTRIPLO2 register.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Disables extended low limit capability in the PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the low limit for PPB by allowing the PPB low limit to be set by ADCPPBxTRIPLO register.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Enables an ADC interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">adcIntNum</td><td>is interrupt number within the ADC wrapper.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated ADC interrupt source. Only the sources that are enabled can be reflected to the processor interrupt. Disabled sources have no effect on the processor.</p>
<p><em>adcIntNum</em> can take the value <b>ADC_INT_NUMBER1</b>, <b>ADC_INT_NUMBER2</b>, <b>ADC_INT_NUMBER3</b> or <b>ADC_INT_NUMBER4</b> to express which of the four interrupts of the ADC module should be enabled.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables an ADC interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">adcIntNum</td><td>is interrupt number within the ADC wrapper.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated ADC interrupt source. Only the sources that are enabled can be reflected to the processor interrupt. Disabled sources have no effect on the processor.</p>
<p><em>adcIntNum</em> can take the value <b>ADC_INT_NUMBER1</b>, <b>ADC_INT_NUMBER2</b>, <b>ADC_INT_NUMBER3</b> or <b>ADC_INT_NUMBER4</b> to express which of the four interrupts of the ADC module should be disabled.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the source EOC for an analog-to-digital converter interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">adcIntNum</td><td>is interrupt number within the ADC wrapper. </td></tr>
    <tr><td class="paramname">socNumber</td><td>is the number of the start-of-conversion.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets which conversion is the source of an ADC interrupt.</p>
<p>The <em>intTrigger</em> number is a value <b>ADC_INT_TRIGGER_X</b> where X specifies the interrupt trigger to be configured for the ADC module specified by <em>base</em>. Refer <b>ADC_IntTrigger</b> enum for valid values for this input.</p>
<p><em>adcIntNum</em> can take the value <b>ADC_INT_NUMBER1</b>, <b>ADC_INT_NUMBER2</b>, <b>ADC_INT_NUMBER3</b> or <b>ADC_INT_NUMBER4</b> to express which of the four interrupts of the ADC module is being configured.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables continuous mode for an ADC interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC. </td></tr>
    <tr><td class="paramname">adcIntNum</td><td>is interrupt number within the ADC wrapper.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables continuous mode for the ADC interrupt passed into <em>adcIntNum</em>. This means that pulses will be generated for the specified ADC interrupt whenever an EOC pulse is generated irrespective of whether or not the flag bit is set.</p>
<p><em>adcIntNum</em> can take the value <b>ADC_INT_NUMBER1</b>, <b>ADC_INT_NUMBER2</b>, <b>ADC_INT_NUMBER3</b> or <b>ADC_INT_NUMBER4</b> to express which of the four interrupts of the ADC module is being configured.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables continuous mode for an ADC interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC. </td></tr>
    <tr><td class="paramname">adcIntNum</td><td>is interrupt number within the ADC wrapper.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables continuous mode for the ADC interrupt passed into <em>adcIntNum</em>. This means that pulses will not be generated for the specified ADC interrupt until the corresponding interrupt flag for the previous interrupt occurrence has been cleared using ADC_clearInterruptStatus().</p>
<p><em>adcIntNum</em> can take the value <b>ADC_INT_NUMBER1</b>, <b>ADC_INT_NUMBER2</b>, <b>ADC_INT_NUMBER3</b> or <b>ADC_INT_NUMBER4</b> to express which of the four interrupts of the ADC module is being configured.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Converts temperature from sensor reading to degrees C</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tempResult</td><td>is the raw ADC A conversion result from the temp sensor. </td></tr>
    <tr><td class="paramname">vref</td><td>is the reference voltage being used (for example 3.3 for 3.3V). </td></tr>
    <tr><td class="paramname">refMode</td><td>is the reference mode being used (<b>ADC_REFERENCE_INTERNAL</b> or <b>ADC_REFERENCE_EXTERNAL</b>).</td></tr>
  </table>
  </dd>
</dl>
<p>This function converts temperature from temp sensor reading to degrees C. Temp sensor values in production test are derived with 2.5V reference. The <b>vref</b> argument in the function is used to scale the temp sensor reading accordingly if temp sensor value is read at a different VREF setting.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the temperature sensor reading converted to degrees C.</dd></dl>
<p>Converts temperature from sensor reading to degrees K</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tempResult</td><td>is the raw ADC A conversion result from the temp sensor. </td></tr>
    <tr><td class="paramname">vref</td><td>is the reference voltage being used (for example 3.3 for 3.3V). </td></tr>
    <tr><td class="paramname">refMode</td><td>is the reference mode being used (<b>ADC_REFERENCE_INTERNAL</b> or <b>ADC_REFERENCE_EXTERNAL</b>).</td></tr>
  </table>
  </dd>
</dl>
<p>This function converts temperature from temp sensor reading to degrees K. Temp sensor values in production test are derived with 2.5V reference. The <b>vref</b> argument in the function is used to scale the temp sensor reading accordingly if temp sensor value is read at a different VREF setting.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the temperature sensor reading converted to degrees K.</dd></dl>
<p>Configures the safety checker result for a selected SOC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">socNumber</td><td>is the number of the start-of-conversion. </td></tr>
    <tr><td class="paramname">scInput</td><td>is the desired input configuration.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the safety checker input for the desired SOC.</p>
<p>The <em>socNumber</em> number is a value <b>ADC_SOC_NUMBERX</b> where X is a number from 0 to 15 specifying which SOC is to be configured on the ADC module specified by <em>base</em>.</p>
<p>The <em>scInput</em> is the desired safety checker input configuration. Valid values can be refered from the enum <em>ADC_SafetyCheckerInput</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables the ADC result safety checker module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scBase</td><td>is the base address of the ADC Safety Checker module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the ADC result safety checker module.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the ADC result safety checker module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scBase</td><td>is the base address of the ADC Safety Checker module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the ADC result safety checker module.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Forces the software sync for the safety checker module</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scBase</td><td>is the base address of the safety checker module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function forces the software sync for the safety checker module.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Returns the status of the safey checker module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scBase</td><td>is the base address of the ADC safety checker module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the external channel for an SOC by configuring the external channel mux for an SOC.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the safety checker module. Valid values are any of the follwing values or any of their OR'd combination:<ul>
<li><em>ADC_SAFECHECK_RESULT1_READY</em> </li>
<li><em>ADC_SAFECHECK_RESULT2_READY</em> </li>
<li><em>ADC_SAFECHECK_RESULT1_OOT</em> </li>
</ul>
</dd></dl>
<p>Configures the safety checker module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scBase</td><td>is the base address of the ADC safety checker module. </td></tr>
    <tr><td class="paramname">scInst</td><td>is the safety checker instance to be configured. </td></tr>
    <tr><td class="paramname">adcInst</td><td>is the desired ADC instance. </td></tr>
    <tr><td class="paramname">adcResultInst</td><td>is the desired ADC result instance.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the selected checker instance of a safety checker instance.</p>
<p>The <em>checkInst</em> parameter can take values defined by enum <b>ADC_SafetyCheckInst</b>. The <em>adcInst</em> parameter can take values defined by enum <b>ADC_Select</b>. The <em>adcResultInst</em> parameter can take values defined by enum <b>ADC_ResultSelect</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the tolerance allowed between safety check results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scBase</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">tolerance</td><td>is the number of the start-of-conversion.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the tolerance for the difference between check result instances of the selected safety checker instance.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Returns the safety check result for the selected instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scBase</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">checkInst</td><td>is the number of the start-of-conversion.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the safety check result for the selected instance.</p>
<p>The <em>checkInst</em> number is a value <b>ADC_SAFETY_CHECKx</b> where x is a number from 1 to 2 specifying the safety result check instances available in the safety checker instance specified by <em>scBase</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the safety checker result for the desired instance.</dd></dl>
<p>Enables the safety checker event sources for selected instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scIntEvtBase</td><td>is the base address of ADC Safe Check INTEVT module. </td></tr>
    <tr><td class="paramname">checkResult</td><td>is the desired ADC Safety Checker result. </td></tr>
    <tr><td class="paramname">checkEvent</td><td>is the desired event number. </td></tr>
    <tr><td class="paramname">checkerNumber</td><td>is the number of the checker tile.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated safety checker event sources.</p>
<p>The <em>checkResult</em> specifies the result of the OOT or OVF events. It should be one of the following values.</p>
<ul>
<li><b>ADC_SAFETY_CHECK_RESULT1</b> </li>
<li><b>ADC_SAFETY_CHECK_RESULT2</b> </li>
<li><b>ADC_SAFETY_CHECK_OOT</b> </li>
</ul>
<p>The <em>checkEvent</em> is a value <b>ADC_SAFETY_CHECK_EVENTx</b> where x is a number from 1 to 4 specifying the safety check events available in the safety checker specified by <em>scIntEvtBase</em>.</p>
<p>The <em>checkerNumber</em> number is a value <b>ADC_SAFETY_CHECKERx</b> where x is a number from 1 to 8 specifying which Checker Tile is to be selected in the ADC module.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the safety checker event sources for selected instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scIntEvtBase</td><td>is the base address of ADC Safe Check INTEVT module. </td></tr>
    <tr><td class="paramname">checkResult</td><td>is the desired ADC Safety Checker result. </td></tr>
    <tr><td class="paramname">checkEvent</td><td>is the desired event number. </td></tr>
    <tr><td class="paramname">checkerNumber</td><td>is the number of the checker tile.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated safety checker event sources.</p>
<p>The <em>checkResult</em> specifies the result of the OOT or OVF events. It should be one of the following values.</p>
<ul>
<li><b>ADC_SAFETY_CHECK_RESULT1</b> </li>
<li><b>ADC_SAFETY_CHECK_RESULT2</b> </li>
<li><b>ADC_SAFETY_CHECK_OOT</b> </li>
</ul>
<p>The <em>checkEvent</em> is a value <b>ADC_SAFETY_CHECK_EVENTx</b> where x is a number from 1 to 4 specifying the safety check events available in the safety checker specified by <em>scIntEvtBase</em>.</p>
<p>The <em>checkerNumber</em> number is a value <b>ADC_CHECKER_NUMBERx</b> where x is a number from 1 to 8 specifying which Checker Tile is to be selected in the ADC module.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables the safety checker interrupt sources for selected instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scIntEvtBase</td><td>is the base address of ADC Safe Check INTEVT module. </td></tr>
    <tr><td class="paramname">checkResult</td><td>is the desired ADC Safety Checker interrupt result. </td></tr>
    <tr><td class="paramname">checkerNumber</td><td>is the number of the checker tile.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated safety checker interrupt sources.</p>
<p>The <em>checkResult</em> specifies the result of the OOT or OVF events. It should be one of the following values.</p>
<ul>
<li><b>ADC_SAFETY_CHECK_RESULT1</b> </li>
<li><b>ADC_SAFETY_CHECK_RESULT2</b> </li>
<li><b>ADC_SAFETY_CHECK_OOT</b> </li>
</ul>
<p>The <em>checkerNumber</em> number is a value <b>ADC_CHECKER_NUMBERx</b> where x is a number from 1 to 8 specifying which Checker Tile is to be selected in the ADC module.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the safety checker interrupt sources for selected instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scIntEvtBase</td><td>is the base address of ADC Safe Check INTEVT module. </td></tr>
    <tr><td class="paramname">checkResult</td><td>is the desired ADC Safety Checker interrupt result. </td></tr>
    <tr><td class="paramname">checkerNumber</td><td>is the number of the checker tile.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated safety checker interrupt sources.</p>
<p>The <em>checkResult</em> specifies the result of the OOT or OVF events. It should be one of the following values.</p>
<ul>
<li><b>ADC_SAFETY_CHECK_RESULT1</b> </li>
<li><b>ADC_SAFETY_CHECK_RESULT2</b> </li>
<li><b>ADC_SAFETY_CHECK_OOT</b> </li>
</ul>
<p>The <em>checkerNumber</em> number is a value <b>ADC_CHECKER_NUMBERx</b> where x is a number from 1 to 8 specifying which Checker Tile is to be selected in the ADC module.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get the ADC safety checker OOT and OVF event status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scIntEvtBase</td><td>is the base address of ADC Safe Check INTEVT module. </td></tr>
    <tr><td class="paramname">checkerFlag</td><td>is the desired ADC Safety Checker event status. </td></tr>
    <tr><td class="paramname">checkerNumber</td><td>is the number of the checker tile.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the event status for the OOT or OVF event.</p>
<p>The <em>checkerFlag</em> specifies the ADC safety checker event status of OOT or OVF events. It should be one of the following values.</p>
<ul>
<li><b>ADC_SAFETY_CHECK_OOT_FLG</b> </li>
<li><b>ADC_SAFETY_CHECK_RES1OVF_FLG</b> </li>
<li><b>ADC_SAFETY_CHECK_RES2OVF_FLG</b> </li>
</ul>
<p>The <em>checkerNumber</em> number is a value <b>ADC_SAFETY_CHECKERx</b> where x is a number from 1 to 8 specifying which Checker Tile is to be selected in the ADC module specified by <em>scIntEvtBase</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the safety checker event module for the selected instance.</dd></dl>
<p>Clears the ADC safety checker OOT and OVF event status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scIntEvtBase</td><td>is the base address of ADC Safe Check INTEVT module. </td></tr>
    <tr><td class="paramname">checkerFlag</td><td>is the desired ADC Safety Checker event status. </td></tr>
    <tr><td class="paramname">checkerNumber</td><td>is the number of the checker tile.</td></tr>
  </table>
  </dd>
</dl>
<p>This funtion clears the specified ADC Safety Checker event status so that they no longer assert.</p>
<p><em>checkerFlag</em> takes one of the values <b>ADC_SAFETY_CHECK_OOT_FLG</b>, <b>ADC_SAFETY_CHECK_RES1OVF_FLG</b> or <b>ADC_SAFETY_CHECK_RES2OVF_FLG</b> to express which of the three event status of the ADC Safety Checker should be cleared.</p>
<p>The <em>checkerNumber</em> number is a value <b>ADC_SAFETY_CHECKERx</b> where x is a number from 1 to 8 specifying which Checker Tile is to be selected in the ADC module specified by <em>scIntEvtBase</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get the ADC safety checker interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scIntEvtBase</td><td>is the base address of ADC Safe Check INTEVT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the interrupt status for the OOT or OVF event.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the safety checker interrupt for the selected instance.</dd></dl>
<p>Clears the ADC safety checker interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scIntEvtBase</td><td>is the base address of ADC Safe Check INTEVT module. </td></tr>
    <tr><td class="paramname">checkerNumber</td><td>is the number of the checker tile.</td></tr>
  </table>
  </dd>
</dl>
<p>This funtion clears the specified ADC Safety Checker interrupt status so that they no longer assert.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the trigger repeater mode select.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">repInstance</td><td>is the repeater instance. </td></tr>
    <tr><td class="paramname">mode</td><td>is the repeater mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures desired ADC trigger repeater mode that corresponds to <em>mode</em> to select either oversampling or undersampling mode.</p>
<p>The <em>repInstance</em> is the repeater instance to be configured. Valid values for this parameter can be referred from the enum <em>ADC_RepInstance</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get the trigger repeater active mode status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">repInstance</td><td>is the repeater instance.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the status of the ADC trigger repeater mode for the selected repeater instance.</p>
<p>The <em>repInstance</em> is the repeater instance to be configured. Valid values for this parameter can be referred from the enum <em>ADC_RepInstance</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the trigger repeater active mode.</dd></dl>
<p>Get the trigger repeater module busy indication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">repInstance</td><td>is the repeater instance.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the status of the ADC trigger repeater module for the selected repeater instance.</p>
<p>The <em>repInstance</em> is the repeater instance to be configured. Valid values for this parameter can be referred from the enum <em>ADC_RepInstance</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the staus of the trigger repeater module busy.</dd></dl>
<p>Configures the trigger source of the trigger repeater.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">repInstance</td><td>is the repeater instance. </td></tr>
    <tr><td class="paramname">trigger</td><td>the source to modify via oversampling or undersampling.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures ADC trigger repeater by selecting the trigger source passed into <em>trigger</em> to modify via oversampling or undersampling.</p>
<p>The <em>repInstance</em> is the repeater instance to be configured. Valid values for this parameter can be referred from the enum <em>ADC_RepInstance</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the trigger repeater syncin source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">repInstance</td><td>is the repeater instance. </td></tr>
    <tr><td class="paramname">syncInput</td><td>is the desired sync event to reset all counters.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures desired ADC trigger repeater sync event that corresponds to <em>syncInput</em> to reset all counters and any pending repeated triggers are discarded.</p>
<p>The <em>repInstance</em> is the repeater instance to be configured. Valid values for this parameter can be referred from the enum <em>ADC_RepInstance</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Forces software sync for the trigger repeater block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">repInstance</td><td>is the repeater instance.</td></tr>
  </table>
  </dd>
</dl>
<p>This function forces the software sync for the trigger repeater block.</p>
<p>The <em>repInstance</em> is the repeater instance to be configured. Valid values for this parameter can be referred from the enum <em>ADC_RepInstance</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the trigger repeater count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">repInstance</td><td>is the repeater instance. </td></tr>
    <tr><td class="paramname">repCount</td><td>is the desired trigger count to be selected.</td></tr>
  </table>
  </dd>
</dl>
<p>This function indicates the number of repeated triggers passed into <em>repCount</em> and remaining triggers to be generated/supressed. In oversampling mode, the <em>repCount</em> parameter is the number of desired repeated triggers to be generated. It should be a value between 0 to 127 where (repCount + 1) triggers will be generated. For example, when <em>repCount</em> = 2, 3 triggers will be generated on receiving corresponding REPxCTL.TRIGSEL. In unversampling mode, the <em>repCount</em> parameter is the number of desired triggers to be supressed. It should be a value between 0 to 127 where 1 out of (repCount + 1) triggers received will be passed through. For Example, when <em>repCount</em> = 2, 1 out of 3 triggers will be generated.</p>
<p>The <em>repInstance</em> is the repeater instance to be configured. Valid values for this parameter can be referred from the enum <em>ADC_RepInstance</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the trigger repeater phase.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">repInstance</td><td>is the repeater instance. </td></tr>
    <tr><td class="paramname">repPhase</td><td>indicates the repeater trigger phase delay in sysclk cycles.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the phase delay that corresponds to <em>repPhase</em> by defining the number of sysclk to delay the selected trigger. The <em>repPhase</em> parameter should be a value between 0 and 65535 inclusive. For example, passing a 2 to the <em>offset</em> parameter will delay the trigger by 2 sysclks and passing 0 will pass through the trigger without delay.</p>
<p>The <em>repInstance</em> is the repeater instance to be configured. Valid values for this parameter can be referred from the enum <em>ADC_RepInstance</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the trigger repeater spread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">repInstance</td><td>is the repeater instance. </td></tr>
    <tr><td class="paramname">repSpread</td><td>is the desired trigger spread in sysclk cycle.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the spread time by setting <em>repSpread</em> to number of sysclk desired between triggers. In oversampling mode, the <em>repSpread</em> parameter is the minimum number of sysclks to wait before creating the next repeated trigger to the ADC. It should be a value between 0 and 65535 inclusive. For example, passing a 2 to the <em>offset</em> parameter will create at least 2 sysclk time between repeated triggers.</p>
<p>The <em>repInstance</em> is the repeater instance to be configured. Valid values for this parameter can be referred from the enum <em>ADC_RepInstance</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clear global enable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the CLB via global enable register.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable HLC NMI.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the CLB HLC NMI.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable HLC NMI.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the CLB HLC NMI.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configure Clock Prescalar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables and configures the CLB Clock Precalar.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures Clock Precalar Strobe Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables and configures the CLB Clock Precalar Strobe Mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the general purpose SW release control value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">inID</td><td>is the specified CLB SW Release input signal. </td></tr>
    <tr><td class="paramname">val</td><td>is the value of the SW RLS control.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the general purpose SW release control value. The <em>inID</em> parameter can have one enumeration value from CLB_SWReleaseCtrl.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the general purpose SW gate control value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">inID</td><td>is the specified CLB SW Release input signal. </td></tr>
    <tr><td class="paramname">val</td><td>is the value of the SW GATE control.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the general purpose SW release control value. The <em>inID</em> parameter can have one enumeration value from CLB_SWGateCtrl.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures Counter TAP Selects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">miscCtrl</td><td>is the value to represent counter tap selects. Generated by tool as <b>TILEx_CFG_TAP_SELL</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the counter tap selects.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures AOC (Asynchronous Output Conditioning) functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">aocID</td><td>is the specified CLB tile AOC signal. </td></tr>
    <tr><td class="paramname">aocCfg</td><td>is the value for the AOC signal function and input signal selections. Generated by tool as <b>TILEx_OUTPUT_COND_CTR_n</b> where n is the output number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the input signals and equations of the aoc LUT corresponding to the /e aocID parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable CLB lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the lock bit of the lock register. The lock can only be set once and can only be cleared by a device reset.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Write value to address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">address</td><td>is the address of CLB internal memory. </td></tr>
    <tr><td class="paramname">value</td><td>is the value to write to specified address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes the specified value to CLB internal memory.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Select input filter type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">inID</td><td>is the specified CLB tile input signal. </td></tr>
    <tr><td class="paramname">filterType</td><td>is the selected type of filter applied to the input.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the filter selection for the specified input. The <em>inID</em> parameter can have one enumeration value from CLB_Inputs. The <em>filterType</em> parameter can have one enumeration value from CLB_FilterType.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables synchronization of an input signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">inID</td><td>is the specified CLB tile input signal.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables synchronization on the specified input signal. The <em>inID</em> parameter can have one enumeration value from CLB_Inputs.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables synchronization of an input signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">inID</td><td>is the specified CLB tile input signal.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables synchronization on the specified input signal. The <em>inID</em> parameter can have one enumeration value from CLB_Inputs.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the general purpose input mux.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">inID</td><td>is the specified CLB tile input signal. </td></tr>
    <tr><td class="paramname">gpMuxCfg</td><td>is the mux selection for the general purpose input mux.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the general purpose input mux. The <em>gpMuxCfg</em> parameter can select either the use of an external input signal (<b>CLB_GP_IN_MUX_EXTERNAL</b>) or the use of the corresponding CLB_GP_REG bit as an input (<b>CLB_GP_IN_MUX_GP_REG</b>). The <em>inID</em> parameter can have one enumeration value from CLB_Inputs.</p>
<dl class="section see"><dt>See also</dt><dd>CLB_setGPREG() to write to the CLB_GP_REG.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the CLB_GP_REG register value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">gpRegVal</td><td>is the value to be written to CLB_GP_REG.</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes to the CLB_GP_REG register. When the general purpose input mux is configured to use CLB_GP_REG, each bit in <em>gpRegVal</em> corresponds to an input signal (bit 0 to Input 0, bit 1 to Input 1, and so on).</p>
<dl class="section see"><dt>See also</dt><dd>CLB_configGPInputMux() to select the CLB_GP_REG as the <a class="el" href="group__xbar__api.html#ga1e2754bcfe037d89628bdaab31e07af7">source</a> for an <a class="el" href="group__xbar__api.html#ga5455244d8478f57a516772394df54ace">input</a> signal.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the CLB_GP_REG register value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes to the CLB_GP_REG register. When the general purpose input mux is configured to use CLB_GP_REG, each bit in <em>gpRegVal</em> corresponds to an input signal (bit 0 to Input 0, bit 1 to Input 1, and so on).</p>
<dl class="section see"><dt>See also</dt><dd>CLB_configGPInputMux() to select the CLB_GP_REG as the <a class="el" href="group__xbar__api.html#ga1e2754bcfe037d89628bdaab31e07af7">source</a> for an <a class="el" href="group__xbar__api.html#ga5455244d8478f57a516772394df54ace">input</a> signal.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>CLB_GP_REG value.</dd></dl>
<p>Configures the local input mux.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">inID</td><td>is the specified CLB tile input signal. </td></tr>
    <tr><td class="paramname">localMuxCfg</td><td>is the mux selection for the local input mux.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the local input mux for the specified input signal.</p>
<p>The <em>inID</em> parameter can have one enumeration value from CLB_Inputs. The <em>localMuxCfg</em> parameter can have one enumeration value from CLB_LocalInputMux.</p>
<dl class="section note"><dt>Note</dt><dd>The local input mux options' peripheral sources depend on which instance of the CLB (<em>base</em>) you are using. For example, for CLB1 the EPWM signal selections come from EPWM1 but for CLB2 they come from EPWM2. See your technical reference manual for details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the global input mux.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">inID</td><td>is the specified CLB tile input signal. </td></tr>
    <tr><td class="paramname">globalMuxCfg</td><td>is the mux selection for the global input mux.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the global input mux for the specified input signal. The <em>inID</em> parameter can have one enumeration value from CLB_Inputs. The <em>globalMuxCfg</em> parameter can have one enumeration value from CLB_GlobalInputMux.</p>
<dl class="section note"><dt>Note</dt><dd>The global input mux options' peripheral sources depend on which instance of the CLB (<em>base</em>) you are using. For example, for CLB1 the EPWM signal selections come from EPWM1 but for CLB2 they come from EPWM2. See your technical reference manual for details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Controls the output enable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">outputMask</td><td>is a mask of the outputs to be enabled. </td></tr>
    <tr><td class="paramname">enable</td><td>is a switch to decide if the CLB outputs need to be enabled or not.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to enable and disable CLB outputs by writing a mask to CLB_OUT_EN. Each bit corresponds to a CLB output. When a bit is 1, the corresponding output is enabled; when a bit is 0, the output is disabled.</p>
<p>The <em>outputMask</em> parameter takes a logical OR of any of the CLB_OUTPUT_0x values that correspond to the CLB OUTPUT ENABLE for the respective outputs. The <em>enable</em> parameter can have one of the values from: false: Disable the respective CLB outputs true: Enable the respective CLB outputs</p>
<dl class="section note"><dt>Note</dt><dd>Note that the 8 CLB outputs are replicated to create more output paths. See your technical reference manual for more details. If no further modifications are expected, then it is advised to set the block writes bit of the MISC_ACCESS_CTRL Register. This will prevent accidental writes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Reads the interrupt tag register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value in the interrupt tag register which is a 6-bit constant set by the HLC.</dd></dl>
<p>Clears the interrupt tag register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the interrupt tag register, setting it to 0.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Selects LUT4 inputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">lut4In0</td><td>is the value for LUT4 input signal 0. Generated by tool as <b>TILEx_CFG_LUT4_IN0</b>. </td></tr>
    <tr><td class="paramname">lut4In1</td><td>is the value for LUT4 input signal 1. Generated by tool as <b>TILEx_CFG_LUT4_IN1</b>. </td></tr>
    <tr><td class="paramname">lut4In2</td><td>is the value for LUT4 input signal 2. Generated by tool as <b>TILEx_CFG_LUT4_IN2</b>. </td></tr>
    <tr><td class="paramname">lut4In3</td><td>is the value for LUT4 input signal 3. Generated by tool as <b>TILEx_CFG_LUT4_IN3</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the LUT4 block's input signals.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures LUT4 functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">lut4Fn10</td><td>is the equation value for LUT4 blocks 0 and 1. Generated by tool as <b>TILEx_CFG_LUT4_FN10</b>. </td></tr>
    <tr><td class="paramname">lut4Fn2</td><td>is the equation value for LUT4 block2. Generated by tool as <b>TILEx_CFG_LUT4_FN2</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the LUT4 block's equations.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Selects FSM inputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">external0</td><td>is the value for FSM external 0 input. Generated by tool as <b>TILEx_CFG_FSM_EXT_IN0</b>. </td></tr>
    <tr><td class="paramname">external1</td><td>is the value for FSM external 1 input. Generated by tool as <b>TILEx_CFG_FSM_EXT_IN1</b>. </td></tr>
    <tr><td class="paramname">extra0</td><td>is the value for FSM extra 0 input. Generated by tool as <b>TILEx_CFG_FSM_EXTRA_IN0</b>. </td></tr>
    <tr><td class="paramname">extra1</td><td>is the value for FSM extra 1 input. Generated by tool as <b>TILEx_CFG_FSM_EXTRA_IN1</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the FSM block's external inputs and extra external inputs.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures FSM LUT function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">fsmLutFn10</td><td>is the value for FSM 0 &amp; FSM 1 LUT function. Generated by tool as <b>TILEx_CFG_FSM_LUT_FN10</b>. </td></tr>
    <tr><td class="paramname">fsmLutFn2</td><td>is the value for FSM 2 LUT function. Generated by tool as <b>TILEx_CFG_FSM_LUT_FN2</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the FSM block's LUT equations.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures FSM next state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">nextState0</td><td>is the value for FSM 0's next state. Generated by tool as <b>TILEx_CFG_FSM_NEXT_STATE_0</b>. </td></tr>
    <tr><td class="paramname">nextState1</td><td>is the value for FSM 1's next state. Generated by tool as <b>TILEx_CFG_FSM_NEXT_STATE_1</b>. </td></tr>
    <tr><td class="paramname">nextState2</td><td>is the value for FSM 2's next state. Generated by tool as <b>TILEx_CFG_FSM_NEXT_STATE_2</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the FSM's next state equation.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Selects Counter inputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">reset</td><td>is the value for counter's reset inputs. Generated by tool as <b>TILEx_CFG_COUNTER_RESET</b>. </td></tr>
    <tr><td class="paramname">event</td><td>is the value for counter's event inputs. Generated by tool as <b>TILEx_CFG_COUNTER_EVENT</b>. </td></tr>
    <tr><td class="paramname">mode0</td><td>is the value for counter's mode 0 inputs. Generated by tool as <b>TILEx_CFG_COUNTER_MODE_0</b>. </td></tr>
    <tr><td class="paramname">mode1</td><td>is the value for counter's mode 1 inputs. Generated by tool as <b>TILEx_CFG_COUNTER_MODE_1</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the input signals to the counter block.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures Counter and FSM modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">miscCtrl</td><td>is the value to represent counter and FSM modes. Generated by tool as <b>TILEx_CFG_MISC_CONTROL</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the counter mode, particularly add/shift, load modes. The function also configures whether the FSM should use state inputs or an extra external input.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures Output LUT functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">outID</td><td>is the specified CLB tile output signal. </td></tr>
    <tr><td class="paramname">outputCfg</td><td>is the value for the output LUT signal function and input signal selections. Generated by tool as <b>TILEx_CFG_OUTLUT_n</b> where n is the output number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the input signals and equations of the output LUT corresponding to the /e outID parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures HLC event selection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">eventSel</td><td>is the value for HLC event selection. Generated by tool as <b>TILEx_HLC_EVENT_SEL</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the event selection for the High Level Controller.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Program HLC instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">instructionNum</td><td>is the index into the HLC instruction memory. For example, a value of 0 corresponds to instruction 0 of event 0, a value of 1 corresponds to instruction 1 of event 0, and so on up to a value of 31 which corresponds to instruction 7 of event 3. </td></tr>
    <tr><td class="paramname">instruction</td><td>is the instruction to be programmed. Generated by tool as <b>TILEx_HLCINSTR_n</b> where n is the instruction number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the CLB internal memory corresponding to the specified HLC instruction number with the given instruction.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set HLC registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">r0Init</td><td>is the value to write to HLC register R0. Generated by tool as <b>TILEx_HLC_R0_INIT</b>. </td></tr>
    <tr><td class="paramname">r1Init</td><td>is the value to write to HLC register R1. Generated by tool as <b>TILEx_HLC_R1_INIT</b>. </td></tr>
    <tr><td class="paramname">r2Init</td><td>is the value to write to HLC register R2. Generated by tool as <b>TILEx_HLC_R2_INIT</b>. </td></tr>
    <tr><td class="paramname">r3Init</td><td>is the value to write to HLC register R3. Generated by tool as <b>TILEx_HLC_R3_INIT</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the CLB internal memory corresponding to the HLC registers R0-R3 with the specified values.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get HLC or counter register values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">registerID</td><td>is the internal register from which to read. Can be either an HLC register (<b>CLB_REG_HLC_Rn</b>) or a counter value (<b>CLB_REG_CTR_Cn</b>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value in the specified HLC register or counter.</dd></dl>
<p>Get output status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the output status of various components within the CLB tile such as a counter match or LUT output. Use the <b>CLB_DBG_OUT_*</b> masks from <code>hw_clb.h</code> to decode the bits.</dd></dl>
<p>Enable CLB Pipeline Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the CLB Pipeline Mode</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable CLB Pipeline Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the CLB Pipeline Mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable CLB Output Mask Updates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the CLB Output Mask updates</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable CLB Output Mask Updates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the CLB Output Mask updates</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable Input Pipeline Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the CLB Input Pipeline mode</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable Input Pipeline Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the CLB Input Pipeline mode</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable SPI RX Buffer Access.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the CLB SPI RX Buffer access</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable SPI RX Buffer Access.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the CLB SPI RX Buffer access</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures SPI RX Buffer Load Signal event selection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">eventSel</td><td>is the value for HLC event selection. Generated by tool as <b>TILEx_SPI_BUF_EVENT_SEL</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the event selection for the SPI RX Buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures SPI Export HLC R0 Shift value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register. </td></tr>
    <tr><td class="paramname">shiftVal</td><td>is the value for SPI export HLC R0 bit range selection.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the SPI Export HLC R0 Shift value.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables strobe delay event for SPI.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the delay for selected strobe event by 4-CLB clock cycles to SPI module.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables strobe delay event for SPI.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of a CLB tile's logic config register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the delay for selected strobe event.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the CMPSS module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the CMPSS module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the CMPSS module passed into the <em>base</em> parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the configuration for the high comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the CMPSS module. </td></tr>
    <tr><td class="paramname">config</td><td>is the configuration of the high comparator.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures a comparator. The <em>config</em> parameter is the result of a logical OR operation between a <b>CMPSS_INSRC_xxx</b> value and if desired, <b>CMPSS_INV_INVERTED</b> and <b>CMPSS_OR_ASYNC_OUT_W_FILT</b> values.</p>
<p>The <b>CMPSS_INSRC_xxx</b> term can take on the following values to specify the high comparator negative input source:</p><ul>
<li><b>CMPSS_INSRC_DAC</b> - The internal DAC.</li>
<li><b>CMPSS_INSRC_PIN</b> - An external pin.</li>
</ul>
<p><b>CMPSS_INV_INVERTED</b> may be ORed into <em>config</em> if the comparator output should be inverted.</p>
<p><b>CMPSS_OR_ASYNC_OUT_W_FILT</b> may be ORed into <em>config</em> if the asynchronous comparator output should be fed into an OR gate with the latched digital filter output before it is made available for CTRIPH or CTRIPOUTH.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the configuration for the low comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the CMPSS module. </td></tr>
    <tr><td class="paramname">config</td><td>is the configuration of the low comparator.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures a comparator. The <em>config</em> parameter is the result of a logical OR operation between a <b>CMPSS_INSRC_xxx</b> value and if desired, <b>CMPSS_INV_INVERTED</b> and <b>CMPSS_OR_ASYNC_OUT_W_FILT</b> values.</p>
<p>The <b>CMPSS_INSRC_xxx</b> term can take on the following values to specify the low comparator negative input source:</p><ul>
<li><b>CMPSS_INSRC_DAC</b> - The internal DAC.</li>
<li><b>CMPSS_INSRC_PIN</b> - An external pin.</li>
</ul>
<p><b>CMPSS_INV_INVERTED</b> may be ORed into <em>config</em> if the comparator output should be inverted.</p>
<p><b>CMPSS_OR_ASYNC_OUT_W_FILT</b> may be ORed into <em>config</em> if the asynchronous comparator output should be fed into an OR gate with the latched digital filter output before it is made available for CTRIPL or CTRIPOUTL.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the output signal configuration for the high comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the CMPSS module. </td></tr>
    <tr><td class="paramname">config</td><td>is the configuration of the high comparator output signals.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures a comparator's output signals CTRIP and CTRIPOUT. The <em>config</em> parameter is the result of a logical OR operation between the <b>CMPSS_TRIPOUT_xxx</b> and <b>CMPSS_TRIP_xxx</b> values.</p>
<p>The <b>CMPSS_TRIPOUT_xxx</b> term can take on the following values to specify which signal drives CTRIPOUTH:</p><ul>
<li><b>CMPSS_TRIPOUT_ASYNC_COMP</b> - The asynchronous comparator output.</li>
<li><b>CMPSS_TRIPOUT_SYNC_COMP</b> - The synchronous comparator output.</li>
<li><b>CMPSS_TRIPOUT_FILTER</b> - The output of the digital filter.</li>
<li><b>CMPSS_TRIPOUT_LATCH</b> - The latched output of the digital filter.</li>
</ul>
<p>The <b>CMPSS_TRIP_xxx</b> term can take on the following values to specify which signal drives CTRIPH:</p><ul>
<li><b>CMPSS_TRIP_ASYNC_COMP</b> - The asynchronous comparator output.</li>
<li><b>CMPSS_TRIP_SYNC_COMP</b> - The synchronous comparator output.</li>
<li><b>CMPSS_TRIP_FILTER</b> - The output of the digital filter.</li>
<li><b>CMPSS_TRIP_LATCH</b> - The latched output of the digital filter.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the output signal configuration for the low comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the CMPSS module. </td></tr>
    <tr><td class="paramname">config</td><td>is the configuration of the low comparator output signals.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures a comparator's output signals CTRIP and CTRIPOUT. The <em>config</em> parameter is the result of a logical OR operation between the <b>CMPSS_TRIPOUT_xxx</b> and <b>CMPSS_TRIP_xxx</b> values.</p>
<p>The <b>CMPSS_TRIPOUT_xxx</b> term can take on the following values to specify which signal drives CTRIPOUTL:</p><ul>
<li><b>CMPSS_TRIPOUT_ASYNC_COMP</b> - The asynchronous comparator output.</li>
<li><b>CMPSS_TRIPOUT_SYNC_COMP</b> - The synchronous comparator output.</li>
<li><b>CMPSS_TRIPOUT_FILTER</b> - The output of the digital filter.</li>
<li><b>CMPSS_TRIPOUT_LATCH</b> - The latched output of the digital filter.</li>
</ul>
<p>The <b>CMPSS_TRIP_xxx</b> term can take on the following values to specify which signal drives CTRIPL:</p><ul>
<li><b>CMPSS_TRIP_ASYNC_COMP</b> - The asynchronous comparator output.</li>
<li><b>CMPSS_TRIP_SYNC_COMP</b> - The synchronous comparator output.</li>
<li><b>CMPSS_TRIP_FILTER</b> - The output of the digital filter.</li>
<li><b>CMPSS_TRIP_LATCH</b> - The latched output of the digital filter.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the current comparator status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current status for the comparator, specifically the digital filter output and latched digital filter output.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current interrupt status, enumerated as a bit field of the following values:<ul>
<li><b>CMPSS_STS_HI_FILTOUT</b> - High digital filter output</li>
<li><b>CMPSS_STS_HI_LATCHFILTOUT</b> - Latched value of high digital filter output</li>
<li><b>CMPSS_STS_LO_FILTOUT</b> - Low digital filter output</li>
<li><b>CMPSS_STS_LO_LATCHFILTOUT</b> - Latched value of low digital filter output</li>
</ul>
</dd></dl>
<p>Sets the configuration for the internal comparator DACs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the CMPSS module. </td></tr>
    <tr><td class="paramname">config</td><td>is the configuration of the internal DAC.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the comparator's internal DAC. The <em>config</em> parameter is the result of a logical OR operation between the <b>CMPSS_DACVAL_xxx</b>, <b>CMPSS_DACREF_xxx</b>, and <b>CMPSS_DACSRC_xxx</b>.</p>
<p>The <b>CMPSS_DACVAL_xxx</b> term can take on the following values to specify when the DAC value is loaded from its shadow register:</p><ul>
<li><b>CMPSS_DACVAL_SYSCLK</b> - Value register updated on system clock.</li>
<li><b>CMPSS_DACVAL_PWMSYNC</b> - Value register updated on PWM sync.</li>
</ul>
<p>The <b>CMPSS_DACREF_xxx</b> term can take on the following values to specify which voltage supply is used as reference for the DACs:</p><ul>
<li><b>CMPSS_DACREF_VDDA</b> - VDDA is the voltage reference for the DAC.</li>
<li><b>CMPSS_DACREF_VDAC</b> - VDAC is the voltage reference for the DAC.</li>
</ul>
<p>The <b>CMPSS_DACSRC_xxx</b> term can take on the following values to specify the DAC value source for the high comparator's internal DAC:</p><ul>
<li><b>CMPSS_DACSRC_SHDW</b> - The user-programmed DACVALS register.</li>
<li><b>CMPSS_DACSRC_RAMP</b> - The ramp generator RAMPSTS register</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This API configures only the high comparator DAC and is to be deprecated in future. Use APIs <em>CMPSS_configDACHigh()</em> and <em>CMPSS_configDACLow()</em> to configure the high and low comparator DACs respectively.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the configuration for the internal DAC of high comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the CMPSS module. </td></tr>
    <tr><td class="paramname">config</td><td>is the configuration of the internal DAC.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the high comparator's internal DAC. The <em>config</em> parameter is the result of a logical OR operation between the <b>CMPSS_DACVAL_xxx</b>, <b>CMPSS_DACREF_xxx</b>, and <b>CMPSS_DACSRC_xxx</b>.</p>
<p>The <b>CMPSS_DACVAL_xxx</b> term can take on the following values to specify when the DAC value is loaded from its shadow register:</p><ul>
<li><b>CMPSS_DACVAL_SYSCLK</b> - Value register updated on system clock.</li>
<li><b>CMPSS_DACVAL_PWMSYNC</b> - Value register updated on PWM sync.</li>
</ul>
<p>The <b>CMPSS_DACREF_xxx</b> term can take on the following values to specify which voltage supply is used as reference for the DACs:</p><ul>
<li><b>CMPSS_DACREF_VDDA</b> - VDDA is the voltage reference for the DAC.</li>
<li><b>CMPSS_DACREF_VDAC</b> - VDAC is the voltage reference for the DAC.</li>
</ul>
<p>The <b>CMPSS_DACSRC_xxx</b> term can take on the following values to specify the DAC value source for the high comparator's internal DAC:</p><ul>
<li><b>CMPSS_DACSRC_SHDW</b> - The user-programmed DACHVALS register.</li>
<li><b>CMPSS_DACSRC_RAMP</b> - The ramp generator RAMPHSTS register</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the configuration for the internal DAC of low comparator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the CMPSS module. </td></tr>
    <tr><td class="paramname">config</td><td>is the configuration of the internal DAC.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the low comparator's internal DAC. The <em>config</em> parameter can take on the following values to specify the DAC value source for the low comparator's internal DAC:</p><ul>
<li><b>CMPSS_DACSRC_SHDW</b> - The user-programmed DACLVALS register.</li>
<li><b>CMPSS_DACSRC_RAMP</b> - The ramp generator RAMPLSTS register</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This API is not valid for CMPSS-Lite IP.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the value of the internal DAC of the high comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">value</td><td>is the value actively driven by the DAC.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the 12-bit value driven by the internal DAC of the high comparator. This function will load the value into the shadow register from which the actual DAC value register will be loaded. To configure which event causes this shadow load to take place, use CMPSS_configDAC().</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the value of the internal DAC of the low comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">value</td><td>is the value actively driven by the DAC.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the 12-bit value driven by the internal DAC of the low comparator. This function will load the value into the shadow register from which the actual DAC value register will be loaded. To configure which event causes this shadow load to take place, use CMPSS_configDAC().</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Initializes the digital filter of the high comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes all the samples in the high comparator digital filter to the filter input value.</p>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="group__cmpss__api.html#gaa0345e3d4b5df846668e3699da609a55">CMPSS_configFilterHigh()</a> for the proper initialization sequence to avoid glitches.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Initializes the digital filter of the low comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes all the samples in the low comparator digital filter to the filter input value.</p>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="group__cmpss__api.html#ga775b12cdecceeb61fd2fcf4c0736ffca">CMPSS_configFilterLow()</a> for the proper initialization sequence to avoid glitches.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures input for the digital filter of the high comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">filtInput</td><td>is the desired filter input</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures input for the digital filter of the high comparator. The filter input can either be high comparator output or an external signal configured through XBAR.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Initializes the digital filter of the low comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">filtInput</td><td>is the desired filter input</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures input for the digital filter of the low comparator. The filter input can either be low comparator output or an external signal configured through XBAR.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the value of the internal DAC of the high comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the value of the internal DAC of the high comparator. The value is read from the <em>active</em> register&ndash;not the shadow register to which CMPSS_setDACValueHigh() writes.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value driven by the internal DAC of the high comparator.</dd></dl>
<p>Gets the value of the internal DAC of the low comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the value of the internal DAC of the low comparator. The value is read from the <em>active</em> register&ndash;not the shadow register to which CMPSS_setDACValueLow() writes.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value driven by the internal DAC of the low comparator.</dd></dl>
<p>Causes a software reset of the high comparator digital filter output latch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function causes a software reset of the high comparator digital filter output latch. It will generate a single pulse of the latch reset signal.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Causes a software reset of the low comparator digital filter output latch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function causes a software reset of the low comparator digital filter output latch. It will generate a single pulse of the latch reset signal.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the ramp generator maximum reference value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">value</td><td>the ramp maximum reference value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the ramp maximum reference value that will be loaded into the ramp generator.</p>
<dl class="section note"><dt>Note</dt><dd>This API returns the reference value for only the high ramp generator and is to be deprecated in future. Use APIs <em>CMPSS_getRampReferenceHigh()</em> and <em>CMPSS_getRampReferenceLow()</em> to get reference value for high and low ramp generators respectively.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the ramp generator maximum reference value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API returns the reference value for only the high ramp generator and is to be deprecated in future. Use APIs <em>CMPSS_getRampReferenceHigh()</em> and <em>CMPSS_getRampReferenceLow()</em> to get reference value for high and low ramp generators respectively.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the latched ramp maximum reference value that will be loaded into the ramp generator.</dd></dl>
<p>Sets the ramp generator decrement value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">value</td><td>is the ramp decrement value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the value that is subtracted from the ramp value on every system clock cycle.</p>
<dl class="section note"><dt>Note</dt><dd>This API configures the step value only for the high ramp generator in down count mode and is to be deprecated in future. Use APIs <em>CMPSS_setRampStepHigh()</em> and <em>CMPSS_setRampStepLow()</em> to configure the step value for high and low ramp ramp generators respectively for up/down count mode.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the ramp generator decrement value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API returns the high ramp generator step value only and is to be deprecated in future. Use APIs <em>CMPSS_getRampStepHigh()</em> and <em>CMPSS_getRampStepLow()</em> to configure the step value for high and low ramp ramp generators respectively for up/down count mode.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the latched ramp decrement value that is subtracted from the ramp value on every system clock cycle.</dd></dl>
<p>Sets the ramp generator delay value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">value</td><td>is the 13-bit ramp delay value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the value that configures the number of system clock cycles to delay the start of the ramp generator decrementer after a PWMSYNC event is received. Delay value can be no greater than 8191.</p>
<dl class="section note"><dt>Note</dt><dd>This API configures the delay value for only the high ramp generator configured in down count mode and is to be deprecated in future. Use APIs <em>CMPSS_setRampDelayHigh()</em> and <em>CMPSS_setRampDelayLow()</em> to configure the delay value for high and low ramp generators respectively for up/down count mode.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the ramp generator delay value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API returns delay value for only the high ramp generator and is to be deprecated in future. Use APIs <em>CMPSS_getRampDelayHigh()</em> and <em>CMPSS_getRampDelayLow()</em> to configure the delay value for high and low ramp ramp generators respectively for up/down count mode.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the latched ramp delay value that is subtracted from the ramp value on every system clock cycle.</dd></dl>
<p>Sets the ramp direction for the high ramp generator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">dir</td><td>is the ramp direction for high ramp generator.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the ramp direction for the high ramp generator.</p>
<dl class="section note"><dt>Note</dt><dd>This API is not valid for CMPSS-Lite IP.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the high ramp generator reference value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">value</td><td>the high ramp generator reference value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the reference value that will be loaded into the high ramp generator.</p>
<dl class="section note"><dt>Note</dt><dd>This API is not valid for CMPSS-Lite IP.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the ramp generator reference value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is not valid for CMPSS-Lite IP.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the latched ramp reference value that will be loaded into the high ramp generator.</dd></dl>
<p>Sets the ramp generator decrement value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">value</td><td>is the ramp decrement value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the value that is subtracted from the ramp value on every system clock cycle.</p>
<dl class="section note"><dt>Note</dt><dd>This API is not valid for CMPSS-Lite IP.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the ramp step value for high ramp generator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is not valid for CMPSS-Lite IP.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the latched ramp step value that is added/subtracted from the ramp reference value on every system clock cycle.</dd></dl>
<p>Sets the high ramp generator delay value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">value</td><td>is the 13-bit ramp delay value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the value that configures the number of system clock cycles to delay the start of the ramp generator incrementor/decrementor after a PWMSYNC event is received. Delay value can be no greater than 8191.</p>
<dl class="section note"><dt>Note</dt><dd>This API is not valid for CMPSS-Lite IP.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the high ramp generator delay value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is not valid for CMPSS-Lite IP.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the latched ramp delay value that configures the number of system clock cycles to delay the start of the ramp generator incrementor/ decrementor after a PWMSYNC event is received.</dd></dl>
<p>Sets the ramp direction for the low ramp generator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">dir</td><td>is the ramp direction for low ramp generator.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the ramp direction for the low ramp generator.</p>
<dl class="section note"><dt>Note</dt><dd>This API is not valid for CMPSS-Lite IP.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the low ramp generator reference value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">value</td><td>the low ramp generator reference value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the reference value that will be loaded into the low ramp generator.</p>
<dl class="section note"><dt>Note</dt><dd>This API is not valid for CMPSS-Lite IP.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the low ramp generator reference value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is not valid for CMPSS-Lite IP.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the latched ramp reference value that will be loaded into the low ramp generator.</dd></dl>
<p>Sets the ramp generator decrement value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">value</td><td>is the ramp decrement value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the value that is added/subtracted from the ramp value on every system clock cycle.</p>
<dl class="section note"><dt>Note</dt><dd>This API is not valid for CMPSS-Lite IP.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the ramp step value for low ramp generator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is not valid for CMPSS-Lite IP.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the latched ramp step value that is added/subtracted from the ramp reference value on every system clock cycle.</dd></dl>
<p>Sets the low ramp generator delay value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">value</td><td>is the 13-bit ramp delay value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the value that configures the number of system clock cycles to delay the start of the ramp generator incrementor/decrementor after a PWMSYNC event is received. Delay value can be no greater than 8191.</p>
<dl class="section note"><dt>Note</dt><dd>This API is not valid for CMPSS-Lite IP.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the low ramp generator delay value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is not valid for CMPSS-Lite IP.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the latched ramp delay value that configures the number of system clock cycles to delay the start of the ramp generator incrementor/ decrementor after a PWMSYNC event is received.</dd></dl>
<p>Configures high ramp generator cross trigger feature</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">trigger</td><td>is the desired cross trigger for ramp generation</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the cross trigger feature for the high ramp generators. Cross triggering allows usage of both high and low ramp generators in the CMPSS with the involvement of single PWM trigger. When enabled, cross triggering allows selected PWMSYNCx signal to trigger start of ramp(SOR) of primary ramp while secondary ramp can be triggered by the end of ramp (EOR) of primary ramp generator.</p>
<dl class="section note"><dt>Note</dt><dd>The primary ramp generator trigger can be configured through CMPSS_configureSyncSourceHigh() API.</dd>
<dd>
This API is not valid for CMPSS-Lite IP.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures sync source for high comparator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">syncSource</td><td>is the desired EPWMxSYNCPER source</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures desired EPWMxSYNCPER source for high comparator blocks. Configured EPWMxSYNCPER signal can be used to synchronize loading of DAC input value from shadow to active register. It can also be used to synchronize Ramp generator, if applicable. Refer to device manual to check if Ramp generator is available in the desired CMPSS instance.</p>
<p>Valid values for <em>syncSource</em> parameter can be 1 to n, where n represents the maximum number of EPWMSYNCPER signals available on the device. For instance, passing 2 into <em>syncSource</em> will select EPWM2SYNCPER.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures sync source for low comparator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">syncSource</td><td>is the desired EPWMxSYNCPER source</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures desired EPWMxSYNCPER source for low comparator blocks. Configured EPWMxSYNCPER signal can be used to synchronize loading of DAC input value from shadow to active register. It can also be used to synchronize Ramp generator, if applicable. Refer to device manual to check if Ramp generator is available in the desired CMPSS instance.</p>
<p>Valid values for <em>syncSource</em> parameter can be 1 to n, where n represents the maximum number of EPWMSYNCPER signals available on the device. For instance, passing 2 into <em>syncSource</em> will select EPWM2SYNCPER.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the high ramp generator clock divider value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">value</td><td>is the ramp clock divider value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the ramp clock divider value for high comparator(COMPH) to be divided from SYSCLK to configure the ramp generator clock. Valid values for param <em>divider</em> can be refered from enum <em>CMPSS_RampClockDiv</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the high ramp generator clock divider value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the latched ramp clock divider value that is divided from the SYSCLK to configure the ramp generator clock.</dd></dl>
<p>Sets the low ramp generator clock divider value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">divider</td><td>is the ramp clock divider value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the ramp clock divider value for low comparator(COMPL) to be divided from SYSCLK to configure the ramp generator clock. Valid values for param <em>divider</em> can be refered from enum <em>CMPSS_RampClockDiv</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the low ramp generator clock divider value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the latched ramp clock divider value that is divided from the SYSCLK to configure the low ramp generator clock.</dd></dl>
<p>Sets the comparator hysteresis settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">value</td><td>is the amount of hysteresis on the comparator inputs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the amount of hysteresis on the comparator inputs. The <em>value</em> parameter indicates the amount of hysteresis desired. Passing in 0 results in none, passing in 1 results in typical hysteresis, passing in 2 results in 2x of typical hysteresis, and so on where <em>value</em> x of typical hysteresis is the amount configured.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables reset of HIGH comparator digital filter output latch on PWMSYNC</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables EPWMSYNCPER reset of High comparator digital filter output latch</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables reset of HIGH comparator digital filter output latch on PWMSYNC</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables EPWMSYNCPER reset of High comparator digital filter output latch</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables reset of LOW comparator digital filter output latch on PWMSYNC</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables EPWMSYNCPER reset of Low comparator digital filter output latch</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables reset of LOW comparator digital filter output latch on PWMSYNC</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables EPWMSYNCPER reset of Low comparator digital filter output latch</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the ePWM module blanking signal that holds trip in reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">pwmBlankSrc</td><td>is the number of the PWMBLANK source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures which PWMBLANK signal from the ePWM module will hold trip in reset when blanking is enabled.</p>
<p>The number of the PWMBLANK signal to be used to reset the ramp generator should be specified by passing it into the <em>pwmBlankSrc</em> parameter. For instance, passing a 2 into <em>pwmBlankSrc</em> will select PWMBLANK2.</p>
<dl class="section note"><dt>Note</dt><dd>This API configures blanking source for only the high comparator and is to be deprecated in future. Use APIs <em>CMPSS_configBlankingSourceHigh()</em> and <em>CMPSS_configBlankingSourceLow()</em> to configure the blanking source for high and low comparators respectively.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables an ePWM blanking signal to hold trip in reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables a selected ePWM blanking signal to hold trip in reset.</p>
<dl class="section note"><dt>Note</dt><dd>This API enables blanking for only the high comparator subsystem and is to be deprecated in future. Use APIs <em>CMPSS_enableBlankingHigh()</em> and <em>CMPSS_enableBlankingLow()</em> to enable the blanking for high and low comparators respectively.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables an ePWM blanking signal from holding trip in reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables a selected ePWM blanking signal from holding trip in reset.</p>
<dl class="section note"><dt>Note</dt><dd>This API disables blanking for only the high comparator subsystem and is to be deprecated in future. Use APIs <em>CMPSS_disableBlankingHigh()</em> and <em>CMPSS_disableBlankingLow()</em> to disable the blanking for high and low comparators respectively.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the high comparator ePWM module blanking signal source that holds trip in reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">pwmBlankSrc</td><td>is the number of the PWMBLANK source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures which PWMBLANK signal from the ePWM module will hold trip in reset when blanking is enabled in high comparator digital filter.</p>
<p>The number of the PWMBLANK signal to be used should be specified by passing it into the <em>pwmBlankSrc</em> parameter. For instance, passing a 2 into <em>pwmBlankSrc</em> will select PWMBLANK2.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables high comparator's ePWM blanking signal to hold trip in reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables high comparator's selected ePWM blanking signal to hold trip in reset.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables high comparator's ePWM blanking signal from holding trip in reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables high comparator's selected ePWM blanking signal from holding trip in reset.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the low comparator's ePWM module blanking signal source that holds trip in reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">pwmBlankSrc</td><td>is the number of the PWMBLANK source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures which PWMBLANK signal from the ePWM module will hold trip in reset when blanking is enabled for low comparator.</p>
<p>The number of the PWMBLANK signal to be used should be specified by passing it into the <em>pwmBlankSrc</em> parameter. For instance, passing a 2 into <em>pwmBlankSrc</em> will select PWMBLANK2.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables low comparator's ePWM blanking signal to hold trip in reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables low comparator's selected ePWM blanking signal to hold trip in reset.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables low comparator's ePWM blanking signal from holding trip in reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables low comparator's selected ePWM blanking signal from holding trip in reset.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables the CMPSS diode emulation mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the CMPSS diode emulation mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the CMPSS diode emulation mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the CMPSS diode emulation mode</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Select the CMPSS diode emulation mode DEACTIVE source</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">deactivesel</td><td>is the DEACTIVE source select</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the CMPSS diode emulation mode DEACTIVE source Valid values for param <em>deactivesel</em> are to be referred from <em>CMPSS_DEActiveSelect</em> enum.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the shadow value 2 (used in DE mode) of the internal DAC of the high comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">dacval</td><td>is the value actively driven by the DAC.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the 12-bit value driven by the internal DAC of the high comparator. This function will load the value into the shadow register 2 from which the actual DAC value register will be loaded in DE mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the shadow value 2 (used in DE mode) of the internal DAC of the low comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">dacval</td><td>is the value actively driven by the DAC.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the 12-bit value driven by the internal DAC of the low comparator. This function will load the value into the shadow register 2 from which the actual DAC value register will be loaded in DE mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Select the Blank source group for high comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">group</td><td>is the blank source group</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the Blank source group for high comparator(COMPH). Valid values for param <em>group</em> can be: CMPSS_EPWM_GROUP_0TO15 or CMPSS_EPWM_GROUP_16TO31.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Select the Blank source group for low comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">group</td><td>is the blank source group.</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the Blank source group for low comparator(COMPL). Valid values for param <em>group</em> can be: CMPSS_EPWM_GROUP_0TO15 or CMPSS_EPWM_GROUP_16TO31.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Select the Ramp source group for high comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">group</td><td>is the ramp source group.</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the Ramp source group for high comparator(COMPH). Valid values for param <em>group</em> can be: CMPSS_EPWM_GROUP_0TO15 or CMPSS_EPWM_GROUP_16TO31.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Select the Ramp source group for low comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the comparator module. </td></tr>
    <tr><td class="paramname">group</td><td>is the ramp source group.</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the Ramp source group for low comparator(COMPL). Valid values for param <em>group</em> can be: CMPSS_EPWM_GROUP_0TO15 or CMPSS_EPWM_GROUP_16TO31.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Unlock CPU registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registers</td><td>Registers to be unlocked. Can be OR of the following -<ul>
<li>CPU_C29_RTINT_STACK</li>
<li>CPU_C29_SECCALL_STACK</li>
<li>CPU_C29_SECURE_REGS</li>
<li>CPU_C29_DIAG_REGS</li>
<li>CPU_C29_SELFTEST_REGS </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Commit CPU registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registers</td><td>Registers to be committed. Can be OR of the following -<ul>
<li>CPU_C29_RTINT_STACK</li>
<li>CPU_C29_SECCALL_STACK</li>
<li>CPU_C29_SECURE_REGS</li>
<li>CPU_C29_DIAG_REGS</li>
<li>CPU_C29_SELFTEST_REGS </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Set the warning level for protected call stack pointer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>is the warning level set.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the warning level for protected call stack pointer. External logic may compare PSP with WARNPSP to generate early warning interrupt to avoid protected call stack overflow.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Force TMU ROM Parity error</p>
<p>This function forces the TMU ROM Parity Error. The key 0xA5 must be written along with the force bit, otherwise, writes are ignored. The key is cleared immediately after writing, so it must be written again for every change to this bit.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Clear TMU ROM Parity error</p>
<p>This function clears the TMU ROM Parity Error. The key 0xA5 must be written along with a write of 0 to the force bit, otherwise, writes are ignored.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Sets the DAC Reference Voltage</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DAC module base address </td></tr>
    <tr><td class="paramname">source</td><td>is the selected reference voltage</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the DAC reference voltage.</p>
<p>The <em>source</em> parameter can have the following value:</p><ul>
<li><b>DAC_REF_VDAC</b> - The VDAC reference voltage</li>
<li><b>DAC_REF_ADC_VREFHI</b> - The ADC VREFHI reference voltage</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the DAC Gain Mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DAC module base address </td></tr>
    <tr><td class="paramname">mode</td><td>is the selected gain mode</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the DAC gain mode for the buffered output.</p>
<p>The <em>mode</em> parameter can have one of two values:</p><ul>
<li><b>DAC_GAIN_ONE</b> - Gain is set to 1</li>
<li><b>DAC_GAIN_TWO</b> - Gain is set to 2</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This value is only used when <em>DAC_REF_ADC_VREFHI</em> is set using DAC_setReferenceVoltage() and internal ADC reference mode is selected.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the DAC Load Mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DAC module base address </td></tr>
    <tr><td class="paramname">mode</td><td>is the selected load mode</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the DAC load mode.</p>
<p>The <em>mode</em> parameter can have one of two values:</p><ul>
<li><b>DAC_LOAD_SYSCLK</b> - Load on next SYSCLK</li>
<li><b>DAC_LOAD_PWMSYNC</b> - Load on next PWMSYNC specified by SYNCSEL</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the DAC PWMSYNC Signal</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DAC module base address </td></tr>
    <tr><td class="paramname">signal</td><td>is the selected PWM signal</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the DAC PWMSYNC signal.</p>
<p>The <em>signal</em> parameter must be set to a number that represents the PWM signal that will be set. For instance, passing 2 into <em>signal</em> will select PWM sync signal 2.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get the DAC Active Output Value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DAC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the DAC active output value.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the DAC active output value.</dd></dl>
<p>Set the DAC Shadow Output Value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DAC module base address </td></tr>
    <tr><td class="paramname">value</td><td>is the 12-bit code to be loaded into the active value register</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the DAC shadow output value.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get the DAC Shadow Output Value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DAC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the DAC shadow output value.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the DAC shadow output value.</dd></dl>
<p>Enable the DAC Output</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DAC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the DAC output.</p>
<dl class="section note"><dt>Note</dt><dd>A delay is required after enabling the DAC. Further details regarding the exact delay time length can be found in the device datasheet.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable the DAC Output</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DAC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the DAC output.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set DAC Offset Trim</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DAC module base address </td></tr>
    <tr><td class="paramname">offset</td><td>is the specified value for the offset trim</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the DAC offset trim. The <em>offset</em> value should be a signed number in the range of -128 to 127.</p>
<dl class="section note"><dt>Note</dt><dd>The offset should not be modified unless specifically indicated by TI Errata or other documentation. Modifying the offset value could cause this module to operate outside of the datasheet specifications.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get DAC Offset Trim</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DAC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the DAC offset trim value.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Lock write-access to DAC Register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DAC module base address </td></tr>
    <tr><td class="paramname">reg</td><td>is the selected DAC registers</td></tr>
  </table>
  </dd>
</dl>
<p>This function locks the write-access to the specified DAC register. Only a system reset can unlock the register once locked.</p>
<p>The <em>reg</em> parameter can be an ORed combination of any of the following values:</p><ul>
<li><b>DAC_LOCK_CONTROL</b> - Lock the DAC control register</li>
<li><b>DAC_LOCK_SHADOW</b> - Lock the DAC shadow value register</li>
<li><b>DAC_LOCK_OUTPUT</b> - Lock the DAC output enable/disable register</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Check if DAC Register is locked</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DAC module base address </td></tr>
    <tr><td class="paramname">reg</td><td>is the selected DAC register locks to check</td></tr>
  </table>
  </dd>
</dl>
<p>This function checks if write-access has been locked on the specified DAC register.</p>
<p>The <em>reg</em> parameter can be an ORed combination of any of the following values:</p><ul>
<li><b>DAC_LOCK_CONTROL</b> - Lock the DAC control register</li>
<li><b>DAC_LOCK_SHADOW</b> - Lock the DAC shadow value register</li>
<li><b>DAC_LOCK_OUTPUT</b> - Lock the DAC output enable/disable register</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if any of the registers specified are locked, and <b>false</b> if all specified registers aren't locked.</dd></dl>
<p>Disable the DCC module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function stops the DCC counter operation.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable DCC Error Signal</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the error signal interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable DCC Done Signal</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the done signal interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable DCC Error Signal</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the error signal interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable DCC Done Signal</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the done signal interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable DCC Single-Shot Mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the single-shot mode and sets the operation mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable DCC Single-Shot Mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the DCC Single-Shot operation mode</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get Error Flag Status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the error flag status.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if an error has occurred, <b>false</b> if no errors have occurred.</dd></dl>
<p>Get Single-Shot Done Flag Status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the single-shot done flag status.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if single-shot mode has completed, <b>false</b> if single-shot mode has not completed.</dd></dl>
<p>Clear Error Status Flag</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the DCC error status flag.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clear Single-Shot Done Status Flag</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the DCC single-shot done status flag.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get Current Value of Counter 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets current value of counter 0.</p>
<dl class="section note"><dt>Note</dt><dd>Reads of the counter value may not be exact since the read operation is synchronized to the vbus clock.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the current value of counter 0.</dd></dl>
<p>Get Current Value of the Valid Duration Counter for Counter 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets current value of the valid duration counter for counter 0.</p>
<dl class="section note"><dt>Note</dt><dd>Reads of the counter value may not be exact since the read operation is synchronized to the vbus clock.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the current value of the valid duration counter.</dd></dl>
<p>Get Current Value of Counter 1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets current value of counter 1.</p>
<dl class="section note"><dt>Note</dt><dd>Reads of the counter value may not be exact since the read operation is synchronized to the vbus clock.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the current value of counter 1.</dd></dl>
<p>Set Counter 1 Clock Source</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address </td></tr>
    <tr><td class="paramname">source</td><td>is the selected clock source for counter 1</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the counter 1 clock source.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set Counter 0 Clock Source</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address </td></tr>
    <tr><td class="paramname">source</td><td>is the selected clock source for counter 0</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the counter 0 clock source.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get Counter 1 Clock Source</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the counter 1 clock source.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns Counter 1 clock source from the enum DCC_Count1ClockSource</dd></dl>
<p>Get Counter 0 Clock Source</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the counter 0 clock source.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns Counter 0 clock source from the enum DCC_Count0ClockSource</dd></dl>
<p>Set the seed values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the DCC module base address </td></tr>
    <tr><td class="paramname">counter0</td><td>sets the seed value that gets loaded into Counter 0 </td></tr>
    <tr><td class="paramname">validCounter0</td><td>sets the seed value that gets loaded into the valid duration counter for Counter 0 </td></tr>
    <tr><td class="paramname">counter1</td><td>sets the seed value that gets loaded into Counter 1</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the seed values for Counter 0, Valid Duration Counter 0, and Counter 1.</p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>Operating DCC with '0' set as the seed value for Counter 0, Valid Duration Counter 0, and/or Counter 1 will result in undefined operation.</li>
<li>The Valid Duration Counter 0 is designed to be at least four cycles wide and shouldn't be programmed with a value less than '4'.</li>
</ol>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable Link permissions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>is the SSU_LINK for which the permissions are disabled to record DLT entries in the FIFO.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the permission of the corresponding link to record entries to the DLT FIFO. </p><dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable DLT Recording and triggers.</p>
<p>This function does a global enable of DLT module. The DLT recording and triggers are enabled.</p>
<dl class="section note"><dt>Note</dt><dd>The 16 bit key (DLT_CONTROL_KEY) act as a key to enable writes to lower 16 bits of DLT_CONTROL register. The only time lower 16 bits can be updated is by a single 32-bit write where bits 31:16 equal 0x5a5a. All other writes are ignored including separate 16-bit writes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable Logging.</p>
<p>This function disables all components of the DLT module.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable ERAD Filtering.</p>
<p>This function enables ERAD event based START-END filtering. Note: Filter enables are not expected to change dynamically in the middle of data logging, and take effect after a few cycles.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable ERAD Filtering.</p>
<p>This function disables the ERAD event based START-END filtering.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable Tag Filtering.</p>
<p>This function enables the TAG based START-END filtering.</p>
<dl class="section note"><dt>Note</dt><dd>TAGs should be at the beginning of every function call or ISR function, followed by any registers being data logged.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable Tag Filtering.</p>
<p>This function disables TAG based START-END filtering.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the DLT Capture Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>is the capture mode to be selected. Refer DLT_CaptureMode enum for the possible modes.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the Capture mode. mode = 0: With each entry, the timestamp is captured. mode = 1: With each entry, PC source is captured.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Reset Filtering Unit.</p>
<p>This function resets the filtering unit. It clears the previous status derived from START and STOP events.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable DMA.</p>
<p>This function enables DMA request to be generated when FIFO reaches FIFO_TRIG_LEVEL.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable DMA.</p>
<p>This function disables DMA request from being generated when FIFO reaches FIFO_TRIG_LEVEL.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Reset FIFO.</p>
<p>This function initializes write and read pointers (FIFO_PTR), number of words (FIFO_STS.WORD_CTR), Write counter of FIFO (FIFO_STS.WR_CTR) to 0.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set FIFO Trigger Level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triggerLevel</td><td>is the FIFO trigger level to be set.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the level of FIFO writes required to trigger INT/DMA. When <em>triggerLevel</em> new writes are received in FIFO after the last trigger, INT/DMA trigger is generated if enabled.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Reset TIMER.</p>
<p>TIMER2 is reset to 0, stopped and restarted.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get FIFO Word Status.</p>
<p>This function gets the number of 64-bit words to be read in the FIFO (current level of FIFO that is filled).</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of 64-bit words to be read in the FIFO.</dd></dl>
<p>Get FIFO Write Status.</p>
<p>This function gets the number of 64-bit words written to the FIFO after the last trigger. This WR_CTR gets reset every time the WR_CTR = FIFO_TRIG_LEVEL.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of 64-bit words written to the FIFO after the last trigger.</dd></dl>
<p>Get FIFO Read Pointer.</p>
<p>This function returns the read pointer location of FIFO.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the read pointer location of FIFO.</dd></dl>
<p>Get FIFO Write Pointer.</p>
<p>This function returns the write pointer location of FIFO.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the write pointer location of FIFO.</dd></dl>
<p>Get TIMER Count.</p>
<p>This function returns the current value of TIMER2. TIMER2 is an internal counter and is exported with REGS. It indicates the time difference from the last reported TAG value.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current value of TIMER2.</dd></dl>
<p>Global Interrupt Status.</p>
<p>This function returns the status of the Global interrupt flag. Reading a 1 on this flag indicates that an interrupt was generated from one of the following events.</p><ul>
<li>TIMER1 overflow</li>
<li>TIMER2 overflow</li>
<li>FIFO overflow</li>
<li>FIFO underflow</li>
<li>FIFO reached Trigger level</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the Global Interrupt Status Flag is set. Returns <b>false</b> otherwise.</dd></dl>
<p>TIMER1 Overflow Status.</p>
<p>This function returns the overflow status of TIMER1. TIMER1 is exported with TAGS and is a 45 bit timer. TIMER1's value is derived from the 64-bit IPC timer outside DLT.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the TIMER1 Overflow Status Flag is set. Returns <b>false</b> otherwise.</dd></dl>
<p>TIMER2 Overflow Status.</p>
<p>This function returns the overflow status of TIMER2. The TIMER2 is exported with REGS.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the TIMER2 Overflow Status Flag is set. Returns <b>false</b> otherwise.</dd></dl>
<p>FIFO Overflow Status.</p>
<p>This function returns the status of FIFO overflow flag. The FIFO overflow flag is set when the FIFO is full and a write is attempted.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the FIFO Overflow Status Flag is set. Returns <b>false</b> otherwise.</dd></dl>
<p>FIFO Underflow Status.</p>
<p>This function returns the status of FIFO underflow flag. The FIFO underflow flag is set when a read is attempted with no data in the FIFO.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the FIFO Underflow Status Flag is set. Returns <b>false</b> otherwise.</dd></dl>
<p>FIFO reached Trigger level status.</p>
<p>This function gets the status of the FIFO whether it has recahed the Trigger level or not. The flag is set when the number of writes in the FIFO reaches the configured trigger level.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the FIFO Trigger level Status Flag is set. Returns <b>false</b> otherwise.</dd></dl>
<p>Enable Interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>can be a bitwise OR of the following events:<ul>
<li>DLT_INT_TIMER1_OVF</li>
<li>DLT_INT_TIMER2_OVF</li>
<li>DLT_INT_FIFO_OVF</li>
<li>DLT_INT_FIFO_UF</li>
<li>DLT_INT_FIFO_TRIG</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>The corresponding events are enabled to generate an interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable Interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>can be a bitwise OR of the following events:<ul>
<li>DLT_INT_TIMER1_OVF</li>
<li>DLT_INT_TIMER2_OVF</li>
<li>DLT_INT_FIFO_OVF</li>
<li>DLT_INT_FIFO_UF</li>
<li>DLT_INT_FIFO_TRIG</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>The corresponding events are disabled to generate an interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Force event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>can be a bitwise OR of the following events:<ul>
<li>DLT_INT_TIMER1_OVF</li>
<li>DLT_INT_TIMER2_OVF</li>
<li>DLT_INT_FIFO_OVF</li>
<li>DLT_INT_FIFO_UF</li>
<li>DLT_INT_FIFO_TRIG</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function forces the corresponding events.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clear Event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>can be a bitwise OR of the following events:<ul>
<li>DLT_INT_INT</li>
<li>DLT_INT_TIMER1_OVF</li>
<li>DLT_INT_TIMER2_OVF</li>
<li>DLT_INT_FIFO_OVF</li>
<li>DLT_INT_FIFO_UF</li>
<li>DLT_INT_FIFO_TRIG</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the corresponding events. Clearing the INT flag will enable further interrupts to be generated if any of the event flags are set to 1.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the Capture event polarity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">event</td><td>is the event number. </td></tr>
    <tr><td class="paramname">polarity</td><td>is the polarity of the event.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the polarity of a given event. The value of event is between <b>ECAP_EVENT_1</b> and <b>ECAP_EVENT_4</b> inclusive corresponding to the four available events.For each event the polarity value determines the edge on which the capture is activated. For a rising edge use a polarity value of <b>ECAP_EVNT_RISING_EDGE</b> and for a falling edge use a polarity of <b>ECAP_EVNT_FALLING_EDGE</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the capture mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">mode</td><td>is the capture mode. </td></tr>
    <tr><td class="paramname">event</td><td>is the event number at which the counter stops or wraps.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the eCAP module to a continuous or one-shot mode. The value of mode should be either <b>ECAP_CONTINUOUS_CAPTURE_MODE</b> or <b>ECAP_ONE_SHOT_CAPTURE_MODE</b> corresponding to continuous or one-shot mode respectively.</p>
<p>The value of event determines the event number at which the counter stops (in one-shot mode) or the counter wraps (in continuous mode). The value of event should be between <b>ECAP_EVENT_1</b> and <b>ECAP_EVENT_4</b> corresponding to the valid event numbers.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Re-arms the eCAP module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function re-arms the eCAP module.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the interrupt source to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets and enables eCAP interrupt source. The following are valid interrupt sources.</p><ul>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_1 - Event 1 generates interrupt</li>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_2 - Event 2 generates interrupt</li>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_3 - Event 3 generates interrupt</li>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_4 - Event 4 generates interrupt</li>
<li>ECAP_ISR_SOURCE_COUNTER_OVERFLOW - Counter overflow generates interrupt</li>
<li>ECAP_ISR_SOURCE_COUNTER_PERIOD - Counter equal period generates interrupt</li>
<li>ECAP_ISR_SOURCE_COUNTER_COMPARE - Counter equal compare generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_1_ERROR_EVT1 - Monitoring unit 1 error event 1 generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_1_ERROR_EVT2 - Monitoring unit 1 error event 2 generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_2_ERROR_EVT1 - Monitoring unit 2 error event 1 generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_2_ERROR_EVT2 - Monitoring unit 2 error event 2 generates interrupt</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the interrupt source to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears and disables eCAP interrupt source. The following are valid interrupt sources.</p><ul>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_1 - Event 1 generates interrupt</li>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_2 - Event 2 generates interrupt</li>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_3 - Event 3 generates interrupt</li>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_4 - Event 4 generates interrupt</li>
<li>ECAP_ISR_SOURCE_COUNTER_OVERFLOW - Counter overflow generates interrupt</li>
<li>ECAP_ISR_SOURCE_COUNTER_PERIOD - Counter equal period generates interrupt</li>
<li>ECAP_ISR_SOURCE_COUNTER_COMPARE - Counter equal compare generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_1_ERROR_EVT1 - Monitoring unit 1 error event 1 generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_1_ERROR_EVT2 - Monitoring unit 1 error event 2 generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_2_ERROR_EVT1 - Monitoring unit 2 error event 1 generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_2_ERROR_EVT2 - Monitoring unit 2 error event 2 generates interrupt</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Returns the interrupt flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the eCAP interrupt flag. The following are valid interrupt sources corresponding to the eCAP interrupt flag.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the eCAP interrupt that has occurred. The following are valid return values.<ul>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_1 - Event 1 generates interrupt</li>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_2 - Event 2 generates interrupt</li>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_3 - Event 3 generates interrupt</li>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_4 - Event 4 generates interrupt</li>
<li>ECAP_ISR_SOURCE_COUNTER_OVERFLOW - Counter overflow generates interrupt</li>
<li>ECAP_ISR_SOURCE_COUNTER_PERIOD - Counter equal period generates interrupt</li>
<li>ECAP_ISR_SOURCE_COUNTER_COMPARE - Counter equal compare generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_1_ERROR_EVT1 - Monitoring unit 1 error event 1 generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_1_ERROR_EVT2 - Monitoring unit 1 error event 2 generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_2_ERROR_EVT1 - Monitoring unit 2 error event 1 generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_2_ERROR_EVT2 - Monitoring unit 2 error event 2 generates interrupt</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>- User can check if a combination of various interrupts have occurred by ORing the above return values.</dd></dl>
<p>Returns the Global interrupt flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the eCAP Global interrupt flag.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if there is a global eCAP interrupt, false otherwise.</dd></dl>
<p>Clears interrupt flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the interrupt source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears eCAP interrupt flags. The following are valid interrupt sources.</p><ul>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_1 - Event 1 generates interrupt</li>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_2 - Event 2 generates interrupt</li>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_3 - Event 3 generates interrupt</li>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_4 - Event 4 generates interrupt</li>
<li>ECAP_ISR_SOURCE_COUNTER_OVERFLOW - Counter overflow generates interrupt</li>
<li>ECAP_ISR_SOURCE_COUNTER_PERIOD - Counter equal period generates interrupt</li>
<li>ECAP_ISR_SOURCE_COUNTER_COMPARE - Counter equal compare generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_1_ERROR_EVT1 - Monitoring unit 1 error event 1 generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_1_ERROR_EVT2 - Monitoring unit 1 error event 2 generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_2_ERROR_EVT1 - Monitoring unit 2 error event 1 generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_2_ERROR_EVT2 - Monitoring unit 2 error event 2 generates interrupt</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clears global interrupt flag</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the global interrupt bit.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Forces interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the interrupt source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function forces and enables eCAP interrupt source. The following are valid interrupt sources.</p><ul>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_1 - Event 1 generates interrupt</li>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_2 - Event 2 generates interrupt</li>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_3 - Event 3 generates interrupt</li>
<li>ECAP_ISR_SOURCE_CAPTURE_EVENT_4 - Event 4 generates interrupt</li>
<li>ECAP_ISR_SOURCE_COUNTER_OVERFLOW - Counter overflow generates interrupt</li>
<li>ECAP_ISR_SOURCE_COUNTER_PERIOD - Counter equal period generates interrupt</li>
<li>ECAP_ISR_SOURCE_COUNTER_COMPARE - Counter equal compare generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_1_ERROR_EVT1 - Monitoring unit 1 error event 1 generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_1_ERROR_EVT2 - Monitoring unit 1 error event 2 generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_2_ERROR_EVT1 - Monitoring unit 2 error event 1 generates interrupt</li>
<li>ECAP_ISR_SOURCE_MUNIT_2_ERROR_EVT2 - Monitoring unit 2 error event 2 generates interrupt</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets eCAP in Capture mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the eCAP module to operate in Capture mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets eCAP in APWM mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the eCAP module to operate in APWM mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables counter reset on an event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">event</td><td>is the event number the time base gets reset.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the base timer, TSCTR, to be reset on capture event provided by the variable event. Valid inputs for event are <b>ECAP_EVENT_1</b> to <b>ECAP_EVENT_4</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables counter reset on events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">event</td><td>is the event number the time base gets reset.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the base timer, TSCTR, from being reset on capture event provided by the variable event. Valid inputs for event are <b>ECAP_EVENT_1</b> to <b>ECAP_EVENT_4</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables time stamp capture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables time stamp count to be captured</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables time stamp capture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables time stamp count to be captured</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets a phase shift value count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">shiftCount</td><td>is the phase shift value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes a phase shift value to be loaded into the main time stamp counter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set up the source for sync-in pulse.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">source</td><td>is the sync-in pulse source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function set the sync out pulse mode. Valid values for mode are:</p><ul>
<li>ECAP_SYNC_IN_PULSE_SRC_SYNCOUT_EPWMx - sync-in pulse source can be any of the EPWMx sync-out signal</li>
<li>ECAP_SYNC_IN_PULSE_SRC_SYNCOUT_ECAPx - sync-in pulse source can be selected as any of the ECAPx sync-out signal</li>
<li>ECAP_SYNC_IN_PULSE_SRC_INPUTXBAR_OUT5-6 - sync-in pulse source can be selected as any of the Input xbar out5-6 signal</li>
<li>ECAP_SYNC_IN_PULSE_SRC_ETHERCAT_SYNC0-1 - sync-in pulse source can be selected as any of the Ethercat sync0-1 signal</li>
<li>ECAP_SYNC_IN_PULSE_SRC_FSI_RXn_RX_TRIG1 - sync-in pulse source can be selected as any of the FSI RXn RX trig signal</li>
<li>ECAP_SYNC_IN_PULSE_SRC_DISABLE - sync-in pulse is disabled for the ECAP module</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable counter loading with phase shift value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables loading of the counter with the value present in the phase shift counter as defined by the ECAP_setPhaseShiftCount() function.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable counter loading with phase shift value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables loading of the counter with the value present in the phase shift counter as defined by the ECAP_setPhaseShiftCount() function.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Load time stamp counter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function forces the value in the phase shift counter register to be loaded into Time stamp counter register. Make sure to enable loading of Time stamp counter by calling ECAP_enableLoadCounter() function before calling this function.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures Sync out signal mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">mode</td><td>is the sync out mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the sync out mode. Valid parameters for mode are:</p><ul>
<li>ECAP_SYNC_OUT_SYNCI - Trigger sync out on sync-in event.</li>
<li>ECAP_SYNC_OUT_COUNTER_PRD - Trigger sync out when counter equals period.</li>
<li>ECAP_SYNC_OUT_DISABLED - Disable sync out.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Stops Time stamp counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function stops the time stamp counter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Starts Time stamp counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function starts the time stamp counter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set eCAP APWM polarity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">polarity</td><td>is the polarity of APWM</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the polarity of the eCAP in APWM mode. Valid inputs for polarity are:</p><ul>
<li>ECAP_APWM_ACTIVE_HIGH - For active high.</li>
<li>ECAP_APWM_ACTIVE_LOW - For active low.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set eCAP APWM period.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">periodCount</td><td>is the period count for APWM.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the period count of the APWM waveform. periodCount takes the actual count which is written to the register. The user is responsible for converting the desired frequency or time into the period count.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set eCAP APWM on or off time count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">compareCount</td><td>is the on or off count for APWM.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the on or off time count of the APWM waveform depending on the polarity of the output. If the output , as set by ECAP_setAPWMPolarity(), is active high then compareCount determines the on time. If the output is active low then compareCount determines the off time. compareCount takes the actual count which is written to the register. The user is responsible for converting the desired frequency or time into the appropriate count value.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Load eCAP APWM shadow period.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">periodCount</td><td>is the shadow period count for APWM.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the shadow period count of the APWM waveform. periodCount takes the actual count which is written to the register. The user is responsible for converting the desired frequency or time into the period count.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set eCAP APWM shadow on or off time count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">compareCount</td><td>is the on or off count for APWM.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the shadow on or off time count of the APWM waveform depending on the polarity of the output. If the output , as set by ECAP_setAPWMPolarity() , is active high then compareCount determines the on time. If the output is active low then compareCount determines the off time. compareCount takes the actual count which is written to the register. The user is responsible for converting the desired frequency or time into the appropriate count value.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Returns the time base counter value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the time base counter value.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the time base counter value.</dd></dl>
<p>Returns event time stamp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">event</td><td>is the event number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current time stamp count of the given event. Valid values for event are <b>ECAP_EVENT_1</b> to <b>ECAP_EVENT_4</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>Event time stamp value or 0 if <em>event</em> is invalid.</dd></dl>
<p>Select eCAP input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">input</td><td>is the eCAP input signal.</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the eCAP input signal.</p>
<p>Please refer to the <a class="el" href="group__ecap__api.html#ga50d62d237fd7f51387dd4a5dea22a0fe">ECAP_InputCaptureSignals</a> Enum for the valid values to be passed to <em>input</em> parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Select qualification period to filter out noise</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">width</td><td>is the pulse width below which the pulse will be filtered out.</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the qualification period to filter out pulses with width less than the mentioned number of cycles.</p>
<p>Please refer to the <a class="el" href="group__ecap__api.html#gae95349d4c4b0588d62e63f9c0e407a14">ECAP_QualPeriodSelect</a> Enum for the valid values to be passed to <em>width</em> parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the eCAP SOC trigger source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">event</td><td>is the eCAP event for the SOC trigger</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the eCAP event source in capture mode and APWM mode for the SOC trigger trigger. Valid values for <em>event</em> are <b>ECAP_EVENT_1</b> to <b>ECAP_EVENT_4</b>.</p>
<p>In capture mode of operation - <b>ECAP_EVENT_1</b> - SOC trigger interrupt source is CEVT1 <b>ECAP_EVENT_2</b> - SOC trigger interrupt source is CEVT2 <b>ECAP_EVENT_3</b> - SOC trigger interrupt source is CEVT3 <b>ECAP_EVENT_4</b> - SOC trigger interrupt source is CEVT4</p>
<p>In APWM mode of operation - <b>ECAP_EVENT_1</b> - SOC trigger interrupt source is period match <b>ECAP_EVENT_2</b> - SOC trigger interrupt source is compare match <b>ECAP_EVENT_3</b> - SOC trigger interrupt source is period or compare match <b>ECAP_EVENT_4</b> - disabled This function sets the eCAP event source for the SOC trigger trigger. Valid values for <em>event</em> are <b>ECAP_EVENT_1</b> to <b>ECAP_EVENT_4</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Resets eCAP counters and flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function resets the main counter (TSCTR register), event filter, modulo counter, capture events and counter overflow flags</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the eCAP DMA source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module. </td></tr>
    <tr><td class="paramname">event</td><td>is the eCAP event for the DMA</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the eCAP event source in capture mode and APWM mode for the DMA trigger. Valid values for <em>event</em> are <b>ECAP_EVENT_1</b> to <b>ECAP_EVENT_4</b>.</p>
<p>In capture mode of operation - <b>ECAP_EVENT_1</b> - DMA interrupt source is CEVT1 <b>ECAP_EVENT_2</b> - DMA interrupt source is CEVT2 <b>ECAP_EVENT_3</b> - DMA interrupt source is CEVT3 <b>ECAP_EVENT_4</b> - DMA interrupt source is CEVT4</p>
<p>In APWM mode of operation - <b>ECAP_EVENT_1</b> - DMA interrupt source is period match <b>ECAP_EVENT_2</b> - DMA interrupt source is compare match <b>ECAP_EVENT_3</b> - DMA interrupt source is period or compare match <b>ECAP_EVENT_4</b> - disabled</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Return the Modulo counter status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the modulo counter status, indicating which register gets loaded on the next capture event.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns an <b>ECAP_EVENT_n</b> value indicating that CAPn is the register to be loaded on the next event.</dd></dl>
<p>Enable eCAP monitoring unit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">munit</td><td>is the monitoring unit, either ECAP_1 or ECAP_2.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the eCAP signal monitoring unit. Valid values for the input variables are:</p><ul>
<li>munit:<ul>
<li>ECAP_MONITORING_UNIT_1 - ECAP Monitoring Unit 1</li>
<li>ECAP_MONITORING_UNIT_2 - ECAP Monitoring Unit 2</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable eCAP monitoring unit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">munit</td><td>is the monitoring unit, either 1 or 2.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the eCAP signal monitoring unit. Valid values for the input variables are:</p><ul>
<li>munit:<ul>
<li>ECAP_MONITORING_UNIT_1 - ECAP Monitoring Unit 1</li>
<li>ECAP_MONITORING_UNIT_2 - ECAP Monitoring Unit 2</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables debug mode to capture range from min to max</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">munit</td><td>is the monitoring unit, either 1 or 2.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the eCAP debug mode for signal monitoring. Range is captured in DEBUG_RANGE_MAX and DEBUG_RANGE_MIN registers.</p>
<p>Valid values for the input variables are:</p><ul>
<li>munit:<ul>
<li>ECAP_MONITORING_UNIT_1 - ECAP Monitoring Unit 1</li>
<li>ECAP_MONITORING_UNIT_2 - ECAP Monitoring Unit 2</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables debug mode to capture range from min to max</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">munit</td><td>is the monitoring unit, either 1 or 2.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the eCAP debug mode for signal monitoring.</p>
<p>Valid values for the input variables are:</p><ul>
<li>munit:<ul>
<li>ECAP_MONITORING_UNIT_1 - ECAP Monitoring Unit 1</li>
<li>ECAP_MONITORING_UNIT_2 - ECAP Monitoring Unit 2</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Setup the early max error check</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">munit</td><td>is the monitoring unit, either 1 or 2. </td></tr>
    <tr><td class="paramname">errorCheck</td><td>is the functionality for early max error check to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>Valid values for the input variables are:</p><ul>
<li>munit:<ul>
<li>ECAP_MONITORING_UNIT_1 - ECAP Monitoring Unit 1</li>
<li>ECAP_MONITORING_UNIT_2 - ECAP Monitoring Unit 2</li>
</ul>
</li>
<li>errorCheck:<ul>
<li>ECAP_PULSE_WIDTH_CROSS_MAX_VALUE - Max error generated as soon as pulse width crosses max value</li>
<li>ECAP_SECOND_EVENT_OCCURED - Max error generated when second event has occured</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Selects the type of monitoring</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">munit</td><td>is the monitoring unit, either 1 or 2. </td></tr>
    <tr><td class="paramname">monSel</td><td>is the type of monitoring to be selected.</td></tr>
  </table>
  </dd>
</dl>
<p>Valid values for the input variables are:</p><ul>
<li>munit:<ul>
<li>ECAP_MONITORING_UNIT_1 - ECAP Monitoring Unit 1</li>
<li>ECAP_MONITORING_UNIT_2 - ECAP Monitoring Unit 2</li>
</ul>
</li>
<li>monSel:<ul>
<li>ECAP_MUNIT_HIGH_PULSE_WIDTH - High Pulse Width</li>
<li>ECAP_MUNIT_LOW_PULSE_WIDTH - Low Pulse Width</li>
<li>ECAP_MUNIT_PERIOD_WIDTH_RISE_RISE - Period width from rise to rise</li>
<li>ECAP_MUNIT_PERIOD_WIDTH_FALL_FALL - Period width from fall to fall</li>
<li>ECAP_MUNIT_MONITOR_RISE_EDGE - Monitor rise edge</li>
<li>ECAP_MUNIT_MONITOR_FALL_EDGE - Monitor fall edge</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Selects the trip signal to disable and enable monitoring automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">tripSel</td><td>is the trip signal.</td></tr>
  </table>
  </dd>
</dl>
<p>Valid values for the input variables are:</p><ul>
<li>tripSel:<ul>
<li>DISABLED</li>
<li>ECAP_MUNIT_TRIP_EPWM_XBARy_OUTn - y is A/B, n is 0-7</li>
<li>ECAP_MUNIT_TRIP_EPWMn_TRIPOUT - n is 1-18</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Selects the global load strobe to enable shadow to active loading</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">strobe</td><td>is the type of monitoring to be selected.</td></tr>
  </table>
  </dd>
</dl>
<p>Valid values for the input variables are:</p><ul>
<li>strobe:<ul>
<li>DISABLED</li>
<li>ECAP_MUNIT_TRIP_EPWM_XBARy_OUTn - y is A/B, n is 0-7</li>
<li>ECAP_MUNIT_TRIP_EPWMn_TRIPOUT - n is 1-18</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables shadowing for min and max registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">munit</td><td>is the monitoring unit, either 1 or 2.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the shadowing feature for min and max registers.</p>
<p>Valid values for the input variable:</p><ul>
<li>munit:<ul>
<li>ECAP_MONITORING_UNIT_1 - ECAP Monitoring Unit 1</li>
<li>ECAP_MONITORING_UNIT_2 - ECAP Monitoring Unit 2</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables shadowing for min and max registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">munit</td><td>is the monitoring unit, either 1 or 2.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the shadowing feature for min and max registers.</p>
<p>Valid values for the input variable:</p><ul>
<li>munit:<ul>
<li>ECAP_MONITORING_UNIT_1 - ECAP Monitoring Unit 1</li>
<li>ECAP_MONITORING_UNIT_2 - ECAP Monitoring Unit 2</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables software sync operation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">munit</td><td>is the monitoring unit, either 1 or 2.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the SW Sync to copy min and max values from shadow to active registers immediately is shadowing is enabled.</p>
<p>Valid values for the input variable:</p><ul>
<li>munit:<ul>
<li>ECAP_MONITORING_UNIT_1 - ECAP Monitoring Unit 1</li>
<li>ECAP_MONITORING_UNIT_2 - ECAP Monitoring Unit 2</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Selects the shadow to active load mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">munit</td><td>is the monitoring unit, either 1 or 2. </td></tr>
    <tr><td class="paramname">loadMode</td><td>is the shadow to active mode to be selected.</td></tr>
  </table>
  </dd>
</dl>
<p>Valid values for the input variables are:</p><ul>
<li>munit:<ul>
<li>ECAP_MONITORING_UNIT_1 - ECAP Monitoring Unit 1</li>
<li>ECAP_MONITORING_UNIT_2 - ECAP Monitoring Unit 2</li>
</ul>
</li>
<li>loadMode:<ul>
<li>ECAP_ACTIVE_LOAD_SYNC_EVT - Active loaded with shadow on next sync event</li>
<li>ECAP_ACTIVE_LOAD_GLDLCSTRB_EVT - Active loaded with shadow on EPWM GLDLCSTRB event</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configure minimum value for monitoring</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">munit</td><td>is the monitoring unit, either 1 or 2. </td></tr>
    <tr><td class="paramname">minValue</td><td>is the minimum value for monitoring. Valid values for the input variables are:<ul>
<li>munit:<ul>
<li>ECAP_MONITORING_UNIT_1 - ECAP Monitoring Unit 1</li>
<li>ECAP_MONITORING_UNIT_2 - ECAP Monitoring Unit 2</li>
</ul>
</li>
<li>minValue:<ul>
<li>Range from 0x0 to 0xFFFFFFFF</li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configure maximum value for monitoring</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">munit</td><td>is the monitoring unit, either 1 or 2. </td></tr>
    <tr><td class="paramname">maxValue</td><td>is the maximum value for monitoring.</td></tr>
  </table>
  </dd>
</dl>
<p>Valid values for the input variables are:</p><ul>
<li>munit:<ul>
<li>ECAP_MONITORING_UNIT_1 - ECAP Monitoring Unit 1</li>
<li>ECAP_MONITORING_UNIT_2 - ECAP Monitoring Unit 2</li>
</ul>
</li>
<li>maxValue:<ul>
<li>Range from 0x0 to 0xFFFFFFFF</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configure minimum value for shadow register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">munit</td><td>is the monitoring unit, either 1 or 2. </td></tr>
    <tr><td class="paramname">minValue</td><td>is the minimum value for monitoring. Valid values for the input variables are:<ul>
<li>munit:<ul>
<li>ECAP_MONITORING_UNIT_1 - ECAP Monitoring Unit 1</li>
<li>ECAP_MONITORING_UNIT_2 - ECAP Monitoring Unit 2</li>
</ul>
</li>
<li>minValue:<ul>
<li>Range from 0x0 to 0xFFFFFFFF</li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configure maximum value for shadow register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">munit</td><td>is the monitoring unit, either 1 or 2. </td></tr>
    <tr><td class="paramname">maxValue</td><td>is the maximum value for monitoring.</td></tr>
  </table>
  </dd>
</dl>
<p>Valid values for the input variables are:</p><ul>
<li>munit:<ul>
<li>ECAP_MONITORING_UNIT_1 - ECAP Monitoring Unit 1</li>
<li>ECAP_MONITORING_UNIT_2 - ECAP Monitoring Unit 2</li>
</ul>
</li>
<li>maxValue:<ul>
<li>Range from 0x0 to 0xFFFFFFFF</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Returns observed minimum value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">munit</td><td>is the monitoring unit, either 1 or 2.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the observed minimum value when the DEBUG_RANGE_EN bit is set to 1.</p>
<p>Valid values for the input variables are:</p><ul>
<li>munit:<ul>
<li>ECAP_MONITORING_UNIT_1 - ECAP Monitoring Unit 1</li>
<li>ECAP_MONITORING_UNIT_2 - ECAP Monitoring Unit 2</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>returns the observed minimum value.</dd></dl>
<p>Returns observed maximum value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ECAP signal monitoring module. </td></tr>
    <tr><td class="paramname">munit</td><td>is the monitoring unit, either 1 or 2.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the observed maximum value when the DEBUG_RANGE_EN bit is set to 1.</p>
<p>Valid values for the input variables are:</p><ul>
<li>munit:<ul>
<li>ECAP_MONITORING_UNIT_1 - ECAP Monitoring Unit 1</li>
<li>ECAP_MONITORING_UNIT_2 - ECAP Monitoring Unit 2</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>returns the observed maximum value.</dd></dl>
<p>Enables the Extended Wait Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
    <tr><td class="paramname">offset</td><td>is the offset of asynchronous chip select of the EMIF instance</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the extended wait mode for an asynchronous external memory.Valid values for param <em>offset</em> can be <em>EMIF_ASYNC_CS2_OFFSET</em>, <em>EMIF_ASYNC_CS3_OFFSET</em> &amp; <em>EMIF_ASYNC_C43_OFFSET</em> for EMIF1 and <em>EMIF_ASYNC_CS2_OFFSET</em> for EMIF2.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the Extended Wait Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
    <tr><td class="paramname">offset</td><td>is the offset of asynchronous chip select of EMIF instance.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the extended wait mode for an asynchronous external memory.Valid values for param <em>offset</em> can be <em>EMIF_ASYNC_CS2_OFFSET</em>, <em>EMIF_ASYNC_CS3_OFFSET</em> &amp; <em>EMIF_ASYNC_C43_OFFSET</em> for EMIF1 and <em>EMIF_ASYNC_CS2_OFFSET</em> for EMIF2.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the wait polarity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
    <tr><td class="paramname">polarity</td><td>is desired wait polarity.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the wait polarity for an asynchronous external memory. Valid values for param <em>polarity</em> can be <em>EMIF_ASYNC_WAIT_POLARITY_LOW</em> or <em>EMIF_ASYNC_WAIT_POLARITY_HIGH</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the Maximum Wait Cycles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
    <tr><td class="paramname">value</td><td>is the desired maximum wait cycles.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the maximum wait cycles for extended asynchronous cycle. Valid values for parameter <em>value</em> lies b/w 0x0U-0xFFU or 0-255.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the Asynchronous Memory Timing Characteristics.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
    <tr><td class="paramname">offset</td><td>is the offset of asynchronous chip select of EMIF instance.</td></tr>
    <tr><td class="paramname">tParam</td><td>is the desired timing parameters.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets timing characteristics for an external asynchronous memory to be interfaced. Valid values for param <em>offset</em> can be <em>EMIF_ASYNC_CS2_OFFSET</em>, <em>EMIF_ASYNC_CS3_OFFSET</em> and <em>EMIF_ASYNC_C43_OFFSET</em> for EMIF1 &amp; EMIF_ASYNC_CS2_OFFSET for EMIF2.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the Asynchronous Data Bus Width.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
    <tr><td class="paramname">offset</td><td>is the offset of asynchronous chip select of EMIF instance.</td></tr>
    <tr><td class="paramname">width</td><td>is the data bus width of the memory.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the data bus size for an external asynchronous memory to be interfaced. Valid values for param <em>offset</em> can be <em>EMIF_ASYNC_CS2_OFFSET</em>, <em>EMIF_ASYNC_CS3_OFFSET</em> &amp; <em>EMIF_ASYNC_C43_OFFSET</em> for EMIF1 and <em>EMIF_ASYNC_CS2_OFFSET</em> for EMIF2. Valid values of param <em>width</em> can be <em>EMIF_ASYNC_DATA_WIDTH_8</em>, <em>EMIF_ASYNC_DATA_WIDTH_16</em> or <em>EMIF_ASYNC_DATA_WIDTH_32</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables the Asynchronous Memory Interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
    <tr><td class="paramname">intFlags</td><td>is the mask for desired interrupts.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the desired interrupts for an external asynchronous memory interface. Valid values for param <em>intFlags</em> can be <b>EMIF_ASYNC_INT_AT</b>, <b>EMIF_ASYNC_INT_LT</b>, <b>EMIF_ASYNC_INT_WR</b> or their combination.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the Asynchronous Memory Interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
    <tr><td class="paramname">intFlags</td><td>is the mask for interrupts to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the desired interrupts for an external asynchronous memory interface. Valid values for param <em>intFlags</em> can be <b>EMIF_ASYNC_INT_AT</b>, <b>EMIF_ASYNC_INT_LT</b>, <b>EMIF_ASYNC_INT_WR</b> or their combination.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the interrupt status for an EMIF instance.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current interrupt status.</dd></dl>
<p>Clears the interrupt status for an EMIF instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
    <tr><td class="paramname">intFlags</td><td>is the mask for the interrupt status to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the interrupt status for an EMIF instance. The <em>intFlags</em> parameter can be any of <b>EMIF_INT_MSK_SET_AT_MASK_SET</b>, <b>EMIF_INT_MSK_SET_LT_MASK_SET</b>, or <b>EMIF_INT_MSK_SET_WR_MASK_SET_M</b> values or their combination.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the Synchronous Memory Timing Parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of an EMIF instance.</td></tr>
    <tr><td class="paramname">tParam</td><td>is parameters from memory datasheet in <em>ns</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the timing characteristics for an external synchronous memory to be interfaced.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the SDRAM Self Refresh Exit Timing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of an EMIF instance.</td></tr>
    <tr><td class="paramname">tXs</td><td>is the desired timing value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the self refresh exit timing for an external synchronous memory to be interfaced. tXs values must lie between 0x0U-0x1FU or 0-31.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the SDR Refresh Rate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of an EMIF instance.</td></tr>
    <tr><td class="paramname">refRate</td><td>is the refresh rate.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the refresh rate for an external synchronous memory to be interfaced. Valid values for refRate lies b/w 0x0U-0x1FFFU or 0-8191.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the Synchronous Memory configuration parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
    <tr><td class="paramname">config</td><td>is the desired configuration parameters.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets configuration parameters like CL, NM, IBANK and PAGESIZE for an external synchronous memory to be interfaced.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables Self Refresh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables Self Refresh Mode for EMIF.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables Self Refresh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables Self Refresh Mode for EMIF.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables Power Down.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Enables Power Down Mode for synchronous memory to be interfaced.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables Power Down.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables Power Down Mode for synchronous memory to be interfaced.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables Refresh in Power Down.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables Refresh in Power Down Mode for synchronous memory to be interfaced.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables Refresh in Power Down.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables Refresh in Power Down Mode for synchronous memory to be interfaced.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets total number of SDRAM accesses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns total number of SDRAM accesses from a controller(CPUx/CPUx.DMA).</p>
<dl class="section return"><dt>Returns</dt><dd><em>Returns</em> total number of accesses to SDRAM.</dd></dl>
<p>Gets total number of SDRAM accesses which require activate command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EMIF instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns total number of accesses to SDRAM which require activate command.</p>
<dl class="section return"><dt>Returns</dt><dd><em>Returns</em> total number of accesses to SDRAM which require activate.</dd></dl>
<p>Disable EPG and stops signal and clock generator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the EPG module and stops signal and clock generator.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Select the EPG output source</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">gPinNum</td><td>is the global EPG Output number. </td></tr>
    <tr><td class="paramname">gPinOutSel</td><td>is the mux output of the <em>gPinNum</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the global EPG output source to be clock or signal. This output can then be routed to any GPIO through xbar, mux sel.</p>
<p>The <em>gPinNum</em> can take any of EPG_OUTX. The <em>gPinOutSel</em> can take any of the EPG_OUT_SEL_CLK, EPG_OUT_SEL_SIG values.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Select the individual EPG pin signal data output</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">gPinNum</td><td>is the global EPG Output number. </td></tr>
    <tr><td class="paramname">sigGenOutput</td><td>is the mux output of the <em>gPinNum</em> signal generators data output.</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the individual EPG pin's signal generator data output. This output can then be routed to EPG global output by selecting signal generator as source for that pin.</p>
<p>The <em>gPinNum</em> can take any of EPG_OUTX. The <em>sigGenOutput</em> can take any of the EPG_SIG_GEN0_DATATRANX values where X is a number from 0 to 7 specifying which data output of sig gen to be used.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Select the individual EPG pin clock data output</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">gPinNum</td><td>is the global EPG Output number. </td></tr>
    <tr><td class="paramname">clkGenOutput</td><td>is the mux output of the <em>gPinNum</em> clock generator's data output.</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the individual EPG pin's clock generator data output. This output can then be routed to EPG global output by selecting clock generator as source for that pin.</p>
<p>The <em>gPinNum</em> can take any of EPG_OUTX. The <em>clkGenOutput</em> can take any of the EPG_CLKGENY_CLKOUTX_DCLK values where X is a number from 0 to 3 specifying which data output of clock gen to be used and Y can be 0 or 1 specifying which clock generator to be used.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Select the signal generator's clock source</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">sigGenNum</td><td>is the Signal generator number whose clk source is being configured based on the availability. </td></tr>
    <tr><td class="paramname">clkGenOutput</td><td>is the mux output of the clock generator's data output to be selected as source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the signal generator's clock source. This clock source is used to generate the periodic or aperiodic signals by the signal generator.</p>
<p>The <em>sigGenNum</em> can take value of 0. The <em>clkGenOutput</em> can take any of the EPG_CLKGENY_CLKOUTX_GCLK values where X is a number from 0 to 3 specifying which data output of clock gen to be used and Y can be 0 or 1 specifying which clock generator to be used</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the clock generator period</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">clkGenNum</td><td>is the clock generator number whose period is being set. </td></tr>
    <tr><td class="paramname">periodValue</td><td>is the period value in number of system clk cycles.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Sets the clock generator's period. Clock divider counter counts up to <em>periodValue</em> and snaps back to 0.</p>
<p>The <em>clkGenNum</em> can take values from 0 to 1 inclusive. The <em>periodValue</em> can take a maximum value of EPG_CLKDIV0_CTL0_PRD_M.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the clock generator stop value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">clkGenNum</td><td>is the clock generator number which is being configured. </td></tr>
    <tr><td class="paramname">stopEdge</td><td>is the Edge signal at which clock stops.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Sets the clock generator's stop value. This determines which of the CLKOUTs edge clock generation is stopped following a clear of SIGGENx_CTL0.EN.</p>
<p>The <em>clkGenNum</em> can take values from 0 to 1 inclusive. The <em>stopEdge</em> can take any of EPG_CLK_STOP_EDGE_CLKOUTX value where X signifies the clock out number varying from 0 to 3 inclusive</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the clock generator clock offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">clkGenNum</td><td>is the clock generator number which is being configured. </td></tr>
    <tr><td class="paramname">clkGenOutputNum</td><td>is the output number of particular clock generator whose offset is being set. </td></tr>
    <tr><td class="paramname">offsetValue</td><td>is the offset value in number of system clk cycles.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Sets the clock generator output's offset. This determines number of source clock cycles by which the divided clock output is delayed.</p>
<p>The <em>clkGenNum</em> can take values from 0 to 1 inclusive. The <em>clkGenOutputNum</em> can take values from 0 to 3 inclusive. The <em>offsetValue</em> can take a maximum value of EPG_CLKDIV0_CLKOFFSET_CLK0OFFSET_M.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable EPG signal generator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">sigGenNum</td><td>is the Signal generator number which is enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the Signal generator after which the signal generator functions as per the mode definition.</p>
<p>The <em>sigGenNum</em> can take value of 0. </p><dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable EPG signal generator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">sigGenNum</td><td>is the Signal generator number which is disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Disables the Signal generator and stops its operation.</p>
<p>The <em>sigGenNum</em> can take value of 0. </p><dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set EPG signal generator Mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">sigGenNum</td><td>is the Signal generator number which is being configured. </td></tr>
    <tr><td class="paramname">sigGenMode</td><td>is the Signal generator mode being set.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Sets the EPG signal generator's Mode. This mode effects the operation of the signal generator on the DATA input.</p>
<p>The <em>sigGenNum</em> can take value of 0. The <em>sigGenMode</em> can take any of the EPG_SIGGEN_MODE_BIT_BANG, EPG_SIGGEN_MODE_SHIFT_RIGHT_ONCE, EPG_SIGGEN_MODE_ROTATE_RIGHT_ONCE, EPG_SIGGEN_MODE_ROTATE_RIGHT_REPEAT, EPG_SIGGEN_MODE_SHIFT_LEFT_ONCE, EPG_SIGGEN_MODE_ROTATE_LEFT_ONCE, EPG_SIGGEN_MODE_ROTATE_LEFT_REPEAT, EPG_SIGGEN_MODE_SHIFT_RIGHT_REPEAT, EPG_SIGGEN_MODE_SHIFT_LEFT_REPEAT values.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Perform bit reversal on input of signal generator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">sigGenNum</td><td>is the Signal generator number which is being configured.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets signal generator to Perform bit reversal on input. This results in bit reversal on data input of data transform block.</p>
<p>The <em>sigGenNum</em> can take value of 0.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable bit reversal on input of signal generator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">sigGenNum</td><td>is the Signal generator number which is being configured.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets signal generator to disable bit reversal on input. This results in no bit reversal on data input of data transform block.</p>
<p>The <em>sigGenNum</em> can take value of 0.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Perform bit reversal on output of signal generator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">sigGenNum</td><td>is the Signal generator number which is being configured.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets signal generator to Perform bit reversal on output. This results in bit reversal on data output of data transform block.</p>
<p>The <em>sigGenNum</em> can take value of 0.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable bit reversal on output of signal generator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">sigGenNum</td><td>is the Signal generator number which is being configured.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets signal generator to disable bit reversal on output. This results in no bit reversal on data output of data transform block.</p>
<p>The <em>sigGenNum</em> can take value of 0.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set EPG signal generators data bit length</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">sigGenNum</td><td>is the Signal generator number which is being configured. </td></tr>
    <tr><td class="paramname">bitLength</td><td>is the number of bits of the signal generator input data.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Sets EPG signal generators data bit length. This defines the number bits which participates in the shift rotate operations.</p>
<p>The <em>sigGenNum</em> can take value of 0. The <em>bitLength</em> can have a maximum value of 64.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set EPG signal generator data bit 0 input</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">sigGenNum</td><td>is the Signal generator number which is being configured. </td></tr>
    <tr><td class="paramname">data0Input</td><td>is the source input of bit 0 of Data Register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Sets EPG signal generator data bit 0 input. This provides the ability to capture the data.</p>
<p>The <em>sigGenNum</em> can take value of 0. The <em>data0Input</em> can take any of the EPG_SIGGEN_DATA0_DATA_NEXT0, EPG_SIGGEN_DATA0_EPGINX values where X can be from 0 to 7 which signifies signal input to the EPG.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set EPG signal generator data bit 63 input</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">sigGenNum</td><td>is the Signal generator number which is being configured. </td></tr>
    <tr><td class="paramname">data0Input</td><td>is the source input of bit 63 of Data Register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Sets EPG signal generator data bit 63 input. This provides the ability to capture the data.</p>
<p>The <em>sigGenNum</em> can take value of 0. The <em>data63Input</em> can take any of the EPG_SIGGEN_DATA63_DATA_NEXT63, EPG_SIGGEN_DATA63_EPGINX values where X can be from 0 to 7 which signifies signal input to the EPG.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Write EPG signal generator data 0 [0:31] input</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">sigGenNum</td><td>is the Signal generator number which is being configured. </td></tr>
    <tr><td class="paramname">data0</td><td>is the first 32 bits of Data Register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Writes EPG signal generator data 0 [0:31] input. This is the Data used in signal bit stream.</p>
<p>The <em>sigGenNum</em> can take value of 0. The <em>data0</em> can take any 32 bit value.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Write EPG signal generator data 1 [32:63] input</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">sigGenNum</td><td>is the Signal generator number which is being configured. </td></tr>
    <tr><td class="paramname">data0</td><td>is the last 32 bits of 63 bit Data Register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Writes EPG signal generator data 1 [32:63] input. This is the Data used in signal bit stream.</p>
<p>The <em>sigGenNum</em> can take value of 0. The <em>data1</em> can take any 32 bit value.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get EPG signal generator data 0 active register [0:31] value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">sigGenNum</td><td>is the Signal generator number which is being configured.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Reads EPG signal generator data 0 active [0:31] value which is the Data resulted from the transformation.</p>
<p>The <em>sigGenNum</em> can take value of 0.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the Data 0 Active register value.</dd></dl>
<p>Get EPG signal generator data 1 active register [32:64] value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">sigGenNum</td><td>is the Signal generator number which is being configured.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Reads EPG signal generator data 1 active [32:64] value which is the Data resulted from the transformation.</p>
<p>The <em>sigGenNum</em> can take value of 0.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the Data 1 Active register value.</dd></dl>
<p>Enable the EPG interrupt sources</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is a bit mask of the interrupt sources to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated EPG interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt. Disabled sources have no effect on the processor.</p>
<p>The <em>intFlags</em> parameter can be any of the <b>EPG_INT_SIGGEN0_DONE</b>, or <b>EPG_INT_SIGGEN0_FILL</b> values.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the EPG interrupt sources</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is a bit mask of the interrupt sources to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated EPG interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt. Disabled sources have no effect on the processor.</p>
<p>The <em>intFlags</em> parameter can be any of the <b>EPG_INT_SIGGEN0_DONE</b>, or <b>EPG_INT_SIGGEN0_FILL</b> values.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get the EPG interrupt sources</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the EPG interrupt sources that are active.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the bit mask of the interrupt sources which are currently triggered.</dd></dl>
<p>Clear EPG Interrupt Sources</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is a bit mask of the interrupt sources to be clear.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the indicated EPG interrupt sources if pending.</p>
<p>The <em>intFlags</em> parameter can be any of the <b>EPG_INT_GLOBAL_INT</b>, <b>EPG_INT_SIGGEN0_DONE</b>, or <b>EPG_INT_SIGGEN0_FILL</b> values.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Force EPG Interrupt Sources</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is a bit mask of the interrupt sources to be trigger.</td></tr>
  </table>
  </dd>
</dl>
<p>This function triggers the indicated EPG interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt. Disabled sources have no effect on the processor.</p>
<p>The <em>intFlags</em> parameter can be any of the <b>EPG_INT_SIGGEN0_DONE</b>, or <b>EPG_INT_SIGGEN0_FILL</b> values.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Lock EPG Register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">regFlags</td><td>is a bit mask of the EPG registers that need to locked.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Locks EPG Register from being written further.</p>
<p>The <em>regFlags</em> parameter can be any of the <b>EPG_LOCK_REG_GCTL0</b>, <b>EPG_LOCK_REG_GCTL1</b>, <b>EPG_LOCK_REG_GCTL2</b> <b>EPG_LOCK_REG_GCTL3</b>, <b>EPG_LOCK_REG_CLKDIV0_CTL0</b>, <b>EPG_LOCK_REG_CLKDIV1_CTL0</b>, <b>EPG_LOCK_REG_SIGGEN0_CTL0</b>, <b>EPG_LOCK_REG_SIGGEN0_CTL1</b> values.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Release Locks of EPG Register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">regFlags</td><td>is a bit mask of EPG registers whose lock to be released.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Releases Locks of EPG Register so they can be overwritten.</p>
<p>The <em>regFlags</em> parameter can be any of the <b>EPG_LOCK_REG_GCTL0</b>, <b>EPG_LOCK_REG_GCTL1</b>, <b>EPG_LOCK_REG_GCTL2</b> <b>EPG_LOCK_REG_GCTL3</b>, <b>EPG_LOCK_REG_CLKDIV0_CTL0</b>, <b>EPG_LOCK_REG_CLKDIV1_CTL0</b>, <b>EPG_LOCK_REG_SIGGEN0_CTL0</b>, <b>EPG_LOCK_REG_SIGGEN0_CTL1</b> values.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Commit EPG registers Lock</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPG module. </td></tr>
    <tr><td class="paramname">regFlags</td><td>is a bit mask of EPG registers whose locks to be commited.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Commits Locks of EPG lock register so that the EPG locks cannot be removed.</p>
<p>The <em>regFlags</em> parameter can be any of the <b>EPG_LOCK_REG_GCTL0</b>, <b>EPG_LOCK_REG_GCTL1</b>, <b>EPG_LOCK_REG_GCTL2</b> <b>EPG_LOCK_REG_GCTL3</b>, <b>EPG_LOCK_REG_CLKDIV0_CTL0</b>, <b>EPG_LOCK_REG_CLKDIV1_CTL0</b>, <b>EPG_LOCK_REG_SIGGEN0_CTL0</b>, <b>EPG_LOCK_REG_SIGGEN0_CTL1</b> values.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Lock EPG Mux Select Register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">muxbase</td><td>is the base address of the EPG Mux module. </td></tr>
    <tr><td class="paramname">regFlags</td><td>is a bit mask of the EPG Mux Select registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Locks EPG Mux Select Register from being written further.</p>
<p>The <em>regFlags</em> parameter can be of the <b>EPG_MX_SEL_LOCK_REG_MXSEL0</b> </p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Release Locks of EPG Mux Select Register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">muxbase</td><td>is the base address of the EPG Mux module. </td></tr>
    <tr><td class="paramname">regFlags</td><td>is a bit mask of the EPG Mux Select registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Releases Locks of EPG Mux Sel Registers to allow overwriting the registers.</p>
<p>The <em>regFlags</em> parameter can be of the <b>EPG_MX_SEL_LOCK_REG_MXSEL0</b> </p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Commit EPG Mux Select Registers Lock</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">muxbase</td><td>is the base address of the EPG Mux module. </td></tr>
    <tr><td class="paramname">regFlags</td><td>is a bit mask of the EPG Mux Select registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function Commits the Locks of EPG Mux Sel Registers so that the locks cannot be updated further.</p>
<p>The <em>regFlags</em> parameter can be of the <b>EPG_MX_SEL_LOCK_REG_MXSEL0</b> </p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set count mode after phase shift sync</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">mode</td><td>is the count mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the time base count to count up or down after a new phase value set by the EPWM_setPhaseShift(). The count direction is determined by the variable mode. Valid inputs for mode are:</p><ul>
<li>EPWM_COUNT_MODE_UP_AFTER_SYNC - Count up after sync</li>
<li>EPWM_COUNT_MODE_DOWN_AFTER_SYNC - Count down after sync</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the time base clock and the high speed time base clock count pre-scaler</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">prescaler</td><td>is the time base count pre scale value. </td></tr>
    <tr><td class="paramname">highSpeedPrescaler</td><td>is the high speed time base count pre scale value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the pre scaler(divider)value for the time base clock counter and the high speed time base clock counter. Valid values for pre-scaler and highSpeedPrescaler are EPWM_CLOCK_DIVIDER_X, where X is 1,2,4,8,16, 32,64 or 128. The actual numerical values for these macros represent values 0,1...7. The equation for the output clock is: TBCLK = EPWMCLK/(highSpeedPrescaler * pre-scaler)</p>
<p><b>Note:</b> EPWMCLK is a scaled version of SYSCLK. At reset EPWMCLK is half SYSCLK.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Force a software sync pulse</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function causes a single software initiated sync pulse. Make sure the appropriate mode is selected using EPWM_setupSyncOutputMode() before using this function.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set up the source for sync-in pulse.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">source</td><td>is the sync-in pulse source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function set the sync out pulse mode. Valid values for mode are:</p><ul>
<li>EPWM_SYNC_IN_PULSE_SRC_SYNCOUT_EPWM1-16 - sync-in pulse source can be any of the EPWM1-16 sync-out signal</li>
<li>EPWM_SYNC_IN_PULSE_SRC_SYNCOUT_ECAP1-7 - sync-in pulse source can be selected as any of the ECAP1-16 sync-out signal</li>
<li>EPWM_SYNC_IN_PULSE_SRC_INPUTXBAR_OUT5-6 - sync-in pulse source can be selected as any of the Input xbar out5-6 signal</li>
<li>EPWM_SYNC_IN_PULSE_SRC_ETHERCAT_SYNC0-1 - sync-in pulse source can be selected as any of the Ethercat sync0-1 signal</li>
<li>EPWM_SYNC_IN_PULSE_SRC_DISABLE - sync-in pulse is disabled for the EPWM module</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables sync-out pulse source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">source</td><td>is the sync-out pulse source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the sync-out pulse source. Below valid values for param <b>source</b> can be OR'd together to enable multiple sync-out sources:</p><ul>
<li>EPWM_SYNC_OUT_PULSE_ON_SOFTWARE - sync-out pulse is generated by software when EPWM_forceSyncPulse() function is called or by EPWMxSYNCI signal.</li>
<li>EPWM_SYNC_OUT_PULSE_ON_CNTR_ZERO - sync-out pulse is generated when time base counter equals zero.</li>
<li>EPWM_SYNC_OUT_PULSE_ON_CNTR_COMPARE_B - sync-out pulse is generated when time base counter equals compare B value.</li>
<li>EPWM_SYNC_OUT_PULSE_ON_CNTR_COMPARE_C - sync-out pulse is generated when time base counter equals compare C value.</li>
<li>EPWM_SYNC_OUT_PULSE_ON_CNTR_COMPARE_D - sync-out pulse is generated when time base counter equals compare D value.</li>
<li>EPWM_SYNC_OUT_PULSE_ON_DCA_EVT1_SYNC - sync-out pulse is generated by DCA event1 sync signal</li>
<li>EPWM_SYNC_OUT_PULSE_ON_DCB_EVT1_SYNC - sync-out pulse is generated by DCB event1 sync signal</li>
<li>EPWM_SYNC_OUT_PULSE_ON_ALL - sync-out pulse is generated by all the above sources</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables sync-out pulse source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">source</td><td>is the sync-out pulse source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the sync-out pulse source. Below valid values for param <b>source</b> can be OR'd together to disable multiple sync-out sources:</p><ul>
<li>EPWM_SYNC_OUT_PULSE_ON_SOFTWARE - disables software as sync-out source</li>
<li>EPWM_SYNC_OUT_PULSE_ON_CNTR_ZERO - disables counter equal to zero event as sync-out source</li>
<li>EPWM_SYNC_OUT_PULSE_ON_CNTR_COMPARE_B - disables counter equal to cmpb event as sync-out source</li>
<li>EPWM_SYNC_OUT_PULSE_ON_CNTR_COMPARE_C - disables counter equal to cmpc event as sync-out source</li>
<li>EPWM_SYNC_OUT_PULSE_ON_CNTR_COMPARE_D - disables counter equal to cmpd event as sync-out source</li>
<li>EPWM_SYNC_OUT_PULSE_ON_DCA_EVT1_SYNC - disables DCA event1 sync signal as sync-out source</li>
<li>EPWM_SYNC_OUT_PULSE_ON_DCB_EVT1_SYNC - disables DCB event1 sync signal as sync-out source</li>
<li>EPWM_SYNC_OUT_PULSE_ON_ALL - disables all the above sync-out sources</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set up the one-shot sync-out trigger source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">trigger</td><td>is the one-shot sync-out signal trigger source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the one-shot sync-out trigger source. Valid values for param <b>trigger</b> are:</p><ul>
<li>EPWM_OSHT_SYNC_OUT_TRIG_SYNC - Trigger for one-shot sync-out signal is one-shot sync event.</li>
<li>EPWM_OSHT_SYNC_OUT_TRIG_RELOAD - Trigger for one-shot sync-out signal is one-shot reload event.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set PWM period load mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">loadMode</td><td>is the PWM period load mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the load mode for the PWM period. If loadMode is set to EPWM_PERIOD_SHADOW_LOAD, a write or read to the TBPRD (PWM Period count register) accesses the shadow register. If loadMode is set to EPWM_PERIOD_DIRECT_LOAD, a write or read to the TBPRD register accesses the register directly.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable phase shift load</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables loading of phase shift when the appropriate sync event occurs.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable phase shift load</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables loading of phase shift.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set time base counter mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">counterMode</td><td>is the time base counter mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the time base counter mode. Valid values for counterMode are:</p><ul>
<li>EPWM_COUNTER_MODE_UP - Up - count mode.</li>
<li>EPWM_COUNTER_MODE_DOWN - Down - count mode.</li>
<li>EPWM_COUNTER_MODE_UP_DOWN - Up - down - count mode.</li>
<li>EPWM_COUNTER_MODE_STOP_FREEZE - Stop - Freeze counter.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set shadow to active period load on sync mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">shadowLoadMode</td><td>is the shadow to active load mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the shadow to active Period register load mode with respect to a sync event. Valid values for shadowLoadMode are:</p><ul>
<li>EPWM_SHADOW_LOAD_MODE_COUNTER_ZERO - shadow to active load occurs when time base counter reaches 0.</li>
<li>EPWM_SHADOW_LOAD_MODE_COUNTER_SYNC - shadow to active load occurs when time base counter reaches 0 and a SYNC occurs.</li>
<li>EPWM_SHADOW_LOAD_MODE_SYNC - shadow to active load occurs only when a SYNC occurs.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable one shot sync mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables one shot sync mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable one shot sync mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables one shot sync mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Start one shot sync mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function propagates a one shot sync pulse.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Returns time base counter value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current value of the time base counter.</p>
<dl class="section return"><dt>Returns</dt><dd>returns time base counter value</dd></dl>
<p>Return time base counter maximum status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the status of the time base max counter.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the counter has reached 0xFFFF. Returns false if the counter hasn't reached 0xFFFF.</dd></dl>
<p>Clear max time base counter event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the max time base counter latch event. The latch event occurs when the time base counter reaches its maximum value of 0xFFFF.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Return external sync signal status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the external sync signal status.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if if an external sync signal event Returns false if there is no event.</dd></dl>
<p>Clear external sync signal event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the external sync signal latch event.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Return time base counter direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the direction of the time base counter.</p>
<dl class="section return"><dt>Returns</dt><dd>returns EPWM_TIME_BASE_STATUS_COUNT_UP if the counter is counting up or EPWM_TIME_BASE_STATUS_COUNT_DOWN if the counter is counting down.</dd></dl>
<p>Sets the phase shift offset counter value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">phaseCount</td><td>is the phase shift count value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the 16 bit time-base counter phase of the ePWM relative to the time-base that is supplying the synchronization input signal. Call the EPWM_enablePhaseShiftLoad() function to enable loading of the phaseCount phase shift value when a sync event occurs.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the PWM period count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">periodCount</td><td>is period count value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the period of the PWM count. The value of periodCount is the value written to the register. User should map the desired period or frequency of the waveform into the correct periodCount. Invoke the function EPWM_selectPeriodLoadEvent() with the appropriate parameter to set the load mode of the Period count. periodCount has a maximum valid value of 0xFFFF</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the PWM period count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the period of the PWM count.</p>
<dl class="section return"><dt>Returns</dt><dd>The period count value.</dd></dl>
<p>Sets up the Counter Compare shadow load mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">compModule</td><td>is the counter compare module. </td></tr>
    <tr><td class="paramname">loadMode</td><td>is the shadow to active load mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables and sets up the counter compare shadow load mode. Valid values for the variables are:</p><ul>
<li>compModule<ul>
<li>EPWM_COUNTER_COMPARE_A - counter compare A.</li>
<li>EPWM_COUNTER_COMPARE_B - counter compare B.</li>
<li>EPWM_COUNTER_COMPARE_C - counter compare C.</li>
<li>EPWM_COUNTER_COMPARE_D - counter compare D.</li>
</ul>
</li>
<li>loadMode<ul>
<li>EPWM_COMP_LOAD_ON_CNTR_ZERO - load when counter equals zero</li>
<li>EPWM_COMP_LOAD_ON_CNTR_PERIOD - load when counter equals period</li>
<li>EPWM_COMP_LOAD_ON_CNTR_ZERO_PERIOD - load when counter equals zero or period</li>
<li>EPWM_COMP_LOAD_FREEZE - Freeze shadow to active load</li>
<li>EPWM_COMP_LOAD_ON_SYNC_CNTR_ZERO - load when counter equals zero</li>
<li>EPWM_COMP_LOAD_ON_SYNC_CNTR_PERIOD -load when counter equals period</li>
<li>EPWM_COMP_LOAD_ON_SYNC_CNTR_ZERO_PERIOD - load when counter equals zero or period</li>
<li>EPWM_COMP_LOAD_ON_SYNC_ONLY - load on sync only</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable Counter Compare shadow load mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">compModule</td><td>is the counter compare module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables counter compare shadow load mode. Valid values for the variables are:</p><ul>
<li>compModule<ul>
<li>EPWM_COUNTER_COMPARE_A - counter compare A.</li>
<li>EPWM_COUNTER_COMPARE_B - counter compare B.</li>
<li>EPWM_COUNTER_COMPARE_C - counter compare C.</li>
<li>EPWM_COUNTER_COMPARE_D - counter compare D.</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set counter compare values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">compModule</td><td>is the Counter Compare value module. </td></tr>
    <tr><td class="paramname">compCount</td><td>is the counter compare count value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the counter compare value for counter compare registers. The maximum value for compCount is 0xFFFF. Valid values for compModule are:</p><ul>
<li>EPWM_COUNTER_COMPARE_A - counter compare A.</li>
<li>EPWM_COUNTER_COMPARE_B - counter compare B.</li>
<li>EPWM_COUNTER_COMPARE_C - counter compare C.</li>
<li>EPWM_COUNTER_COMPARE_D - counter compare D.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get counter compare values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">compModule</td><td>is the Counter Compare value module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the counter compare value for counter compare registers. Valid values for compModule are:</p><ul>
<li>EPWM_COUNTER_COMPARE_A - counter compare A.</li>
<li>EPWM_COUNTER_COMPARE_B - counter compare B.</li>
<li>EPWM_COUNTER_COMPARE_C - counter compare C.</li>
<li>EPWM_COUNTER_COMPARE_D - counter compare D.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The counter compare count value.</dd></dl>
<p>Return the counter compare shadow register full status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">compModule</td><td>is the Counter Compare value module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the counter Compare shadow register full status flag. Valid values for compModule are:</p><ul>
<li>EPWM_COUNTER_COMPARE_A - counter compare A.</li>
<li>EPWM_COUNTER_COMPARE_B - counter compare B.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the shadow register is full. Returns false if the shadow register is not full.</dd></dl>
<p>Enable CMPAHR, CMPBHR register linking</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables CMPAHR and CMPBHR register linking. CMPBHR assumes the same value as CMPAHR.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable CMPAHR, CMPBHR register linking</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables CMPAHR and CMPBHR register linking. CMPAHR and CMPBHR operate independently.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the Action Qualifier shadow load mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">aqModule</td><td>is the Action Qualifier module value. </td></tr>
    <tr><td class="paramname">loadMode</td><td>is the shadow to active load mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables and sets the Action Qualifier shadow load mode. Valid values for the variables are:</p><ul>
<li>aqModule<ul>
<li>EPWM_ACTION_QUALIFIER_A - Action Qualifier A.</li>
<li>EPWM_ACTION_QUALIFIER_B - Action Qualifier B.</li>
</ul>
</li>
<li>loadMode<ul>
<li>EPWM_AQ_LOAD_ON_CNTR_ZERO - load when counter equals zero</li>
<li>EPWM_AQ_LOAD_ON_CNTR_PERIOD - load when counter equals period</li>
<li>EPWM_AQ_LOAD_ON_CNTR_ZERO_PERIOD - load when counter equals zero or period</li>
<li>EPWM_AQ_LOAD_FREEZE - Freeze shadow to active load</li>
<li>EPWM_AQ_LOAD_ON_SYNC_CNTR_ZERO - load on sync or when counter equals zero</li>
<li>EPWM_AQ_LOAD_ON_SYNC_CNTR_PERIOD - load on sync or when counter equals period</li>
<li>EPWM_AQ_LOAD_ON_SYNC_CNTR_ZERO_PERIOD - load on sync or when counter equals zero or period</li>
<li>EPWM_AQ_LOAD_ON_SYNC_ONLY - load on sync only</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable Action Qualifier shadow load mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">aqModule</td><td>is the Action Qualifier module value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the Action Qualifier shadow load mode. Valid values for the variables are:</p><ul>
<li>aqModule<ul>
<li>EPWM_ACTION_QUALIFIER_A - Action Qualifier A.</li>
<li>EPWM_ACTION_QUALIFIER_B - Action Qualifier B.</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set up Action qualifier trigger source for event T1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">trigger</td><td>sources for Action Qualifier triggers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the sources for Action Qualifier event T1. Valid values for trigger are:</p><ul>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_DCA_1 - Digital compare event A 1</li>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_DCA_2 - Digital compare event A 2</li>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_DCB_1 - Digital compare event B 1</li>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_DCB_2 - Digital compare event B 2</li>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_TZ_1 - Trip zone 1</li>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_TZ_2 - Trip zone 2</li>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_TZ_3 - Trip zone 3</li>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_EPWM_SYNCIN - ePWM sync</li>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_DC_EVTFILT - Digital compare filter event</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set up Action qualifier trigger source for event T2</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">trigger</td><td>sources for Action Qualifier triggers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the sources for Action Qualifier event T2. Valid values for trigger are:</p><ul>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_DCA_1 - Digital compare event A 1</li>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_DCA_2 - Digital compare event A 2</li>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_DCB_1 - Digital compare event B 1</li>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_DCB_2 - Digital compare event B 2</li>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_TZ_1 - Trip zone 1</li>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_TZ_2 - Trip zone 2</li>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_TZ_3 - Trip zone 3</li>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_EPWM_SYNCIN - ePWM sync</li>
<li>EPWM_AQ_TRIGGER_EVENT_TRIG_DC_EVTFILT - Digital compare filter event</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set up Action qualifier outputs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">epwmOutput</td><td>is the ePWM pin type. </td></tr>
    <tr><td class="paramname">output</td><td>is the Action Qualifier output. </td></tr>
    <tr><td class="paramname">event</td><td>is the event that causes a change in output.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the Action Qualifier output on ePWM A or ePWMB, depending on the value of epwmOutput, to a value specified by outPut based on the input events - specified by event. The following are valid values for the parameters.</p><ul>
<li>epwmOutput<ul>
<li>EPWM_AQ_OUTPUT_A - ePWMxA output</li>
<li>EPWM_AQ_OUTPUT_B - ePWMxB output</li>
</ul>
</li>
<li>output<ul>
<li>EPWM_AQ_OUTPUT_NO_CHANGE - No change in the output pins</li>
<li>EPWM_AQ_OUTPUT_LOW - Set output pins to low</li>
<li>EPWM_AQ_OUTPUT_HIGH - Set output pins to High</li>
<li>EPWM_AQ_OUTPUT_TOGGLE - Toggle the output pins</li>
</ul>
</li>
<li>event<ul>
<li>EPWM_AQ_OUTPUT_ON_TIMEBASE_ZERO - Time base counter equals zero</li>
<li>EPWM_AQ_OUTPUT_ON_TIMEBASE_PERIOD - Time base counter equals period</li>
<li>EPWM_AQ_OUTPUT_ON_TIMEBASE_UP_CMPA - Time base counter up equals COMPA</li>
<li>EPWM_AQ_OUTPUT_ON_TIMEBASE_DOWN_CMPA - Time base counter down equals COMPA</li>
<li>EPWM_AQ_OUTPUT_ON_TIMEBASE_UP_CMPB - Time base counter up equals COMPB</li>
<li>EPWM_AQ_OUTPUT_ON_TIMEBASE_DOWN_CMPB - Time base counter down equals COMPB</li>
<li>EPWM_AQ_OUTPUT_ON_T1_COUNT_UP - T1 event on count up</li>
<li>EPWM_AQ_OUTPUT_ON_T1_COUNT_DOWN - T1 event on count down</li>
<li>EPWM_AQ_OUTPUT_ON_T2_COUNT_UP - T2 event on count up</li>
<li>EPWM_AQ_OUTPUT_ON_T2_COUNT_DOWN - T2 event on count down</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set up Action qualifier event outputs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">epwmOutput</td><td>is the ePWM pin type. </td></tr>
    <tr><td class="paramname">action</td><td>is the desired action when the specified event occurs</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the Action Qualifier output on ePWMA or ePWMB, depending on the value of epwmOutput, to a value specified by action. Valid action param values from different time base counter scenarios should be OR'd together to configure complete action for a pwm output. The following are valid values for the parameters.</p><ul>
<li>epwmOutput<ul>
<li>EPWM_AQ_OUTPUT_A - ePWMxA output</li>
<li>EPWM_AQ_OUTPUT_B - ePWMxB output</li>
</ul>
</li>
<li>action<ul>
<li>When time base counter equals zero<ul>
<li>EPWM_AQ_OUTPUT_NO_CHANGE_ZERO - Time base counter equals zero and no change in output pins</li>
<li>EPWM_AQ_OUTPUT_LOW_ZERO - Time base counter equals zero and set output pins to low</li>
<li>EPWM_AQ_OUTPUT_HIGH_ZERO - Time base counter equals zero and set output pins to high</li>
<li>EPWM_AQ_OUTPUT_TOGGLE_ZERO - Time base counter equals zero and toggle the output pins</li>
</ul>
</li>
<li>When time base counter equals period<ul>
<li>EPWM_AQ_OUTPUT_NO_CHANGE_PERIOD - Time base counter equals period and no change in output pins</li>
<li>EPWM_AQ_OUTPUT_LOW_PERIOD - Time base counter equals period and set output pins to low</li>
<li>EPWM_AQ_OUTPUT_HIGH_PERIOD - Time base counter equals period and set output pins to high</li>
<li>EPWM_AQ_OUTPUT_TOGGLE_PERIOD - Time base counter equals period and toggle the output pins</li>
</ul>
</li>
<li>When time base counter equals CMPA during up-count<ul>
<li>EPWM_AQ_OUTPUT_NO_CHANGE_UP_CMPA - Time base counter up equals COMPA and no change in the output pins</li>
<li>EPWM_AQ_OUTPUT_LOW_UP_CMPA - Time base counter up equals COMPA and set output pins low</li>
<li>EPWM_AQ_OUTPUT_HIGH_UP_CMPA - Time base counter up equals COMPA and set output pins high</li>
<li>EPWM_AQ_OUTPUT_TOGGLE_UP_CMPA - Time base counter up equals COMPA and toggle output pins</li>
</ul>
</li>
<li>When time base counter equals CMPA during down-count<ul>
<li>EPWM_AQ_OUTPUT_NO_CHANGE_DOWN_CMPA - Time base counter down equals COMPA and no change in the output pins</li>
<li>EPWM_AQ_OUTPUT_LOW_DOWN_CMPA - Time base counter down equals COMPA and set output pins low</li>
<li>EPWM_AQ_OUTPUT_HIGH_DOWN_CMPA - Time base counter down equals COMPA and set output pins high</li>
<li>EPWM_AQ_OUTPUT_TOGGLE_DOWN_CMPA - Time base counter down equals COMPA and toggle output pins</li>
</ul>
</li>
<li>When time base counter equals CMPB during up-count<ul>
<li>EPWM_AQ_OUTPUT_NO_CHANGE_UP_CMPB - Time base counter up equals COMPB and no change in the output pins</li>
<li>EPWM_AQ_OUTPUT_LOW_UP_CMPB - Time base counter up equals COMPB and set output pins low</li>
<li>EPWM_AQ_OUTPUT_HIGH_UP_CMPB - Time base counter up equals COMPB and set output pins high</li>
<li>EPWM_AQ_OUTPUT_TOGGLE_UP_CMPB - Time base counter up equals COMPB and toggle output pins</li>
</ul>
</li>
<li>When time base counter equals CMPB during down-count<ul>
<li>EPWM_AQ_OUTPUT_NO_CHANGE_DOWN_CMPB- Time base counter down equals COMPB and no change in the output pins</li>
<li>EPWM_AQ_OUTPUT_LOW_DOWN_CMPB - Time base counter down equals COMPB and set output pins low</li>
<li>EPWM_AQ_OUTPUT_HIGH_DOWN_CMPB - Time base counter down equals COMPB and set output pins high</li>
<li>EPWM_AQ_OUTPUT_TOGGLE_DOWN_CMPB - Time base counter down equals COMPB and toggle output pins</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><b>note:</b> A logical OR of the valid values should be passed as the action parameter. Single action should be configured for each time base counter scenario.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set up Additional action qualifier event outputs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">epwmOutput</td><td>is the ePWM pin type. </td></tr>
    <tr><td class="paramname">action</td><td>is the desired action when the specified event occurs</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the Additional Action Qualifier output on ePWMA or ePWMB depending on the value of epwmOutput, to a value specified by action. Valid action param values from different event scenarios should be OR'd together to configure complete action for a pwm output. The following are valid values for the parameters.</p><ul>
<li>epwmOutput<ul>
<li>EPWM_AQ_OUTPUT_A - ePWMxA output</li>
<li>EPWM_AQ_OUTPUT_B - ePWMxB output</li>
</ul>
</li>
<li>action<ul>
<li>When T1 event occurs during up-count<ul>
<li>EPWM_AQ_OUTPUT_NO_CHANGE_UP_T1 - T1 event on count up and no change in output pins</li>
<li>EPWM_AQ_OUTPUT_LOW_UP_T1 - T1 event on count up and set output pins to low</li>
<li>EPWM_AQ_OUTPUT_HIGH_UP_T1 - T1 event on count up and set output pins to high</li>
<li>EPWM_AQ_OUTPUT_TOGGLE_UP_T1 - T1 event on count up and toggle the output pins</li>
</ul>
</li>
<li>When T1 event occurs during down-count<ul>
<li>EPWM_AQ_OUTPUT_NO_CHANGE_DOWN_T1- T1 event on count down and no change in output pins</li>
<li>EPWM_AQ_OUTPUT_LOW_DOWN_T1 - T1 event on count down and set output pins to low</li>
<li>EPWM_AQ_OUTPUT_HIGH_DOWN_T1 - T1 event on count down and set output pins to high</li>
<li>EPWM_AQ_OUTPUT_TOGGLE_DOWN_T1 - T1 event on count down and toggle the output pins</li>
</ul>
</li>
<li>When T2 event occurs during up-count<ul>
<li>EPWM_AQ_OUTPUT_NO_CHANGE_UP_T2 - T2 event on count up and no change in output pins</li>
<li>EPWM_AQ_OUTPUT_LOW_UP_T2 - T2 event on count up and set output pins to low</li>
<li>EPWM_AQ_OUTPUT_HIGH_UP_T2 - T2 event on count up and set output pins to high</li>
<li>EPWM_AQ_OUTPUT_TOGGLE_UP_T2 - T2 event on count up and toggle the output pins</li>
</ul>
</li>
<li>When T2 event occurs during down-count<ul>
<li>EPWM_AQ_OUTPUT_NO_CHANGE_DOWN_T2 - T2 event on count down and no change in output pins</li>
<li>EPWM_AQ_OUTPUT_LOW_DOWN_T2 - T2 event on count down and set output pins to low</li>
<li>EPWM_AQ_OUTPUT_HIGH_DOWN_T2 - T2 event on count down and set output pins to high</li>
<li>EPWM_AQ_OUTPUT_TOGGLE_DOWN_T2 - T2 event on count down and toggle the output pins</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><b>note:</b> A logical OR of the valid values should be passed as the action parameter. Single action should be configured for each event scenario.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets up Action qualifier continuous software load mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">mode</td><td>is the mode for shadow to active load mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the AQCFRSC register load mode for continuous software force reload mode. The software force actions are determined by the EPWM_setActionQualifierContSWForceAction() function. Valid values for mode are:</p><ul>
<li>EPWM_AQ_SW_SH_LOAD_ON_CNTR_ZERO - shadow mode load when counter equals zero</li>
<li>EPWM_AQ_SW_SH_LOAD_ON_CNTR_PERIOD - shadow mode load when counter equals period</li>
<li>EPWM_AQ_SW_SH_LOAD_ON_CNTR_ZERO_PERIOD - shadow mode load when counter equals zero or period</li>
<li>EPWM_AQ_SW_IMMEDIATE_LOAD - immediate mode load only</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Triggers a continuous software forced event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">epwmOutput</td><td>is the ePWM pin type. </td></tr>
    <tr><td class="paramname">output</td><td>is the Action Qualifier output.</td></tr>
  </table>
  </dd>
</dl>
<p>This function triggers a continuous software forced Action Qualifier output on ePWM A or B based on the value of epwmOutput. Valid values for the parameters are:</p><ul>
<li>epwmOutput<ul>
<li>EPWM_AQ_OUTPUT_A - ePWMxA output</li>
<li>EPWM_AQ_OUTPUT_B - ePWMxB output</li>
</ul>
</li>
<li>output<ul>
<li>EPWM_AQ_SW_DISABLED - Software forcing disabled.</li>
<li>EPWM_AQ_SW_OUTPUT_LOW - Set output pins to low</li>
<li>EPWM_AQ_SW_OUTPUT_HIGH - Set output pins to High</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set up one time software forced Action qualifier outputs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">epwmOutput</td><td>is the ePWM pin type. </td></tr>
    <tr><td class="paramname">output</td><td>is the Action Qualifier output.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the one time software forced Action Qualifier output on ePWM A or ePWMB, depending on the value of epwmOutput to a value specified by outPut. The following are valid values for the parameters.</p><ul>
<li>epwmOutput<ul>
<li>EPWM_AQ_OUTPUT_A - ePWMxA output</li>
<li>EPWM_AQ_OUTPUT_B - ePWMxB output</li>
</ul>
</li>
<li>output<ul>
<li>EPWM_AQ_OUTPUT_NO_CHANGE - No change in the output pins</li>
<li>EPWM_AQ_OUTPUT_LOW - Set output pins to low</li>
<li>EPWM_AQ_OUTPUT_HIGH - Set output pins to High</li>
<li>EPWM_AQ_OUTPUT_TOGGLE - Toggle the output pins</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Triggers a one time software forced event on Action qualifier</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">epwmOutput</td><td>is the ePWM pin type.</td></tr>
  </table>
  </dd>
</dl>
<p>This function triggers a one time software forced Action Qualifier event on ePWM A or B based on the value of epwmOutput. Valid values for epwmOutput are:</p><ul>
<li>EPWM_AQ_OUTPUT_A - ePWMxA output</li>
<li>EPWM_AQ_OUTPUT_B - ePWMxB output</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets Dead Band signal output swap mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">output</td><td>is the ePWM Dead Band output. </td></tr>
    <tr><td class="paramname">enableSwapMode</td><td>is the output swap mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the output signal swap mode. For example if the output variable is set to EPWM_DB_OUTPUT_A and enableSwapMode is true, then the ePWM A output gets its signal from the ePWM B signal path. Valid values for the input variables are:</p><ul>
<li>output<ul>
<li>EPWM_DB_OUTPUT_A - ePWM output A</li>
<li>EPWM_DB_OUTPUT_B - ePWM output B</li>
</ul>
</li>
<li>enableSwapMode<ul>
<li>true - the output is swapped</li>
<li>false - the output and the signal path are the same.</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets Dead Band signal output mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">delayMode</td><td>is the Dead Band delay type. </td></tr>
    <tr><td class="paramname">enableDelayMode</td><td>is the dead band delay mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the dead band delay mode. The delayMode variable determines if the applied delay is Rising Edge or Falling Edge. The enableDelayMode determines if a dead band delay should be applied. Valid values for the variables are:</p><ul>
<li>delayMode<ul>
<li>EPWM_DB_RED - Rising Edge delay</li>
<li>EPWM_DB_FED - Falling Edge delay</li>
</ul>
</li>
<li>enableDelayMode<ul>
<li>true - Falling edge or Rising edge delay is applied.</li>
<li>false - Dead Band delay is bypassed.</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets Dead Band delay polarity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">delayMode</td><td>is the Dead Band delay type. </td></tr>
    <tr><td class="paramname">polarity</td><td>is the polarity of the delayed signal.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the polarity as determined by the variable polarity of the Falling Edge or Rising Edge delay depending on the value of delayMode. Valid values for the variables are:</p><ul>
<li>delayMode<ul>
<li>EPWM_DB_RED - Rising Edge delay</li>
<li>EPWM_DB_FED - Falling Edge delay</li>
</ul>
</li>
<li>polarity<ul>
<li>EPWM_DB_POLARITY_ACTIVE_HIGH - polarity is not inverted.</li>
<li>EPWM_DB_POLARITY_ACTIVE_LOW - polarity is inverted.</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets Rising Edge Dead Band delay input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">input</td><td>is the input signal to the dead band.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the rising Edge delay input signal. Valid values for input are:</p><ul>
<li>EPWM_DB_INPUT_EPWMA - Input signal is ePWMA( Valid for both Falling Edge and Rising Edge)</li>
<li>EPWM_DB_INPUT_EPWMB - Input signal is ePWMB( Valid for both Falling Edge and Rising Edge)</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets Dead Band delay input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">input</td><td>is the input signal to the dead band.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the rising Edge delay input signal. Valid values for input are:</p><ul>
<li>EPWM_DB_INPUT_EPWMA - Input signal is ePWMA(Valid for both Falling Edge and Rising Edge)</li>
<li>EPWM_DB_INPUT_EPWMB - Input signal is ePWMB(Valid for both Falling Edge and Rising Edge)</li>
<li>EPWM_DB_INPUT_DB_RED - Input signal is the output of Rising Edge delay. (Valid only for Falling Edge delay)</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the Dead Band control shadow load mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">loadMode</td><td>is the shadow to active load mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables and sets the Dead Band control register shadow load mode. Valid values for the <em>loadMode</em> parameter are:</p><ul>
<li>EPWM_DB_LOAD_ON_CNTR_ZERO - load when counter equals zero.</li>
<li>EPWM_DB_LOAD_ON_CNTR_PERIOD - load when counter equals period.</li>
<li>EPWM_DB_LOAD_ON_CNTR_ZERO_PERIOD - load when counter equals zero or period.</li>
<li>EPWM_DB_LOAD_FREEZE - Freeze shadow to active load.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable Dead Band control shadow load mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the Dead Band control register shadow load mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the RED (Rising Edge Delay) shadow load mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">loadMode</td><td>is the shadow to active load event.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the Rising Edge Delay register shadow load mode. Valid values for the <em>loadMode</em> parameter are:</p><ul>
<li>EPWM_RED_LOAD_ON_CNTR_ZERO - load when counter equals zero.</li>
<li>EPWM_RED_LOAD_ON_CNTR_PERIOD - load when counter equals period.</li>
<li>EPWM_RED_LOAD_ON_CNTR_ZERO_PERIOD - load when counter equals zero or period.</li>
<li>EPWM_RED_LOAD_FREEZE - Freeze shadow to active load.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable the RED (Rising Edge Delay) shadow load mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the Rising Edge Delay register shadow load mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the FED (Falling Edge Delay) shadow load mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">loadMode</td><td>is the shadow to active load event.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables and sets the Falling Edge Delay register shadow load mode. Valid values for the <em>loadMode</em> parameters are:</p><ul>
<li>EPWM_FED_LOAD_ON_CNTR_ZERO - load when counter equals zero.</li>
<li>EPWM_FED_LOAD_ON_CNTR_PERIOD - load when counter equals period.</li>
<li>EPWM_FED_LOAD_ON_CNTR_ZERO_PERIOD - load when counter equals zero or period.</li>
<li>EPWM_FED_LOAD_FREEZE - Freeze shadow to active load.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the FED (Falling Edge Delay) shadow load mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the Falling Edge Delay register shadow load mode. Valid values for the parameters are:</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets Dead Band Counter clock rate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">clockMode</td><td>is the Dead Band counter clock mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the Dead Band counter clock rate with respect to TBCLK (ePWM time base counter). Valid values for clockMode are:</p><ul>
<li>EPWM_DB_COUNTER_CLOCK_FULL_CYCLE -Dead band counter runs at TBCLK (ePWM Time Base Counter) rate.</li>
<li>EPWM_DB_COUNTER_CLOCK_HALF_CYCLE -Dead band counter runs at 2*TBCLK (twice ePWM Time Base Counter)rate.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set ePWM RED count</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">redCount</td><td>is the RED(Rising Edge Delay) count.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the RED (Rising Edge Delay) count value. The value of redCount should be less than 0x4000U.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set ePWM FED count</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">fedCount</td><td>is the FED(Falling Edge Delay) count.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the FED (Falling Edge Delay) count value. The value of fedCount should be less than 0x4000U.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable chopper mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables ePWM chopper module.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable chopper mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables ePWM chopper module.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set chopper duty cycle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">dutyCycleCount</td><td>is the chopping clock duty cycle count.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the chopping clock duty cycle. The value of dutyCycleCount should be less than 7. The dutyCycleCount value is converted to the actual chopper duty cycle value base on the following equation: chopper duty cycle = (dutyCycleCount + 1) / 8</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set chopper clock frequency scaler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">freqDiv</td><td>is the chopping clock frequency divider.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the scaler for the chopping clock frequency. The value of freqDiv should be less than 8. The chopping clock frequency is altered based on the following equation. chopper clock frequency = SYSCLKOUT / ( 1 + freqDiv)</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set chopper clock frequency scaler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">firstPulseWidth</td><td>is the width of the first pulse.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the first pulse width of chopper output waveform. The value of firstPulseWidth should be less than 0x10. The value of the first pulse width in seconds is given using the following equation: first pulse width = 1 / (((firstPulseWidth + 1) * SYSCLKOUT)/8)</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables Trip Zone signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">tzSignal</td><td>is the Trip Zone signal.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the Trip Zone signals specified by tzSignal as a source for the Trip Zone module. Valid values for tzSignal are:</p><ul>
<li>EPWM_TZ_SIGNAL_CBC1 - TZ1 Cycle By Cycle</li>
<li>EPWM_TZ_SIGNAL_CBC2 - TZ2 Cycle By Cycle</li>
<li>EPWM_TZ_SIGNAL_CBC3 - TZ3 Cycle By Cycle</li>
<li>EPWM_TZ_SIGNAL_CBC4 - TZ4 Cycle By Cycle</li>
<li>EPWM_TZ_SIGNAL_CBC5 - TZ5 Cycle By Cycle</li>
<li>EPWM_TZ_SIGNAL_CBC6 - TZ6 Cycle By Cycle</li>
<li>EPWM_TZ_SIGNAL_DCAEVT2 - DCAEVT2 Cycle By Cycle</li>
<li>EPWM_TZ_SIGNAL_DCBEVT2 - DCBEVT2 Cycle By Cycle</li>
<li>EPWM_TZ_SIGNAL_OSHT1 - One-shot TZ1</li>
<li>EPWM_TZ_SIGNAL_OSHT2 - One-shot TZ2</li>
<li>EPWM_TZ_SIGNAL_OSHT3 - One-shot TZ3</li>
<li>EPWM_TZ_SIGNAL_OSHT4 - One-shot TZ4</li>
<li>EPWM_TZ_SIGNAL_OSHT5 - One-shot TZ5</li>
<li>EPWM_TZ_SIGNAL_OSHT6 - One-shot TZ6</li>
<li>EPWM_TZ_SIGNAL_DCAEVT1 - One-shot DCAEVT1</li>
<li>EPWM_TZ_SIGNAL_DCBEVT1 - One-shot DCBEVT1</li>
</ul>
<p><b>note:</b> A logical OR of the valid values can be passed as the tzSignal parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables Trip Zone signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">tzSignal</td><td>is the Trip Zone signal.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the Trip Zone signal specified by tzSignal as a source for the Trip Zone module. Valid values for tzSignal are:</p><ul>
<li>EPWM_TZ_SIGNAL_CBC1 - TZ1 Cycle By Cycle</li>
<li>EPWM_TZ_SIGNAL_CBC2 - TZ2 Cycle By Cycle</li>
<li>EPWM_TZ_SIGNAL_CBC3 - TZ3 Cycle By Cycle</li>
<li>EPWM_TZ_SIGNAL_CBC4 - TZ4 Cycle By Cycle</li>
<li>EPWM_TZ_SIGNAL_CBC5 - TZ5 Cycle By Cycle</li>
<li>EPWM_TZ_SIGNAL_CBC6 - TZ6 Cycle By Cycle</li>
<li>EPWM_TZ_SIGNAL_DCAEVT2 - DCAEVT2 Cycle By Cycle</li>
<li>EPWM_TZ_SIGNAL_DCBEVT2 - DCBEVT2 Cycle By Cycle</li>
<li>EPWM_TZ_SIGNAL_OSHT1 - One-shot TZ1</li>
<li>EPWM_TZ_SIGNAL_OSHT2 - One-shot TZ2</li>
<li>EPWM_TZ_SIGNAL_OSHT3 - One-shot TZ3</li>
<li>EPWM_TZ_SIGNAL_OSHT4 - One-shot TZ4</li>
<li>EPWM_TZ_SIGNAL_OSHT5 - One-shot TZ5</li>
<li>EPWM_TZ_SIGNAL_OSHT6 - One-shot TZ6</li>
<li>EPWM_TZ_SIGNAL_DCAEVT1 - One-shot DCAEVT1</li>
<li>EPWM_TZ_SIGNAL_DCBEVT1 - One-shot DCBEVT1</li>
</ul>
<p><b>note:</b> A logical OR of the valid values can be passed as the tzSignal parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set Digital compare conditions that cause Trip Zone event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">dcType</td><td>is the Digital compare output type. </td></tr>
    <tr><td class="paramname">dcEvent</td><td>is the Digital Compare output event.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the Digital Compare output Trip Zone event sources. The dcType variable specifies the event source to be whether Digital Compare output A or Digital Compare output B. The dcEvent parameter specifies the event that causes Trip Zone. Valid values for the parameters are:</p><ul>
<li>dcType<ul>
<li>EPWM_TZ_DC_OUTPUT_A1 - Digital Compare output 1 A</li>
<li>EPWM_TZ_DC_OUTPUT_A2 - Digital Compare output 2 A</li>
<li>EPWM_TZ_DC_OUTPUT_B1 - Digital Compare output 1 B</li>
<li>EPWM_TZ_DC_OUTPUT_B2 - Digital Compare output 2 B</li>
</ul>
</li>
<li>dcEvent<ul>
<li>EPWM_TZ_EVENT_DC_DISABLED - Event Trigger is disabled</li>
<li>EPWM_TZ_EVENT_DCXH_LOW - Trigger event when DCxH low</li>
<li>EPWM_TZ_EVENT_DCXH_HIGH - Trigger event when DCxH high</li>
<li>EPWM_TZ_EVENT_DCXL_LOW - Trigger event when DCxL low</li>
<li>EPWM_TZ_EVENT_DCXL_HIGH - Trigger event when DCxL high</li>
<li>EPWM_TZ_EVENT_DCXL_HIGH_DCXH_LOW - Trigger event when DCxL high DCxH low</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>x in DCxH/DCxL represents DCAH/DCAL or DCBH/DCBL</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable advanced Trip Zone event Action.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the advanced actions of the Trip Zone events. The advanced features combine the trip zone events with the direction of the counter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable advanced Trip Zone event Action.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the advanced actions of the Trip Zone events.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set Trip Zone Action.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">tzEvent</td><td>is the Trip Zone event type. </td></tr>
    <tr><td class="paramname">tzAction</td><td>is the Trip zone Action.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the Trip Zone Action to be taken when a Trip Zone event occurs. Valid values for the parameters are:</p><ul>
<li>tzEvent<ul>
<li>EPWM_TZ_ACTION_EVENT_DCBEVT2 - DCBEVT2 (Digital Compare B event 2)</li>
<li>EPWM_TZ_ACTION_EVENT_DCBEVT1 - DCBEVT1 (Digital Compare B event 1)</li>
<li>EPWM_TZ_ACTION_EVENT_DCAEVT2 - DCAEVT2 (Digital Compare A event 2)</li>
<li>EPWM_TZ_ACTION_EVENT_DCAEVT1 - DCAEVT1 (Digital Compare A event 1)</li>
<li>EPWM_TZ_ACTION_EVENT_TZB - TZ1 - TZ6, DCBEVT2, DCBEVT1</li>
<li>EPWM_TZ_ACTION_EVENT_TZA - TZ1 - TZ6, DCAEVT2, DCAEVT1</li>
</ul>
</li>
<li>tzAction<ul>
<li>EPWM_TZ_ACTION_HIGH_Z - high impedance output</li>
<li>EPWM_TZ_ACTION_HIGH - high output</li>
<li>EPWM_TZ_ACTION_LOW - low low</li>
<li>EPWM_TZ_ACTION_DISABLE - disable action</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Disable the advanced Trip Zone event using EPWM_disableTripZoneAdvAction() before calling this function. </dd>
<dd>
This function operates on both ePWMA and ePWMB depending on the tzEvent parameter.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set Advanced Trip Zone Action.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">tzAdvEvent</td><td>is the Trip Zone event type. </td></tr>
    <tr><td class="paramname">tzAdvAction</td><td>is the Trip zone Action.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the Advanced Trip Zone Action to be taken when an advanced Trip Zone event occurs.</p>
<p>Valid values for the parameters are:</p><ul>
<li>tzAdvEvent<ul>
<li>EPWM_TZ_ADV_ACTION_EVENT_TZB_D - TZ1 - TZ6, DCBEVT2, DCBEVT1 while counting down</li>
<li>EPWM_TZ_ADV_ACTION_EVENT_TZB_U - TZ1 - TZ6, DCBEVT2, DCBEVT1 while counting up</li>
<li>EPWM_TZ_ADV_ACTION_EVENT_TZA_D - TZ1 - TZ6, DCAEVT2, DCAEVT1 while counting down</li>
<li>EPWM_TZ_ADV_ACTION_EVENT_TZA_U - TZ1 - TZ6, DCAEVT2, DCAEVT1 while counting up</li>
</ul>
</li>
<li>tzAdvAction<ul>
<li>EPWM_TZ_ADV_ACTION_HIGH_Z - high impedance output</li>
<li>EPWM_TZ_ADV_ACTION_HIGH - high voltage state</li>
<li>EPWM_TZ_ADV_ACTION_LOW - low voltage state</li>
<li>EPWM_TZ_ADV_ACTION_TOGGLE - Toggle output</li>
<li>EPWM_TZ_ADV_ACTION_DISABLE - disable action</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function enables the advanced Trip Zone event.</dd>
<dd>
This function operates on both ePWMA and ePWMB depending on the tzAdvEvent parameter. </dd>
<dd>
Advanced Trip Zone events take into consideration the direction of the counter in addition to Trip Zone events.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set Advanced Digital Compare Trip Zone Action on ePWMA.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">tzAdvDCEvent</td><td>is the Digital Compare Trip Zone event type. </td></tr>
    <tr><td class="paramname">tzAdvDCAction</td><td>is the Digital Compare Trip zone Action.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the Digital Compare (DC) Advanced Trip Zone Action to be taken on ePWMA when an advanced Digital Compare Trip Zone A event occurs. Valid values for the parameters are:</p><ul>
<li>tzAdvDCEvent<ul>
<li>EPWM_TZ_ADV_ACTION_EVENT_DCxEVT2_D - Digital Compare event A2 while counting down</li>
<li>EPWM_TZ_ADV_ACTION_EVENT_DCxEVT2_U - Digital Compare event A2 while counting up</li>
<li>EPWM_TZ_ADV_ACTION_EVENT_DCxEVT1_D - Digital Compare event A1 while counting down</li>
<li>EPWM_TZ_ADV_ACTION_EVENT_DCxEVT1_U - Digital Compare event A1 while counting up</li>
</ul>
</li>
<li>tzAdvDCAction<ul>
<li>EPWM_TZ_ADV_ACTION_HIGH_Z - high impedance output</li>
<li>EPWM_TZ_ADV_ACTION_HIGH - high voltage state</li>
<li>EPWM_TZ_ADV_ACTION_LOW - low voltage state</li>
<li>EPWM_TZ_ADV_ACTION_TOGGLE - Toggle output</li>
<li>EPWM_TZ_ADV_ACTION_DISABLE - disable action</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function enables the advanced Trip Zone event.</dd>
<dd>
Advanced Trip Zone events take into consideration the direction of the counter in addition to Digital Compare Trip Zone events.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set Advanced Digital Compare Trip Zone Action on ePWMB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">tzAdvDCEvent</td><td>is the Digital Compare Trip Zone event type. </td></tr>
    <tr><td class="paramname">tzAdvDCAction</td><td>is the Digital Compare Trip zone Action.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the Digital Compare (DC) Advanced Trip Zone Action to be taken on ePWMB when an advanced Digital Compare Trip Zone B event occurs. Valid values for the parameters are:</p><ul>
<li>tzAdvDCEvent<ul>
<li>EPWM_TZ_ADV_ACTION_EVENT_DCxEVT2_D - Digital Compare event B2 while counting down</li>
<li>EPWM_TZ_ADV_ACTION_EVENT_DCxEVT2_U - Digital Compare event B2 while counting up</li>
<li>EPWM_TZ_ADV_ACTION_EVENT_DCxEVT1_D - Digital Compare event B1 while counting down</li>
<li>EPWM_TZ_ADV_ACTION_EVENT_DCxEVT1_U - Digital Compare event B1 while counting up</li>
</ul>
</li>
<li>tzAdvDCAction<ul>
<li>EPWM_TZ_ADV_ACTION_HIGH_Z - high impedance output</li>
<li>EPWM_TZ_ADV_ACTION_HIGH - high voltage state</li>
<li>EPWM_TZ_ADV_ACTION_LOW - low voltage state</li>
<li>EPWM_TZ_ADV_ACTION_TOGGLE - Toggle output</li>
<li>EPWM_TZ_ADV_ACTION_DISABLE - disable action</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function enables the advanced Trip Zone event.</dd>
<dd>
Advanced Trip Zone events take into consideration the direction of the counter in addition to Digital Compare Trip Zone events.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable Trip Zone interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">tzInterrupt</td><td>is the Trip Zone interrupt.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the Trip Zone interrupts. Valid values for tzInterrupt are:</p><ul>
<li>EPWM_TZ_INTERRUPT_CBC - Trip Zones Cycle By Cycle interrupt</li>
<li>EPWM_TZ_INTERRUPT_OST - Trip Zones One Shot interrupt</li>
<li>EPWM_TZ_INTERRUPT_DCAEVT1 - Digital Compare A Event 1 interrupt</li>
<li>EPWM_TZ_INTERRUPT_DCAEVT2 - Digital Compare A Event 2 interrupt</li>
<li>EPWM_TZ_INTERRUPT_DCBEVT1 - Digital Compare B Event 1 interrupt</li>
<li>EPWM_TZ_INTERRUPT_DCBEVT2 - Digital Compare B Event 2 interrupt</li>
<li>EPWM_TZ_INTERRUPT_CAPEVT - Trip Zones Capture Event interrupt</li>
</ul>
<p><b>note:</b> A logical OR of the valid values can be passed as the tzInterrupt parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable Trip Zone interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">tzInterrupt</td><td>is the Trip Zone interrupt.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the Trip Zone interrupts. Valid values for tzInterrupt are:</p><ul>
<li>EPWM_TZ_INTERRUPT_CBC - Trip Zones Cycle By Cycle interrupt</li>
<li>EPWM_TZ_INTERRUPT_OST - Trip Zones One Shot interrupt</li>
<li>EPWM_TZ_INTERRUPT_DCAEVT1 - Digital Compare A Event 1 interrupt</li>
<li>EPWM_TZ_INTERRUPT_DCAEVT2 - Digital Compare A Event 2 interrupt</li>
<li>EPWM_TZ_INTERRUPT_DCBEVT1 - Digital Compare B Event 1 interrupt</li>
<li>EPWM_TZ_INTERRUPT_DCBEVT2 - Digital Compare B Event 2 interrupt</li>
<li>EPWM_TZ_INTERRUPT_CAPEVT - Trip Zones Capture Event interrupt</li>
</ul>
<p><b>note:</b> A logical OR of the valid values can be passed as the tzInterrupt parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the Trip Zone status flag</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the Trip Zone status flag.</p>
<dl class="section return"><dt>Returns</dt><dd>The function returns the following or the bitwise OR value of the following values.<ul>
<li>EPWM_TZ_INTERRUPT - Trip Zone interrupt was generated due to the following TZ events.</li>
<li>EPWM_TZ_FLAG_CBC - Trip Zones Cycle By Cycle event status flag</li>
<li>EPWM_TZ_FLAG_OST - Trip Zones One Shot event status flag</li>
<li>EPWM_TZ_FLAG_DCAEVT1 - Digital Compare A Event 1 status flag</li>
<li>EPWM_TZ_FLAG_DCAEVT2 - Digital Compare A Event 2 status flag</li>
<li>EPWM_TZ_FLAG_DCBEVT1 - Digital Compare B Event 1 status flag</li>
<li>EPWM_TZ_FLAG_DCBEVT2 - Digital Compare B Event 2 status flag</li>
<li>EPWM_TZ_FLAG_CAPEVT - Trip Zones Capture Event flag</li>
</ul>
</dd></dl>
<p>Gets the Trip Zone Cycle by Cycle flag status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the specific Cycle by Cycle Trip Zone flag status.</p>
<dl class="section return"><dt>Returns</dt><dd>The function returns the following values.<ul>
<li>EPWM_TZ_CBC_FLAG_1 - CBC 1 status flag</li>
<li>EPWM_TZ_CBC_FLAG_2 - CBC 2 status flag</li>
<li>EPWM_TZ_CBC_FLAG_3 - CBC 3 status flag</li>
<li>EPWM_TZ_CBC_FLAG_4 - CBC 4 status flag</li>
<li>EPWM_TZ_CBC_FLAG_5 - CBC 5 status flag</li>
<li>EPWM_TZ_CBC_FLAG_6 - CBC 6 status flag</li>
<li>EPWM_TZ_CBC_FLAG_DCAEVT2 - CBC status flag for Digital compare event A2</li>
<li>EPWM_TZ_CBC_FLAG_DCBEVT2 - CBC status flag for Digital compare event B2</li>
<li>EPWM_TZ_CBC_FLAG_CAPEVT - CBC status flag for capture event</li>
</ul>
</dd></dl>
<p>Gets the Trip Zone One Shot flag status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the specific One Shot Trip Zone flag status.</p>
<dl class="section return"><dt>Returns</dt><dd>The function returns the bitwise OR of the following flags.<ul>
<li>EPWM_TZ_OST_FLAG_OST1 - OST status flag for OST1</li>
<li>EPWM_TZ_OST_FLAG_OST2 - OST status flag for OST2</li>
<li>EPWM_TZ_OST_FLAG_OST3 - OST status flag for OST3</li>
<li>EPWM_TZ_OST_FLAG_OST4 - OST status flag for OST4</li>
<li>EPWM_TZ_OST_FLAG_OST5 - OST status flag for OST5</li>
<li>EPWM_TZ_OST_FLAG_OST6 - OST status flag for OST6</li>
<li>EPWM_TZ_OST_FLAG_DCAEVT1 - OST status flag for Digital compare event A1</li>
<li>EPWM_TZ_OST_FLAG_DCBEVT1 - OST status flag for Digital compare event B1</li>
<li>EPWM_TZ_OST_FLAG_CAPEVT - OST status flag for capture event</li>
</ul>
</dd></dl>
<p>Set the Trip Zone CBC pulse clear event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">clearEvent</td><td>is the CBC trip zone clear event.</td></tr>
  </table>
  </dd>
</dl>
<p>This function set the event which automatically clears the CBC (Cycle by Cycle) latch. Valid values for clearEvent are:</p><ul>
<li>EPWM_TZ_CBC_PULSE_CLR_CNTR_ZERO - Clear CBC pulse when counter equals zero</li>
<li>EPWM_TZ_CBC_PULSE_CLR_CNTR_PERIOD - Clear CBC pulse when counter equals period</li>
<li>EPWM_TZ_CBC_PULSE_CLR_CNTR_ZERO_PERIOD - Clear CBC pulse when counter equals zero or period</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clear Trip Zone flag</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">tzFlags</td><td>is the Trip Zone flags.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the Trip Zone flags Valid values for tzFlags are:</p><ul>
<li>EPWM_TZ_INTERRUPT - Global Trip Zone interrupt flag</li>
<li>EPWM_TZ_FLAG_CBC - Trip Zones Cycle By Cycle flag</li>
<li>EPWM_TZ_FLAG_OST - Trip Zones One Shot flag</li>
<li>EPWM_TZ_FLAG_DCAEVT1 - Digital Compare A Event 1 flag</li>
<li>EPWM_TZ_FLAG_DCAEVT2 - Digital Compare A Event 2 flag</li>
<li>EPWM_TZ_FLAG_DCBEVT1 - Digital Compare B Event 1 flag</li>
<li>EPWM_TZ_FLAG_DCBEVT2 - Digital Compare B Event 2 flag</li>
<li>EPWM_TZ_FLAG_CAPEVT - Trip Zones Capture Event flag</li>
</ul>
<p><b>note:</b> A bitwise OR of the valid values can be passed as the tzFlags parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clear the Trip Zone Cycle by Cycle flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">tzCBCFlags</td><td>is the CBC flag to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the specific Cycle by Cycle Trip Zone flag. The following are valid values for tzCBCFlags.</p><ul>
<li>EPWM_TZ_CBC_FLAG_1 - CBC 1 flag</li>
<li>EPWM_TZ_CBC_FLAG_2 - CBC 2 flag</li>
<li>EPWM_TZ_CBC_FLAG_3 - CBC 3 flag</li>
<li>EPWM_TZ_CBC_FLAG_4 - CBC 4 flag</li>
<li>EPWM_TZ_CBC_FLAG_5 - CBC 5 flag</li>
<li>EPWM_TZ_CBC_FLAG_6 - CBC 6 flag</li>
<li>EPWM_TZ_CBC_FLAG_DCAEVT2 - CBC flag Digital compare event A2</li>
<li>EPWM_TZ_CBC_FLAG_DCBEVT2 - CBC flag Digital compare event B2</li>
<li>EPWM_TZ_CBC_FLAG_CAPEVT - CBC flag capture event</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clear the Trip Zone One Shot flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">tzOSTFlags</td><td>is the OST flags to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the specific One Shot (OST) Trip Zone flag. The following are valid values for tzOSTFlags.</p><ul>
<li>EPWM_TZ_OST_FLAG_OST1 - OST flag for OST1</li>
<li>EPWM_TZ_OST_FLAG_OST2 - OST flag for OST2</li>
<li>EPWM_TZ_OST_FLAG_OST3 - OST flag for OST3</li>
<li>EPWM_TZ_OST_FLAG_OST4 - OST flag for OST4</li>
<li>EPWM_TZ_OST_FLAG_OST5 - OST flag for OST5</li>
<li>EPWM_TZ_OST_FLAG_OST6 - OST flag for OST6</li>
<li>EPWM_TZ_OST_FLAG_DCAEVT1 - OST flag for Digital compare event A1</li>
<li>EPWM_TZ_OST_FLAG_DCBEVT1 - OST flag for Digital compare event B1</li>
<li>EPWM_TZ_OST_FLAG_CAPEVT - OST flag capture event</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Force Trip Zone events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">tzForceEvent</td><td>is the forced Trip Zone event.</td></tr>
  </table>
  </dd>
</dl>
<p>This function forces a Trip Zone event. Valid values for tzForceEvent are:</p><ul>
<li>EPWM_TZ_FORCE_EVENT_CBC - Force Trip Zones Cycle By Cycle event</li>
<li>EPWM_TZ_FORCE_EVENT_OST - Force Trip Zones One Shot Event</li>
<li>EPWM_TZ_FORCE_EVENT_DCAEVT1 - Force Digital Compare A Event 1</li>
<li>EPWM_TZ_FORCE_EVENT_DCAEVT2 - Force Digital Compare A Event 2</li>
<li>EPWM_TZ_FORCE_EVENT_DCBEVT1 - Force Digital Compare B Event 1</li>
<li>EPWM_TZ_FORCE_EVENT_DCBEVT2 - Force Digital Compare B Event 2</li>
<li>EPWM_TZ_FORCE_EVENT_CAPEVT - Force Capture Event</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Select TRIPOUT signals for the ePWM module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">tzTripOut</td><td>is the trip zone event to be selected.</td></tr>
  </table>
  </dd>
</dl>
<p>Valid values for <em>tzTripOut</em> are:</p><ul>
<li>EPWM_TZ_TRIPOUT_CBC - CBC as TRIPOUT source</li>
<li>EPWM_TZ_TRIPOUT_OST - OST as TRIPOUT source</li>
<li>EPWM_TZ_TRIPOUT_TZ[1-6] - TZx as TRIPOUT source</li>
<li>EPWM_TZ_TRIPOUT_DCAEVT1 - DCAEVT1 as TRIPOUT source</li>
<li>EPWM_TZ_TRIPOUT_DCAEVT2 - DCAEVT2 as TRIPOUT source</li>
<li>EPWM_TZ_TRIPOUT_DCBEVT1 - DCBEVT1 as TRIPOUT source</li>
<li>EPWM_TZ_TRIPOUT_DCBEVT2 - DCBEVT2 as TRIPOUT source</li>
<li>EPWM_TZ_TRIPOUT_CAPEVT - Capture Event as TRIPOUT source</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables TRIPOUT signals for the ePWM module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">tzTripOut</td><td>is the trip zone event to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>Valid values for <em>tzTripOut</em> are:</p><ul>
<li>EPWM_TZ_TRIPOUT_CBC - CBC as TRIPOUT source</li>
<li>EPWM_TZ_TRIPOUT_OST - OST as TRIPOUT source</li>
<li>EPWM_TZ_TRIPOUT_TZ[1-6] - TZx as TRIPOUT source</li>
<li>EPWM_TZ_TRIPOUT_DCAEVT1 - DCAEVT1 as TRIPOUT source</li>
<li>EPWM_TZ_TRIPOUT_DCAEVT2 - DCAEVT2 as TRIPOUT source</li>
<li>EPWM_TZ_TRIPOUT_DCBEVT1 - DCBEVT1 as TRIPOUT source</li>
<li>EPWM_TZ_TRIPOUT_DCBEVT2 - DCBEVT2 as TRIPOUT source</li>
<li>EPWM_TZ_TRIPOUT_CAPEVT - Capture Event as TRIPOUT source</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable ePWM interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the ePWM interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>disable ePWM interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the ePWM interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the ePWM interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">interruptSource</td><td>is the ePWM interrupt source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the ePWM interrupt source. Valid values for interruptSource are:</p><ul>
<li>EPWM_INT_TBCTR_DISABLED - Time-base counter is disabled</li>
<li>EPWM_INT_TBCTR_ZERO - Time-base counter equal to zero</li>
<li>EPWM_INT_TBCTR_PERIOD - Time-base counter equal to period</li>
<li>EPWM_INT_TBCTR_ZERO_OR_PERIOD - Time-base counter equal to zero or period</li>
<li>EPWM_INT_TBCTR_ETINTMIX - Time-base counter based on mixed events (ETINTMIX)</li>
<li>EPWM_INT_TBCTR_U_CMPx - Where x is A,B,C or D Time-base counter equal to CMPA, CMPB, CMPC or CMPD (depending the value of x) when the timer is incrementing</li>
<li>EPWM_INT_TBCTR_D_CMPx - Where x is A,B,C or D Time-base counter equal to CMPA, CMPB, CMPC or CMPD (depending the value of x) when the timer is decrementing</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the ePWM interrupt event counts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">eventCount</td><td>is the event count for interrupt scale</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the interrupt event count that determines the number of events that have to occur before an interrupt is issued. Maximum value for eventCount is 15.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Return the interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the ePWM interrupt status. <b>Note</b> This function doesn't return the Trip Zone status.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if ePWM interrupt was generated. Returns false if no interrupt was generated</dd></dl>
<p>Clear interrupt flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the ePWM interrupt flag.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Enable Pre-interrupt count load.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the ePWM interrupt counter to be pre-interrupt loaded with a count value.</p>
<dl class="section note"><dt>Note</dt><dd>This is valid only for advanced/expanded interrupt mode</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable interrupt count load.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the ePWM interrupt counter from being loaded with pre-interrupt count value.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Force a software pre interrupt event counter load.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function forces the ePWM interrupt counter to be loaded with the contents set by EPWM_setPreInterruptEventCount().</p>
<dl class="section note"><dt>Note</dt><dd>make sure the EPWM_enablePreInterruptEventCountLoad() function is is called before invoking this function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set interrupt count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">eventCount</td><td>is the ePWM interrupt count value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the ePWM interrupt count. eventCount is the value of the pre-interrupt value that is to be loaded. The maximum value of eventCount is 15.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get the interrupt count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the ePWM interrupt event count.</p>
<dl class="section return"><dt>Returns</dt><dd>The interrupt event counts that have occurred.</dd></dl>
<p>Force ePWM interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function forces an ePWM interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Sets the mixed event trigger interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">etmixSignal</td><td>is the module for which trigger needs to be enabled. </td></tr>
    <tr><td class="paramname">interruptSource</td><td>is the Mixed ET interrupt source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the ePWM interrupt source. Valid values for etmixSignal are:</p><ul>
<li>EPWM_ETMIX_INTERRUPT - Mixed ET Interrupt signal</li>
<li>EPWM_ETMIX_SOCA - Mixed ET SOCA signal</li>
<li>EPWM_ETMIX_SOCB - Mixed ET SOCB signal Valid values for interruptSource are:</li>
<li>EPWM_ETMIX_TBCTR_ZERO - Time-base counter equal to zero</li>
<li>EPWM_ETMIX_TBCTR_PERIOD - Time-base counter equal to period</li>
<li>EPWM_ETMIX_TBCTR_U_CMPx - Where x is A,B,C or D Time-base counter equal to CMPA, CMPB, CMPC or CMPD (depending the value of x) when the timer is incrementing</li>
<li>EPWM_ETMIX_TBCTR_D_CMPx - Where x is A,B,C or D Time-base counter equal to CMPA, CMPB, CMPC or CMPD (depending the value of x) when the timer is decrementing</li>
<li>EPWM_ETMIX_DCAEVT1 - DCAEVT1 interrupt signal to trigger mixed ET interrupt</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable ADC SOC event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">adcSOCType</td><td>is the ADC SOC type.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the ePWM module to trigger an ADC SOC event. Valid values for adcSOCType are:</p><ul>
<li>EPWM_SOC_A - SOC A</li>
<li>EPWM_SOC_B - SOC B</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable ADC SOC event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">adcSOCType</td><td>is the ADC SOC type.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the ePWM module from triggering an ADC SOC event. Valid values for adcSOCType are:</p><ul>
<li>EPWM_SOC_A - SOC A</li>
<li>EPWM_SOC_B - SOC B</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the ePWM SOC source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the EPWM module. </td></tr>
    <tr><td class="paramname">adcSOCType</td><td>is the ADC SOC type. </td></tr>
    <tr><td class="paramname">socSource</td><td>is the SOC source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the ePWM ADC SOC source. Valid values for socSource are:</p><ul>
<li>adcSOCType<ul>
<li>EPWM_SOC_A - SOC A</li>
<li>EPWM_SOC_B - SOC B</li>
</ul>
</li>
<li>socSource<ul>
<li>EPWM_SOC_DCxEVT1 - Event is based on DCxEVT1</li>
<li>EPWM_SOC_TBCTR_ZERO - Time-base counter equal to zero</li>
<li>EPWM_SOC_TBCTR_PERIOD - Time-base counter equal to period</li>
<li>EPWM_SOC_TBCTR_ETSOCAMIX - Time-base counter based on mixed events (ETSOCAMIX)</li>
<li>EPWM_SOC_TBCTR_U_CMPx - Where x is A,B,C or D Time-base counter equal to CMPA, CMPB, CMPC or CMPD(depending the value of x) when the timer is incrementing</li>
<li>EPWM_SOC_TBCTR_D_CMPx - Where x is A,B,C or D Time-base counter equal to CMPA, CMPB, CMPC or CMPD(depending the value of x) when the timer is decrementing</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the eQEP module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the enhanced quadrature encoder pulse (eQEP) module</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables operation of the eQEP module.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures eQEP module's quadrature decoder unit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">config</td><td>is the configuration for the eQEP module decoder unit.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the operation of the eQEP module's quadrature decoder unit. The <em>config</em> parameter provides the configuration of the decoder and is the logical OR of several values:</p>
<ul>
<li><b>EQEP_CONFIG_2X_RESOLUTION</b> or <b>EQEP_CONFIG_1X_RESOLUTION</b> specify if both rising and falling edges should be counted or just rising edges.</li>
<li><b>EQEP_CONFIG_QUADRATURE</b>, <b>EQEP_CONFIG_CLOCK_DIR</b>, <b>EQEP_CONFIG_UP_COUNT</b>, or <b>EQEP_CONFIG_DOWN_COUNT</b> specify if quadrature signals are being provided on QEPA and QEPB, if a direction signal and a clock are being provided, or if the direction should be hard-wired for a single direction with QEPA used for input.</li>
<li><b>EQEP_CONFIG_NO_SWAP</b> or <b>EQEP_CONFIG_SWAP</b> to specify if the signals provided on QEPA and QEPB should be swapped before being processed.</li>
<li><b>EQEP_CONFIG_IGATE_DISABLE</b> or <b>EQEP_CONFIG_IGATE_ENABLE</b> to specify if the gating of the index pulse should be enabled or disabled</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures eQEP module position counter unit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">mode</td><td>is the configuration for the eQEP module position counter. </td></tr>
    <tr><td class="paramname">maxPosition</td><td>specifies the maximum position value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the operation of the eQEP module position counter. The <em>mode</em> parameter determines the event on which the position counter gets reset. It should be passed one of the following values: <b>EQEP_POSITION_RESET_IDX</b>, <b>EQEP_POSITION_RESET_MAX_POS</b>, <b>EQEP_POSITION_RESET_1ST_IDX</b>, or <b>EQEP_POSITION_RESET_UNIT_TIME_OUT</b>.</p>
<p><em>maxPosition</em> is the maximum value of the position counter and is the value used to reset the position capture when moving in the reverse (negative) direction.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the current encoder position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current position of the encoder. Depending upon the configuration of the encoder, and the incident of an index pulse, this value may or may not contain the expected data (that is, if in reset on index mode, if an index pulse has not been encountered, the position counter is not yet aligned with the index pulse).</p>
<dl class="section return"><dt>Returns</dt><dd>The current position of the encoder.</dd></dl>
<p>Sets the current encoder position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">position</td><td>is the new position for the encoder.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the current position of the encoder; the encoder position is then measured relative to this value.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the current direction of rotation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current direction of rotation. In this case, current means the most recently detected direction of the encoder; it may not be presently moving but this is the direction it last moved before it stopped.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if moving in the forward direction or -1 if moving in the reverse direction.</dd></dl>
<p>Enables individual eQEP module interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is a bit mask of the interrupt sources to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables eQEP module interrupt sources. The <em>intFlags</em> parameter can be any of the following values OR'd together:</p><ul>
<li><b>EQEP_INT_POS_CNT_ERROR</b> - Position counter error</li>
<li><b>EQEP_INT_PHASE_ERROR</b> - Quadrature phase error</li>
<li><b>EQEP_INT_DIR_CHANGE</b> - Quadrature direction change</li>
<li><b>EQEP_INT_WATCHDOG</b> - Watchdog time-out</li>
<li><b>EQEP_INT_UNDERFLOW</b> - Position counter underflow</li>
<li><b>EQEP_INT_OVERFLOW</b> - Position counter overflow</li>
<li><b>EQEP_INT_POS_COMP_READY</b> - Position-compare ready</li>
<li><b>EQEP_INT_POS_COMP_MATCH</b> - Position-compare match</li>
<li><b>EQEP_INT_STROBE_EVNT_LATCH</b> - Strobe event latch</li>
<li><b>EQEP_INT_INDEX_EVNT_LATCH</b> - Index event latch</li>
<li><b>EQEP_INT_UNIT_TIME_OUT</b> - Unit time-out</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables individual eQEP module interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is a bit mask of the interrupt sources to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables eQEP module interrupt sources. The <em>intFlags</em> parameter can be any of the following values OR'd together:</p><ul>
<li><b>EQEP_INT_POS_CNT_ERROR</b> - Position counter error</li>
<li><b>EQEP_INT_PHASE_ERROR</b> - Quadrature phase error</li>
<li><b>EQEP_INT_DIR_CHANGE</b> - Quadrature direction change</li>
<li><b>EQEP_INT_WATCHDOG</b> - Watchdog time-out</li>
<li><b>EQEP_INT_UNDERFLOW</b> - Position counter underflow</li>
<li><b>EQEP_INT_OVERFLOW</b> - Position counter overflow</li>
<li><b>EQEP_INT_POS_COMP_READY</b> - Position-compare ready</li>
<li><b>EQEP_INT_POS_COMP_MATCH</b> - Position-compare match</li>
<li><b>EQEP_INT_STROBE_EVNT_LATCH</b> - Strobe event latch</li>
<li><b>EQEP_INT_INDEX_EVNT_LATCH</b> - Index event latch</li>
<li><b>EQEP_INT_UNIT_TIME_OUT</b> - Unit time-out</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the current interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the interrupt status for the eQEP module module.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current interrupt status, enumerated as a bit field of the following values:<ul>
<li><b>EQEP_INT_GLOBAL</b> - Global interrupt flag</li>
<li><b>EQEP_INT_POS_CNT_ERROR</b> - Position counter error</li>
<li><b>EQEP_INT_PHASE_ERROR</b> - Quadrature phase error</li>
<li><b>EQEP_INT_DIR_CHANGE</b> - Quadrature direction change</li>
<li><b>EQEP_INT_WATCHDOG</b> - Watchdog time-out</li>
<li><b>EQEP_INT_UNDERFLOW</b> - Position counter underflow</li>
<li><b>EQEP_INT_OVERFLOW</b> - Position counter overflow</li>
<li><b>EQEP_INT_POS_COMP_READY</b> - Position-compare ready</li>
<li><b>EQEP_INT_POS_COMP_MATCH</b> - Position-compare match</li>
<li><b>EQEP_INT_STROBE_EVNT_LATCH</b> - Strobe event latch</li>
<li><b>EQEP_INT_INDEX_EVNT_LATCH</b> - Index event latch</li>
<li><b>EQEP_INT_UNIT_TIME_OUT</b> - Unit time-out</li>
</ul>
</dd></dl>
<p>Clears eQEP module interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is a bit mask of the interrupt sources to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears eQEP module interrupt flags. The <em>intFlags</em> parameter can be any of the following values OR'd together:</p><ul>
<li><b>EQEP_INT_GLOBAL</b> - Global interrupt flag</li>
<li><b>EQEP_INT_POS_CNT_ERROR</b> - Position counter error</li>
<li><b>EQEP_INT_PHASE_ERROR</b> - Quadrature phase error</li>
<li><b>EQEP_INT_DIR_CHANGE</b> - Quadrature direction change</li>
<li><b>EQEP_INT_WATCHDOG</b> - Watchdog time-out</li>
<li><b>EQEP_INT_UNDERFLOW</b> - Position counter underflow</li>
<li><b>EQEP_INT_OVERFLOW</b> - Position counter overflow</li>
<li><b>EQEP_INT_POS_COMP_READY</b> - Position-compare ready</li>
<li><b>EQEP_INT_POS_COMP_MATCH</b> - Position-compare match</li>
<li><b>EQEP_INT_STROBE_EVNT_LATCH</b> - Strobe event latch</li>
<li><b>EQEP_INT_INDEX_EVNT_LATCH</b> - Index event latch</li>
<li><b>EQEP_INT_UNIT_TIME_OUT</b> - Unit time-out</li>
</ul>
<p>Note that the <b>EQEP_INT_GLOBAL</b> value is the global interrupt flag. In order to get any further eQEP interrupts, this flag must be cleared.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Forces individual eQEP module interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is a bit mask of the interrupt sources to be forced.</td></tr>
  </table>
  </dd>
</dl>
<p>This function forces eQEP module interrupt flags. The <em>intFlags</em> parameter can be any of the following values OR'd together:</p><ul>
<li><b>EQEP_INT_POS_CNT_ERROR</b> </li>
<li><b>EQEP_INT_PHASE_ERROR</b> </li>
<li><b>EQEP_INT_DIR_CHANGE</b> </li>
<li><b>EQEP_INT_WATCHDOG</b> </li>
<li><b>EQEP_INT_UNDERFLOW</b> </li>
<li><b>EQEP_INT_OVERFLOW</b> </li>
<li><b>EQEP_INT_POS_COMP_READY</b> </li>
<li><b>EQEP_INT_POS_COMP_MATCH</b> </li>
<li><b>EQEP_INT_STROBE_EVNT_LATCH</b> </li>
<li><b>EQEP_INT_INDEX_EVNT_LATCH</b> </li>
<li><b>EQEP_INT_UNIT_TIME_OUT</b> </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the encoder error indicator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the error indicator for the eQEP module. It is an error for both of the signals of the quadrature input to change at the same time.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if an error has occurred and <b>false</b> otherwise.</dd></dl>
<p>Returns content of the eQEP module status register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the contents of the status register. The value it returns is an OR of the following values:</p>
<ul>
<li><b>EQEP_STS_UNIT_POS_EVNT</b> - Unit position event detected</li>
<li><b>EQEP_STS_DIR_ON_1ST_IDX</b> - If set, clockwise rotation (forward movement) occurred on the first index event</li>
<li><b>EQEP_STS_DIR_FLAG</b> - If set, movement is clockwise rotation</li>
<li><b>EQEP_STS_DIR_LATCH</b> - If set, clockwise rotation occurred on last index event marker</li>
<li><b>EQEP_STS_CAP_OVRFLW_ERROR</b> - Overflow occurred in eQEP capture timer</li>
<li><b>EQEP_STS_CAP_DIR_ERROR</b> - Direction change occurred between position capture events</li>
<li><b>EQEP_STS_1ST_IDX_FLAG</b> - Set by the occurrence of the first index pulse</li>
<li><b>EQEP_STS_POS_CNT_ERROR</b> - Position counter error occurred</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of the QEP status register.</dd></dl>
<p>Clears selected fields of the eQEP module status register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">statusFlags</td><td>is the bit mask of the status flags to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the status register fields indicated by <em>statusFlags</em>. The <em>statusFlags</em> parameter is the logical OR of any of the following:</p>
<ul>
<li><b>EQEP_STS_UNIT_POS_EVNT</b> - Unit position event detected</li>
<li><b>EQEP_STS_CAP_OVRFLW_ERROR</b> - Overflow occurred in eQEP capture timer</li>
<li><b>EQEP_STS_CAP_DIR_ERROR</b> - Direction change occurred between position capture events</li>
<li><b>EQEP_STS_1ST_IDX_FLAG</b> - Set by the occurrence of the first index pulse</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Only the above status fields can be cleared. All others are read-only, non-sticky fields.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures eQEP module edge-capture unit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">capPrescale</td><td>is the prescaler setting of the eQEP capture timer clk. </td></tr>
    <tr><td class="paramname">evntPrescale</td><td>is the prescaler setting of the unit position event frequency.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the operation of the eQEP module edge-capture unit. The <em>capPrescale</em> parameter provides the configuration of the eQEP capture timer clock rate. It determines by which power of 2 between 1 and 128 inclusive SYSCLKOUT is divided. The macros for this parameter are in the format of EQEP_CAPTURE_CLK_DIV_X, where X is the divide value. For example, <b>EQEP_CAPTURE_CLK_DIV_32</b> will give a capture timer clock frequency that is SYSCLKOUT/32.</p>
<p>The <em>evntPrescale</em> parameter determines how frequently a unit position event occurs. The macro that can be passed this parameter is in the format EQEP_UNIT_POS_EVNT_DIV_X, where X is the number of quadrature clock periods between unit position events. For example, <b>EQEP_UNIT_POS_EVNT_DIV_16</b> will result in a unit position event frequency of QCLK/16.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables the eQEP module edge-capture unit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables operation of the eQEP module's edge-capture unit.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the eQEP module edge-capture unit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables operation of the eQEP module's edge-capture unit.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the encoder capture period.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the period count value between the last successive eQEP position events.</p>
<dl class="section return"><dt>Returns</dt><dd>The period count value between the last successive position events.</dd></dl>
<p>Gets the encoder capture timer value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the time base for the edge capture unit.</p>
<dl class="section return"><dt>Returns</dt><dd>The capture timer value.</dd></dl>
<p>Enables the eQEP module position-compare unit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables operation of the eQEP module's position-compare unit.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the eQEP module position-compare unit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables operation of the eQEP module's position-compare unit.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the position-compare unit's sync output pulse width.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">cycles</td><td>is the width of the pulse that can be generated on a position-compare event. It is in units of 4 SYSCLKOUT cycles.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the width of the sync output pulse. The width of the pulse will be <em>cycles</em> * 4 * the width of a SYSCLKOUT cycle. The maximum width is 4096 * 4 * SYSCLKOUT cycles.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Loads the eQEP module unit timer period as number of SYSCLK cycles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">period</td><td>is period value at which a unit time-out interrupt is set.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the unit time-out interrupt when it matches the value specified by <em>period</em> The unit timer is clocked by SYSCLKOUT</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables the eQEP module unit timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">period</td><td>is period value at which a unit time-out interrupt is set.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables operation of the eQEP module's peripheral unit timer. The unit timer is clocked by SYSCLKOUT and will set the unit time-out interrupt when it matches the value specified by <em>period</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the eQEP module unit timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables operation of the eQEP module's peripheral unit timer.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables the eQEP module watchdog timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">period</td><td>is watchdog period value at which a time-out will occur if no quadrature-clock event is detected.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables operation of the eQEP module's peripheral watchdog timer.</p>
<dl class="section note"><dt>Note</dt><dd>When selecting <em>period</em>, note that the watchdog timer is clocked from SYSCLKOUT/64.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the eQEP module watchdog timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables operation of the eQEP module's peripheral watchdog timer.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the eQEP module watchdog timer value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">value</td><td>is the value to be written to the watchdog timer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the eQEP module's watchdog timer value.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the eQEP module watchdog timer value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the current watchdog timer value.</dd></dl>
<p>Configures the mode in which the position counter is initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">initMode</td><td>is the configuration for initializing the position count. See below for a description of this parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the events on which the position count can be initialized. The <em>initMode</em> parameter provides the mode as either <b>EQEP_INIT_DO_NOTHING</b> (no action configured) or one of the following strobe events, index events, or a logical OR of both a strobe event and an index event.</p>
<ul>
<li><b>EQEP_INIT_RISING_STROBE</b> or <b>EQEP_INIT_EDGE_DIR_STROBE</b> specify which strobe event will initialize the position counter.</li>
<li><b>EQEP_INIT_RISING_INDEX</b> or <b>EQEP_INIT_FALLING_INDEX</b> specify which index event will initialize the position counter.</li>
</ul>
<p>Use EQEP_setSWPositionInit() to cause a software initialization and EQEP_setInitialPosition() to set the value that gets loaded into the position counter upon initialization.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the software initialization of the encoder position counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">initialize</td><td>is a flag to specify if software initialization of the position counter is enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function does a software initialization of the position counter when the <em>initialize</em> parameter is <b>true</b>. When <b>false</b>, the QEPCTL[SWI] bit is cleared and no action is taken.</p>
<p>The init value to be loaded into the position counter can be set with EQEP_setInitialPosition(). Additional initialization causes can be configured with EQEP_setPositionInitMode().</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the init value for the encoder position counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">position</td><td>is the value to be written to the position counter upon. initialization.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the init value for position of the encoder. See EQEP_setPositionInitMode() to set the initialization cause or EQEP_setSWPositionInit() to cause a software initialization.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the quadrature modes in which the position count can be latched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">latchMode</td><td>is the configuration for latching of the position count and several other registers. See below for a description of this parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the events on which the position count and several other registers can be latched. The <em>latchMode</em> parameter provides the mode as the logical OR of several values.</p>
<ul>
<li><b>EQEP_LATCH_CNT_READ_BY_CPU</b> or <b>EQEP_LATCH_UNIT_TIME_OUT</b> specify the event that latches the position counter. This latch register can be read using EQEP_getPositionLatch(). The capture timer and capture period are also latched based on this setting, and can be read using EQEP_getCaptureTimerLatch() and EQEP_getCapturePeriodLatch().</li>
<li><b>EQEP_LATCH_RISING_STROBE</b> or <b>EQEP_LATCH_EDGE_DIR_STROBE</b> specify which strobe event will latch the position counter into the strobe position latch register. This register can be read with EQEP_getStrobePositionLatch().</li>
<li><b>EQEP_LATCH_RISING_INDEX</b>, <b>EQEP_LATCH_FALLING_INDEX</b>, or <b>EQEP_LATCH_SW_INDEX_MARKER</b> specify which index event will latch the position counter into the index position latch register. This register can be read with EQEP_getIndexPositionLatch().</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the encoder position that was latched on an index event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the value in the index position latch register. The position counter is latched into this register on either a rising index edge, a falling index edge, or a software index marker. This is configured using EQEP_setLatchMode().</p>
<dl class="section return"><dt>Returns</dt><dd>The position count latched on an index event.</dd></dl>
<p>Gets the encoder position that was latched on a strobe event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the value in the strobe position latch register. The position counter can be configured to be latched into this register on rising strobe edges only or on rising strobe edges while moving clockwise and falling strobe edges while moving counter-clockwise. This is configured using EQEP_setLatchMode().</p>
<dl class="section return"><dt>Returns</dt><dd>The position count latched on a strobe event.</dd></dl>
<p>Gets the encoder position that was latched on a unit time-out event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the value in the position latch register. The position counter is latched into this register either on a unit time-out event.</p>
<dl class="section return"><dt>Returns</dt><dd>The position count latch register value.</dd></dl>
<p>Gets the encoder capture timer latch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the value in the capture timer latch register. The capture timer value is latched into this register either on a unit time-out event or upon the CPU reading the eQEP position counter. This is configured using EQEP_setLatchMode().</p>
<dl class="section return"><dt>Returns</dt><dd>The edge-capture timer latch value.</dd></dl>
<p>Gets the encoder capture period latch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the value in the capture period latch register. The capture period value is latched into this register either on a unit time-out event or upon the CPU reading the eQEP position counter. This is configured using EQEP_setLatchMode().</p>
<dl class="section return"><dt>Returns</dt><dd>The edge-capture period latch value.</dd></dl>
<p>Set the quadrature mode adapter (QMA) module mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">qmaMode</td><td>is the mode in which the QMA module will operate.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the quadrature mode adapter module mode. The possible modes are passed to the function through the <em>qmaMode</em> parameter which can take the values EQEP_QMA_MODE_BYPASS, EQEP_QMA_MODE_1, or EQEP_QMA_MODE_2.</p>
<p>To use the QMA module, you must first put the eQEP module into direction-count mode (<b>EQEP_CONFIG_CLOCK_DIR</b>) using EQEP_setConfig().</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the strobe input source of the eQEP module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">strobeSrc</td><td>is the source of the strobe signal.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the source of the eQEP module's strobe signal. The possible values of the <em>strobeSrc</em> parameter are</p><ul>
<li><b>EQEP_STROBE_FROM_GPIO</b> - The strobe is used as-is after passing through the polarity select logic.</li>
<li><b>EQEP_STROBE_OR_ADCSOCA</b> - The strobe is OR'd with the ADCSOCA signal after passing through the polarity select logic.</li>
<li><b>EQEP_STROBE_OR_ADCSOCB</b> - The strobe is OR'd with the ADCSOCB signal after passing through the polarity select logic.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables the index direction enhancement mode of the eQEP module</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the enhancement mode for direction change during Index event</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the index direction enhancement mode of the eQEP module</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the enhancement mode for direction change during Index event</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Selects the source for eQEPA/B/I signals</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the enhanced quadrature encoder pulse (eQEP) module </td></tr>
    <tr><td class="paramname">sourceConfig</td><td>is the structure that contains source configuration</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the sources for QEPA,QEPB and Index of eQEP module</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the emulation mode of the eQEP module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the eQEP module. </td></tr>
    <tr><td class="paramname">emuMode</td><td>is the mode operation upon an emulation suspend.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the eQEP module's emulation mode. This mode determines how the timers are affected by an emulation suspend. Valid values for the <em>emuMode</em> parameter are the following:</p>
<ul>
<li><b>EQEP_EMULATIONMODE_STOPIMMEDIATELY</b> - The position counter, watchdog counter, unit timer, and capture timer all stop immediately.</li>
<li><b>EQEP_EMULATIONMODE_STOPATROLLOVER</b> - The position counter, watchdog counter, unit timer all count until period rollover. The capture timer counts until the next unit period event.</li>
<li><b>EQEP_EMULATIONMODE_RUNFREE</b> - The position counter, watchdog counter, unit timer, and capture timer are all unaffected by an emulation suspend.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the current owner of the EBC instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td>This function returns the current owner of the EBC instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Owner of ERAD.</dd></dl>
<p>Sets the current owner of the EBC instance</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>is the Owner of the EBC instance that is to be set.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the current owner of the EBC instance.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the current owner of the SEC instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td>This function returns the current owner of the SEC instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Owner of ERAD.</dd></dl>
<p>Sets the current owner of the SEC instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>is the Owner of the SEC instance that is to be set</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the current owner of the SEC instance.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the current owner of the AND / OR Mask instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td>This function returns the current owner of the AND / OR Mask instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Owner of AND / OR Mask.</dd></dl>
<p>Sets the current owner of the AND / OR Mask instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>is the Owner of the AND / OR Mask instance that is to be set</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the current owner of the AND / OR Mask instance.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the reset event of the counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>is the instance of the counter to be configured. </td></tr>
    <tr><td class="paramname">reset_event</td><td>is the event upon which the counter must be reset.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the event upon which the counter must reset and enables reset upon such an event.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the reset event of the counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>is the instance of the counter.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the reset event that may have been set earlier</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clears an event that may have fired in the counter upon match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>is the instance of the counter.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears a counter event that may have fired when the counter hit a match.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clears an overflow that may have occured in the counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>is the instance of the counter.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the overflow bit that may have got set when the counter may have crossed 0xFFFFFFFF.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the current count of a counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>is the instance of the counter.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current count of the counter which was configured earlier.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of the current count of the counter.</dd></dl>
<p>Sets the current count of a counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>is the instance of the counter. </td></tr>
    <tr><td class="paramname">value</td><td>is the value to be written as the current count.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the current count of the counter which was configured earlier. This can be used to reset the counter or start at a value other than 0.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the maximum count of a counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>is the SEC instance.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current maximum count of the counter which was configured earlier.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of the current maximum count of the counter.</dd></dl>
<p>Sets the maximum count of a counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>is the SEC instance. </td></tr>
    <tr><td class="paramname">value</td><td>is the value to be written as the maximum count.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the current maximum count of the counter which was configured earlier.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the minimum count of a counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>is the SEC instance.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current minimum count of the counter which was configured earlier.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of the current minimum count of the counter.</dd></dl>
<p>Sets the minimum count of a counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>is the SEC instance. </td></tr>
    <tr><td class="paramname">value</td><td>is the value to be written as the minimum count.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the current minimum count of the counter which was configured earlier.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets conditioning on the inputs to the counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>is the instance value of the counter to be configured </td></tr>
    <tr><td class="paramname">input_type</td><td>defines which input needs to be conditioned </td></tr>
    <tr><td class="paramname">options</td><td>is the kind of conditioning that needs to applied. This can be <b>ERAD_INPUT_INVERT_ENABLE</b> or <b>ERAD_INPUT_INVERT_DISABLE</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function conditions the inputs to the counter specified. This includes inverting the input for any 4 of the inputs: <em>reset</em>, <em>stop</em>, <em>start</em>, <em>count_input</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable PC Trace</p>
<p>This function enables PC Trace</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable PC Trace</p>
<p>This function disables PC Trace</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the current owner of the PC Trace module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td>This function returns the current owner of the PC Trace module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Owner of PC Trace.</dd></dl>
<p>Sets the current owner of the PC Trace module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>is the Owner of the PC Trace module that is to be set.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the current owner of the PC Trace module.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Initialize PC Trace Buffer</p>
<p>This function initilizes the Trace module for a fresh trace start with buffer pointer reset and overflow flags cleared along with SOFT_START_PC and SOFT_STOP_PC</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the PC Trace submodule to trace without hardware qaulifiers</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the PC Trace submodule to trace using windowed mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qualifier</td><td>Qualifier input to enable tracing </td></tr>
    <tr><td class="paramname">inputConditioning</td><td>is the kind of conditioning that needs to applied for the trace input. This can be <b>ERAD_INPUT_INVERT_ENABLE</b> or <b>ERAD_INPUT_INVERT_DISABLE</b>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the PC Trace submodule to trace using start stop mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startInput</td><td>Start Event for the Trace </td></tr>
    <tr><td class="paramname">stopInput</td><td>Stop Event for the Trace </td></tr>
    <tr><td class="paramname">startInputConditioning</td><td>is the kind of conditioning that needs to applied for the start input. This can be <b>ERAD_INPUT_INVERT_ENABLE</b> or <b>ERAD_INPUT_INVERT_DISABLE</b>. </td></tr>
    <tr><td class="paramname">stopInputConditioning</td><td>is the kind of conditioning that needs to applied for the stop input. This can be <b>ERAD_INPUT_INVERT_ENABLE</b> or <b>ERAD_INPUT_INVERT_DISABLE</b>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get last Reset source</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM instance.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the Source of the last Reset.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable all interrupts (Global enable).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM module instance.</td></tr>
  </table>
  </dd>
</dl>
<p>The function enables all the interrupts.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables all the interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM instance.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables all the interrupts (Global disable)</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Write the EOI vector to the EOI register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM configuration registers. </td></tr>
    <tr><td class="paramname">vector</td><td>is the corresponding vector for the interrupt. Refer ESM_EOIVector enum</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes the corresponding EOI vector to the EOI register. Writing the vector to this field will cause a re-evaluation of interrupts. If, when the vector is written, there are still pending interrupts, a new pulse will be generated.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Write the EOI vector to acknowledge the interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM configuration registers. </td></tr>
    <tr><td class="paramname">interruptType</td><td>is the type of interrupt mapping the EOI vector. Refer ESM_InterruptType enum</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes the corresponding EOI vector to the EOI register based on the interrupt type passes. Writing the vector to this field will cause a re-evaluation of interrupts. If, when the vector is written, there are still pending interrupts, a new pulse will be generated.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configure the operation mode of Error pin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>is the Error pin mode to be configured. Refer ESM_OperationMode enum</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the mode of the Error pin of the ESM.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clears the Error pin</p>
<p>The clear event mode from ESM_OperationMode enum is used.</p>
<p>This function clears the Error pin. For the Error pin to de-assert, 1.The Minimum Time Interval must expire 2.The event that caused the Error Pin to assert must be cleared 3.A CLEAR must be written to the Error Pin Control Register using this function</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the ESM error output pin mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>indicates whether the output pin is level or PWM mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the mode of the ESM error output pin. This function should only be called when the ESM is disabled, from the Global Enable register.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the polarity of the Error pin in Level mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polarity</td><td>indicates whether the polarity is active low or active high</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the Level mode polarity. When the error output pin is a level, by default it is active low (drives the error pin low to indicate an error). When 4’b1111 is written to this field, the polarity will be active high instead.</p>
<p>The polarity should only be modified when the ESM is disabled, from the Global Enable register.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get the current state of the Error pin output.</p>
<p>This function returns the status of the Error Pin as looped back from the I/O.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if De-Asserted (pin is inactive, high). Returns <b>false</b> if Asserted (pin is active, low).</dd></dl>
<p>Enables High priority Watchdog feature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM CPU instance.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the high priority Watchdog and its associated interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the High priority Watchdog feature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM CPU instance.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the high priority Watchdog and its associated interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables High priority Watchdog's Free running mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM CPU instance.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the high priority Watchdog free running mode. If it is enabled, the Watchdog counter will continue to count down during debug.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables High priority Watchdog's Free running mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM CPU instance.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the high priority Watchdog free running mode. The watchdog counter will be frozen during debug and not resume counting down until debug is suspended.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables the Error pin monitor.</p>
<p>This function enables the Error Pin Monitor and its associated interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the Error pin monitor.</p>
<p>This function disables the Error Pin Monitor and its associated interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the Error pin monitor interrupt.</p>
<p>This function allows software to set the Error pin monitor interrupt output.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clear the Error pin monitor interrupt.</p>
<p>This function allows software to clear the Error pin monitor interrupt output.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get the Error pin monitor interrupt status.</p>
<p>This function returns the status of the Error pin monitor interrupt</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if Inactive or Disabled Returns <b>false</b> if Active/Pending and Enabled</dd></dl>
<p>Enable interrupt for an event</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM module instance. </td></tr>
    <tr><td class="paramname">event</td><td>is the error event. Refer ESM_EventMap for the list of error inputs to the ESM subsystem.</td></tr>
  </table>
  </dd>
</dl>
<p>The function sets the interrupt enable bit for the specific error event. If the corresponding bit and the global_enable are set, then then interrupt is unmasked. The enable field is only reset by a Power-On-Reset (not warm reset) or global soft reset.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable interrupt for an event</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM module instance. </td></tr>
    <tr><td class="paramname">event</td><td>is the error event. Refer ESM_EventMap for the list of error inputs to the ESM subsystem.</td></tr>
  </table>
  </dd>
</dl>
<p>The function clears the interrupt enable bit for the specific error event. (The interrupt is disabled.)</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the Interrupt priority level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM instance. </td></tr>
    <tr><td class="paramname">event</td><td>is the error event. Refer ESM_EventMap for the list of error inputs to the ESM subsystem. </td></tr>
    <tr><td class="paramname">priority</td><td>indicates the priority level of the interrupt. Refer enum ESM_InterruptPriorityLevel</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets which interrupt (low or high prirority) should be influenced for the events in group N.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Set the interrupt raw status of an event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM instance. </td></tr>
    <tr><td class="paramname">event</td><td>is the error event. Refer ESM_EventMap for the list of error inputs to the ESM subsystem.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the interrupt raw status for the corresponding error event.</p>
<p>Get the interrupt raw status of an event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM instance. </td></tr>
    <tr><td class="paramname">event</td><td>is the error event. Refer ESM_EventMap for the list of error inputs to the ESM subsystem.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the raw status of the interrupt for the corresponding error event.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>false</b> if Inactive Returns <b>true</b> if Active/Pending</dd></dl>
<p>Get the interrupt status for an event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM instance. </td></tr>
    <tr><td class="paramname">event</td><td>is the error event. Refer ESM_EventMap for the list of error inputs to the ESM subsystem.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the status of the interrupt for the corresponding error event.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>false</b> if Inactive or Disabled Returns <b>true</b> if Active/Pending and Enabled</dd></dl>
<p>Clear the interrupt raw status of an event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM instance. </td></tr>
    <tr><td class="paramname">event</td><td>is the error event. Refer ESM_EventMap for the list of error inputs to the ESM subsystem.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the interrupt raw status for the corresponding error event.</p>
<p>Sets Critical priority interrupt influence for an event</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM module instance. </td></tr>
    <tr><td class="paramname">event</td><td>is the error event. Refer ESM_EventMap for the list of error inputs to the ESM subsystem. </td></tr>
    <tr><td class="paramname">influence</td><td>indicates if the event influences the critical priority interrupt or not</td></tr>
  </table>
  </dd>
</dl>
<p>The function sets/clears the critical priority interrupt influence enable bit for the specific error event. Corresponding event, when set, will count as a pending event towards generating a critical priority interrupt. It can only be reset by a Power-On-Reset (not warm reset) or global soft reset. When cleared, the corresponding event will no longer count as a pending event towards generating a critical priority interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get Critical priority interrupt output status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM module instance.</td></tr>
  </table>
  </dd>
</dl>
<p>The function returns the status of the critical priority interrupt output. The status is only reset via POR and the Global Soft Reset MMR.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the Critical Priority Interrupt output has triggered, returns <b>false</b> otherwise.</dd></dl>
<p>Sets the influence of an event on the Error pin</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>is the error event. Refer ESM_EventMap for the list of error inputs to the ESM subsystem. </td></tr>
    <tr><td class="paramname">influence</td><td>indicates if the event influences the error pin or not</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets if the error event in group N can influence the Error pin. Corresponding event, when set, will count as a pending error event for the ESM state machine. If influence is cleared, the corresponding events will no longer count as pending error events.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Get the low priority interrupt status for an Event group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM instance. </td></tr>
    <tr><td class="paramname">group</td><td>is the event group. Refer ESM_EventGroup for the list of event groups in the ESM subsystem.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the status of the low priority interrupt for the corresponding error group.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the event Groups have one or more Low Priority interrupts pending, returns <b>false</b> otherwise.</dd></dl>
<p>Get the high priority interrupt status for an Event group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM instance. </td></tr>
    <tr><td class="paramname">group</td><td>is the event group. Refer ESM_EventGroup for the list of event groups in the ESM subsystem.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the status of the high priority interrupt for the corresponding error group.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the event Groups have one or more High Priority interrupts pending, returns <b>false</b> otherwise.</dd></dl>
<p>Get the highest priority outstanding low priority interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM instance.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the global event number of the highest priority outstanding low priority interrupt that is pending. The lowest event number has the highest priority. A value of 0xFFFF indicates that there are no low priority interrupts pending.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the global event number of the highest priority outstanding low priority interrupt.</dd></dl>
<p>Get the highest priority outstanding high priority interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM instance.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the global event number of the highest priority outstanding high priority interrupt that is pending. The lowest event number has the highest priority. A value of 0xFFFF indicates that there are no high priority interrupts pending.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the global event number of the highest priority outstanding high priority interrupt.</dd></dl>
<p>Get the Error pin counter value</p>
<p>This function gets the current value of the Time Interval Counter. This register is reloaded to the counter_preload value on entry to the ESM_ERROR state from ESM_IDLE and counts down by one per clock cycle. Once the counter has reached 0, the Minimum Time Interval has expired.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current Error pin counter value.</dd></dl>
<p>Lock the Error Group N Interrupt configuration Registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM instance. </td></tr>
    <tr><td class="paramname">groups</td><td>Error groups whose configuration for the associated Interrupt Enable Set/Clear Registers and Interrupt Priority Register are to be locked. This parameter can be an OR of the groups in ESM_EventGroup enum.</td></tr>
  </table>
  </dd>
</dl>
<p>This function locks the associated enable and priority bits for each Group for Low and High Priority Interrupts.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Unlock the Error Group N Interrupt configuration Registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM instance. </td></tr>
    <tr><td class="paramname">groups</td><td>Error groups whose configuration for the associated Interrupt Enable Set/Clear Registers and Interrupt Priority Register are to be unlocked.</td></tr>
  </table>
  </dd>
</dl>
<p>This function unlocks the associated enable and priority bits for each Group for Low and High Priority Interrupts.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Commit the Error Group N Interrupt configuration Registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ESM instance. </td></tr>
    <tr><td class="paramname">groups</td><td>Error groups whose lock on configuration for the associated Interrupt Enable Set/Clear Registers and Interrupt Priority Register are to be committed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function locks the associated enable and priority bits for each Group for Low and High Priority Interrupts.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Lock Error Pin Influence registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groups</td><td>Error groups whose Error Pin Influence Set and Clear Registers are to be locked.</td></tr>
  </table>
  </dd>
</dl>
<p>This function locks the Error Pin Influence configuration for the associated Error Groups.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Unlock the Error Pin Influence registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groups</td><td>Error groups whose Error Pin Influence Set and Clear Registers are to be unlocked.</td></tr>
  </table>
  </dd>
</dl>
<p>This function unlocks the Error Pin Influence configuration for the associated Error Groups, if the corresponding Commit bit is not set.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Commit the Error Pin Influence registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groups</td><td>Error groups whose lock on Error Pin Influence Set and Clear Registers are to be committed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function commits the lock configuration for the Error Pin Influence configuration for the associated Error Groups.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Lock the Critical Priority Interrupt Influence configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groups</td><td>Error groups whose Error Pin Influence Set and Clear Registers are to be locked.</td></tr>
  </table>
  </dd>
</dl>
<p>This function locks the Critical Priority Interrupt Influence configuration for the associated Error Groups. Each bit lock[N] bit will lock the associated masking MMRs associated with Group N.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Unlock the Critical Priority Interrupt Influence configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groups</td><td>Error groups whose Error Pin Influence Set and Clear Registers are to be unlocked.</td></tr>
  </table>
  </dd>
</dl>
<p>This function unlocks the Critical Priority Interrupt Influence configuration for the associated Error Groups, if the corresponding Commit bit is not set.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Commit the Critical Priority Interrupt Influence configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groups</td><td>Error groups whose lock on Error Pin Influence Set and Clear Registers are to be committed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function commits the lock configuration for the Critical Priority Interrupt Influence configuration for the associated Error Groups. Each bit commit[N] bit will commit the lock configuration for the corresponding bit in the Critical Priority Interrupt Influence Lock Register.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Lock MMR registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registers</td><td>Registers to be locked. Can be OR of the following -<ul>
<li>ESM_GLOBAL_EN_REG</li>
<li>ESM_GLOBAL_SOFT_RESET_REG</li>
<li>ESM_ERROR_PIN_REG</li>
<li>ESM_ERROR_PIN_MONITOR_REG</li>
<li>ESM_HIGH_PRIORITY_WATCHDOG_REG</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Unlock the Configuration MMR registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registers</td><td>Registers to be unlocked. Can be OR of the following -<ul>
<li>ESM_GLOBAL_EN_REG</li>
<li>ESM_GLOBAL_SOFT_RESET_REG</li>
<li>ESM_ERROR_PIN_REG</li>
<li>ESM_ERROR_PIN_MONITOR_REG</li>
<li>ESM_HIGH_PRIORITY_WATCHDOG_REG</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Commit the configuration MMR registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registers</td><td>Register locks to be committed. Can be OR of the following<ul>
<li>ESM_GLOBAL_EN_REG</li>
<li>ESM_GLOBAL_SOFT_RESET_REG</li>
<li>ESM_ERROR_PIN_REG</li>
<li>ESM_ERROR_PIN_MONITOR_REG</li>
<li>ESM_HIGH_PRIORITY_WATCHDOG_REG</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Get the ESM group interrupt status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>The group id for which the interrupt status is returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Group interrupt status</dd></dl>
<p>Clear the group interrupt status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Group for which the interrupt status is cleared</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Transmission of FLUSH pattern should be stopped before starting sending frames. Generally during initilization a pair of send/stop APIs for FLUSH pattern is called to clear data/clock lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preScaleValue</td><td>used to generate transmit clock, it defines the division value of /2,/3,/4,etc. of <b>PLLCLK</b>. Prescale value is is to be set while keeping the clock in reset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataWidth</td><td>selection between 1 or 2 lane transmission</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>FSI supports a <b>compatibility</b> mode in order to communicate with <b>legacy</b> peripherals like <b>SPI</b>. Only the 16-bit mode of SPI will be supported. All the frame structures, CRC checks and will be identical to the normal FSI frames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txStartMode</td><td>is one of supported 3 start modes in transmission</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pingTimeoutMode</td><td>can be HW or both HW/SW initiated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extInputNum</td><td>can be one of ports from 0 to 127. See also FSI_ExtFrameTriggerSrc enum members for valid external triggers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>CRC value of the data frame will be forced to 0 whenever there is a transmission and buffer over-run or under-run condition happens. The idea is to force a corruption of the CRC since the data is not guaranteed to be reliable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccComputeWidth</td><td>is ECC Computation width</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameType</td><td>value of frame type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nWords</td><td>is number of data words in a software defined frame</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameTag</td><td>is value of frame tag, 4 bit value (0 to 15)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userDefData</td><td>is 8 bit user defined data value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufPtrOff</td><td>is a 4 bit offset pointer in Tx buffer from where transmitter will pick the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current buffer pointer location</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There could be lag due to synchronization hence value is accurate only when no current transmission is happening</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of data words present in buffer which have not been transmitted yet </dd></dl>
<dl class="section note"><dt>Note</dt><dd>There could be lag due to synchronization hence value is accurate only when no current transmission is happening</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refValue</td><td>is 32 bit reference value for ping time-out counter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pingFrameTag</td><td>is 4 bit tag value for ping time-out counter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frameTag</td><td>is 4 bit tag value for ping time-out counter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extTrigSel</td><td>can be one of the external inputs from 0 to 127.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current value of counter is returned</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>System reset only can unlock registers once locked.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of error flags, each bit of integer is associated with one error flag.</dd></dl>
<p>Example Usage - function will set the bits corresponding to respective error flag in return value evtStatus = FSI_getTxEventStatus(FSI_base) if bit value of evtStatus is 12(01100) means FSI_TX_EVT_OVERRUN and FSI_TX_EVT_PING_HW_TRIG flags are set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evtFlags</td><td>contains list of event and error flags that are supposed to be set.</td></tr>
  </table>
  </dd>
</dl>
<p>Writing a 1 to this bit position will cause the corresponding bit in <b>TX_EVT_ERR_STATUS</b> register to get set. The purpose of this register is to allow software to simulate the effect of the event and test the associated software/ISR.</p>
<p>Example Usage evtFlags = FSI_TX_EVT_FRAME_DONE &amp; FSI_TX_EVT_OVERRUN FSI_forceTxEvents(FSI_base,evtFlags) Above call sets error flag to frameDone and overRun events</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evtFlags</td><td>contains list of event and error flags that are supposed to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>Writing a 1 to this bit position will cause the corresponding bit in the TX_EVT_ERR_STATUS register to get cleared to 0</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userCRCValue</td><td>is user defined CRC</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>is the data value for which ECC needs to be computed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ECC value for input data</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intNum</td><td>is the type of interrupt to be generated interrupt1 or interrupt2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intFlags</td><td>contains list of events on which interrupt should be generated.</td></tr>
  </table>
  </dd>
</dl>
<p>Example Usage intFlags = FSI_TX_EVT_FRAME_DONE &amp;&amp; FSI_TX_EVT_BUF_OVERRUN &amp;&amp; FSI_TX_EVT_PING_TIMEOUT FSI_enableTxInterrupt(FSI_base, FSI_INT1, intFlags) above configuration will generate signal on interrupt line 1 upon frameDone, BufOverRun and PingTimeOut event</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intNum</td><td>is the type of interrupt to be generated interrupt1 or interrupt2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intFlags</td><td>contains list of events on which interrupt generation has to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Data buffer is consisting of 16 words from offset- 0x40 to 0x4e</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Tx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tx data buffer address</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the FSI-Rx module</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns <b>true</b> if the base address is valid and <b>false</b> otherwise</dd></dl>
<p>Enables internal loopback where MUX will select internal pins coming from TX module instead of what comes from pins</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataWidth</td><td>selection between 1 or 2 lane receive operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nWords</td><td>is number of data words in a software defined frame</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eccComputeWidth</td><td>is ECC Computation width</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pingTimeoutMode</td><td>can be HW or both HW/SW initiated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of Frame type received on last successful frame</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Frame tag value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>User data field value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of error flags,each bit of integer is associated with one error flag.</dd></dl>
<p>Example Usage - function will set the bits corresponding to respective error flag in return value evtFlags = FSI_getRxEventStatus(FSI_base) if value of evtFlags is 1036(0100000001100) means FSI_RX_EVT_FRAME_OVERRUN,FSI_RX_EVT_TYPE_ERR and FSI_RX_EVT_CRC_ERR flags are set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evtFlags</td><td>contains list of error flags to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Example Usage evtFlags = FSI_RX_EVT_EOF_ERR &amp;&amp; FSI_RX_EVT_TYPE_ERR FSI_forceRxEvents(FSI_base,evtFlags) Above call sets error flag to FSI_RX_ERR_EOF_ERR and FSI_RX_ERR_TYPE_ERR events</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evtFlags</td><td>contains list of error flags to be cleared</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CRC value received in data frame</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CRC value computed on received data</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufPtrOff</td><td>is 4 bit offset pointer in Rx buffer from where received data will be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current buffer pointer location</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There could be lag due to synchronization, hence value is accurate only when no current reception is happening</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of data words present in buffer which have not been read out yet</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There could be lag due to synchronization, hence value is accurate only when no current reception is happening</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wdRef</td><td>is reference value for ping watchdog time-out counter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current value of frame watchdog counter</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current value(32 bit) of ping watchdog counter</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tag Value received for last ping frame</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rxECCdata</td><td>Data for ECC logic</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rxECCvalue</td><td>Received ECC value in a data frame</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>32 bit ECC corrected data</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ECC Log value(8 bit)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intNum</td><td>the type of interrupt to be generated interrupt1 or interrupt2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intFlags</td><td>contains list of events on which interrupt should be generated. Each bit will represent one event,bits for the events on which user want to generate interrupt will be set others remain clear</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Example Usage evtFlags = FSI_RX_EVT_PING_WD_TIMEOUT &amp; FSI_RX_INT_TYPE_ERR FSI_enableRxInterrupt(FSI_base,FSI_INT1,evtFlags) Above call will generate interrupt1 on events FSI_RX_INT_PING_WD_TIMEOUT and FSI_RX_INT_TYPE_ERR</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intNum</td><td>the type of interrupt to be generated interrupt1 or interrupt2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intFlags</td><td>contains list of events on which interrupt generation has to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Data buffer is consisting of 16 words from offset- 0x40 to 0x4e</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rx data buffer address</dd></dl>
<p>The reference tag is used to check against when comparing the TAG_MASK and the incoming frame tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refVal</td><td>is the Rx frame reference tag value to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>The reference tag is used to check against when comparing the TAG_MASK and the incoming frame tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rx frame reference tag</dd></dl>
<p>Any bit position set to 0 will be used in the comparison of incoming tag &amp; the reference tag. A bit position set to 1 will be ignored in the tag comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maskVal</td><td>is the Rx frame tag mask value to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Any bit position set to 0 will be used in the comparison of incoming tag &amp; the reference tag. A bit position set to 1 will be ignored in the tag comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rx frame tag mask</dd></dl>
<p>The reference tag is used to check against when comparing the TAG_MASK and the incoming ping tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refVal</td><td>is the Rx frame reference tag value to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>The reference tag is used to check against when comparing the TAG_MASK and the incoming ping tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rx ping frame reference tag</dd></dl>
<p>Any bit position set to 0 will be used in the comparison of incoming tag &amp; the reference tag. A bit position set to 1 will be ignored in the tag comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maskVal</td><td>is the Rx frame tag mask value to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rx ping tag mask</dd></dl>
<p>Any bit position set to 0 will be used in the comparison of incoming tag &amp; the reference tag. A bit position set to 1 will be ignored in the tag comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>is the FSI Rx module base address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rx ping frame reference tag mask</dd></dl>
<p>Gets the interrupt type for a pin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extIntNum</td><td>specifies the external interrupt.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the interrupt type for a interrupt. The interrupt can be configured as a falling-edge, rising-edge, or both-edges detected interrupt.</p>
<p>The following defines can be used to specify the external interrupt for the <em>extIntNum</em> parameter:</p>
<ul>
<li><b>GPIO_INT_XINT1</b> </li>
<li><b>GPIO_INT_XINT2</b> </li>
<li><b>GPIO_INT_XINT3</b> </li>
<li><b>GPIO_INT_XINT4</b> </li>
<li><b>GPIO_INT_XINT5</b> </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns one of the flags described for GPIO_setInterruptType().</dd></dl>
<p>Enables the specified external interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extIntNum</td><td>specifies the external interrupt.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated external interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt. Disabled sources have no effect on the processor.</p>
<p>The following defines can be used to specify the external interrupt for the <em>extIntNum</em> parameter:</p>
<ul>
<li><b>GPIO_INT_XINT1</b> </li>
<li><b>GPIO_INT_XINT2</b> </li>
<li><b>GPIO_INT_XINT3</b> </li>
<li><b>GPIO_INT_XINT4</b> </li>
<li><b>GPIO_INT_XINT5</b> </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the specified external interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extIntNum</td><td>specifies the external interrupt.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated external interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt. Disabled sources have no effect on the processor.</p>
<p>The following defines can be used to specify the external interrupt for the <em>extIntNum</em> parameter:</p>
<ul>
<li><b>GPIO_INT_XINT1</b> </li>
<li><b>GPIO_INT_XINT2</b> </li>
<li><b>GPIO_INT_XINT3</b> </li>
<li><b>GPIO_INT_XINT4</b> </li>
<li><b>GPIO_INT_XINT5</b> </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the value of the external interrupt counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extIntNum</td><td>specifies the external interrupt.</td></tr>
  </table>
  </dd>
</dl>
<p>The following defines can be used to specify the external interrupt for the <em>extIntNum</em> parameter:</p>
<ul>
<li><b>GPIO_INT_XINT1</b> </li>
<li><b>GPIO_INT_XINT2</b> </li>
<li><b>GPIO_INT_XINT3</b> </li>
</ul>
<p><b>Note:</b> The counter is clocked at the SYSCLKOUT rate.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns external interrupt counter value.</dd></dl>
<p>Reads the value present on the specified pin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>is the identifying GPIO number of the pin.</td></tr>
  </table>
  </dd>
</dl>
<p>The value at the specified pin are read, as specified by <em>pin</em>. The value is returned for both input and output pins.</p>
<p>The pin is specified by its numerical value. For example, GPIO34 is specified by passing 34 as <em>pin</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value in the data register for the specified pin.</dd></dl>
<p>Reads the data register value for specified pin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>is the identifying GPIO number of the pin.</td></tr>
  </table>
  </dd>
</dl>
<p>The value available at the data register for the specified pin is read, as specified by <em>pin</em>. The value is returned for both input and output pins.</p>
<p>The pin is specified by its numerical value. For example, GPIO34 is specified by passing 34 as <em>pin</em>.</p>
<dl class="section see"><dt>See also</dt><dd>GPIO_readPin()</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value in the data register for the specified pin.</dd></dl>
<p>Writes a value to the specified pin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>is the identifying GPIO number of the pin. </td></tr>
    <tr><td class="paramname">outVal</td><td>is the value to write to the pin.</td></tr>
  </table>
  </dd>
</dl>
<p>Writes the corresponding bit values to the output pin specified by <em>pin</em>. Writing to a pin configured as an input pin has no effect.</p>
<p>The pin is specified by its numerical value. For example, GPIO34 is specified by passing 34 as <em>pin</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Toggles the specified pin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>is the identifying GPIO number of the pin.</td></tr>
  </table>
  </dd>
</dl>
<p>Writes the corresponding bit values to the output pin specified by <em>pin</em>. Writing to a pin configured as an input pin has no effect.</p>
<p>The pin is specified by its numerical value. For example, GPIO34 is specified by passing 34 as <em>pin</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Reads the data on the specified port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>is the GPIO port being accessed in the form of <b>GPIO_PORT_X</b> where X is the port letter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value available on pin for the specified port. Each bit of the the return value represents a pin on the port, where bit 0 represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.</dd></dl>
<p>Reads the data written in GPIO Data Register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>is the GPIO port being accessed in the form of <b>GPIO_PORT_X</b> where X is the port letter.</td></tr>
  </table>
  </dd>
</dl>
<p>Reads the data written in GPIO Data Register for the specified port. In previous devices, read of GPIO data registers resulted in read of corresponding pins. The function <b>GPIO_readPortData()</b> returns the value on pin.</p>
<dl class="section see"><dt>See also</dt><dd>GPIO_readPortData()</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value in the data register for the specified port. Each bit of the the return value represents a pin on the port, where bit 0 represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.</dd></dl>
<p>Writes a value to the specified port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>is the GPIO port being accessed. </td></tr>
    <tr><td class="paramname">outVal</td><td>is the value to write to the port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes the value <em>outVal</em> to the port specified by the <em>port</em> parameter which takes a value in the form of <b>GPIO_PORT_X</b> where X is the port letter. For example, use <b>GPIO_PORT_A</b> to affect port A (GPIOs 0-31).</p>
<p>The <em>outVal</em> is a bit-packed value, where each bit represents a bit on a GPIO port. Bit 0 represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets all of the specified pins on the specified port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>is the GPIO port being accessed. </td></tr>
    <tr><td class="paramname">pinMask</td><td>is a mask of which of the 32 pins on the port are affected.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets all of the pins specified by the <em>pinMask</em> parameter on the port specified by the <em>port</em> parameter which takes a value in the form of <b>GPIO_PORT_X</b> where X is the port letter. For example, use <b>GPIO_PORT_A</b> to affect port A (GPIOs 0-31).</p>
<p>The <em>pinMask</em> is a bit-packed value, where each bit that is set identifies the pin to be set. Bit 0 represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clears all of the specified pins on the specified port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>is the GPIO port being accessed. </td></tr>
    <tr><td class="paramname">pinMask</td><td>is a mask of which of the 32 pins on the port are affected.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears all of the pins specified by the <em>pinMask</em> parameter on the port specified by the <em>port</em> parameter which takes a value in the form of <b>GPIO_PORT_X</b> where X is the port letter. For example, use <b>GPIO_PORT_A</b> to affect port A (GPIOs 0-31).</p>
<p>The <em>pinMask</em> is a bit-packed value, where each bit that is <b>set</b> identifies the pin to be cleared. Bit 0 represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Toggles all of the specified pins on the specified port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>is the GPIO port being accessed. </td></tr>
    <tr><td class="paramname">pinMask</td><td>is a mask of which of the 32 pins on the port are affected.</td></tr>
  </table>
  </dd>
</dl>
<p>This function toggles all of the pins specified by the <em>pinMask</em> parameter on the port specified by the <em>port</em> parameter which takes a value in the form of <b>GPIO_PORT_X</b> where X is the port letter. For example, use <b>GPIO_PORT_A</b> to affect port A (GPIOs 0-31).</p>
<p>The <em>pinMask</em> is a bit-packed value, where each bit that is set identifies the pin to be toggled. Bit 0 represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the I2C module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables operation of the I2C module.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables the transmit and receive FIFOs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This functions enables the transmit and receive FIFOs in the I2C.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the transmit and receive FIFOs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This functions disables the transmit and receive FIFOs in the I2C.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the FIFO level at which interrupts are generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used. </td></tr>
    <tr><td class="paramname">txLevel</td><td>is the transmit FIFO interrupt level, specified as <b>I2C_FIFO_TX0</b>, <b>I2C_FIFO_TX1</b>, <b>I2C_FIFO_TX2</b>, . . . or <b>I2C_FIFO_TX16</b>. </td></tr>
    <tr><td class="paramname">rxLevel</td><td>is the receive FIFO interrupt level, specified as <b>I2C_FIFO_RX0</b>, <b>I2C_FIFO_RX1</b>, <b>I2C_FIFO_RX2</b>, . . . or <b>I2C_FIFO_RX16</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the FIFO level at which transmit and receive interrupts are generated. The transmit FIFO interrupt flag will be set when the FIFO reaches a value less than or equal to <em>txLevel</em>. The receive FIFO flag will be set when the FIFO reaches a value greater than or equal to <em>rxLevel</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the FIFO level at which interrupts are generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used. </td></tr>
    <tr><td class="paramname">txLevel</td><td>is a pointer to storage for the transmit FIFO level, returned as one of <b>I2C_FIFO_TX0</b>, <b>I2C_FIFO_TX1</b>, <b>I2C_FIFO_TX2</b>, . . . or <b>I2C_FIFO_TX16</b>. </td></tr>
    <tr><td class="paramname">rxLevel</td><td>is a pointer to storage for the receive FIFO level, returned as one of <b>I2C_FIFO_RX0</b>, <b>I2C_FIFO_RX1</b>, <b>I2C_FIFO_RX2</b>, . . . or <b>I2C_FIFO_RX16</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the FIFO level at which transmit and receive interrupts are generated. The transmit FIFO interrupt flag will be set when the FIFO reaches a value less than or equal to <em>txLevel</em>. The receive FIFO flag will be set when the FIFO reaches a value greater than or equal to <em>rxLevel</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get the transmit FIFO status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the current number of words in the transmit FIFO.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current number of words in the transmit FIFO specified as one of the following: <b>I2C_FIFO_TX0</b>, <b>I2C_FIFO_TX1</b>, <b>I2C_FIFO_TX2</b>, <b>I2C_FIFO_TX3</b>, ..., or <b>I2C_FIFO_TX16</b> </dd></dl>
<p>Get the receive FIFO status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the current number of words in the receive FIFO.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current number of words in the receive FIFO specified as one of the following: <b>I2C_FIFO_RX0</b>, <b>I2C_FIFO_RX1</b>, <b>I2C_FIFO_RX2</b>, <b>I2C_FIFO_RX3</b>, ..., or <b>I2C_FIFO_RX16</b> </dd></dl>
<p>Reads I2C Module clock prescaler value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads the I2C prescaler value which configures the I2C module clock by dividing down the SYSCLK. I2C_MODULE_CLK = SYSCLK / (I2CPSC + )</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the I2C prescaler(I2CPSC) cast as an uint16_t.</dd></dl>
<p>Sets the address that the I2C Controller places on the bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used. </td></tr>
    <tr><td class="paramname">targetAddr</td><td>7-bit or 10-bit target address</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the address that the I2C Controller places on the bus when initiating a transaction.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the own address for this I2C module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C Target module. </td></tr>
    <tr><td class="paramname">Addr</td><td>is the 7-bit or 10-bit address</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes the specified address.</p>
<p>The parameter <em>Addr</em> is the value that is compared against the target address sent by an I2C controller.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Indicates whether or not the I2C bus is busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns an indication of whether or not the I2C bus is busy. This function can be used in a multi-controller environment to determine if the bus is free for another data transfer.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the I2C bus is busy; otherwise, returns <b>false</b>.</dd></dl>
<p>Gets the current I2C module status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the status for the I2C module.</p>
<dl class="section return"><dt>Returns</dt><dd>The current module status, enumerated as a bit field of<ul>
<li><b>I2C_STS_ARB_LOST</b> - Arbitration-lost</li>
<li><b>I2C_STS_NO_ACK</b> - No-acknowledgment (NACK)</li>
<li><b>I2C_STS_REG_ACCESS_RDY</b> - Register-access-ready (ARDY)</li>
<li><b>I2C_STS_RX_DATA_RDY</b> - Receive-data-ready</li>
<li><b>I2C_STS_TX_DATA_RDY</b> - Transmit-data-ready</li>
<li><b>I2C_STS_STOP_CONDITION</b> - Stop condition detected</li>
<li><b>I2C_STS_BYTE_SENT</b> - Byte transmit complete</li>
<li><b>I2C_STS_ADDR_ZERO</b> - Address of all zeros detected</li>
<li><b>I2C_STS_ADDR_TARGET</b> - Addressed as Target</li>
<li><b>I2C_STS_TX_EMPTY</b> - Transmit shift register empty</li>
<li><b>I2C_STS_RX_FULL</b> - Receive shift register full</li>
<li><b>I2C_STS_BUS_BUSY</b> - Bus busy, wait for STOP or reset</li>
<li><b>I2C_STS_NACK_SENT</b> - NACK was sent</li>
<li><b>I2C_STS_TARGET_DIR-</b> Addressed as Target transmitter</li>
<li><b>I2C_STS_SCL_ECS</b> - SCL Auto Clock Stretch Status</li>
</ul>
</dd></dl>
<p>Clears I2C status flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used. </td></tr>
    <tr><td class="paramname">stsFlags</td><td>is a bit mask of the status flags to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the specified I2C status flags. The <em>stsFlags</em> parameter is the logical OR of the following values:</p><ul>
<li><b>I2C_STS_ARB_LOST</b> </li>
<li><b>I2C_STS_NO_ACK</b>,</li>
<li><b>I2C_STS_REG_ACCESS_RDY</b> </li>
<li><b>I2C_STS_RX_DATA_RDY</b> </li>
<li><b>I2C_STS_STOP_CONDITION</b> </li>
<li><b>I2C_STS_BYTE_SENT</b> </li>
<li><b>I2C_STS_NACK_SENT</b> </li>
<li><b>I2C_STS_TARGET_DIR</b> </li>
<li><b>I2C_STS_SCL_ECS</b> </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Note that some of the status flags returned by I2C_getStatus() cannot be cleared by this function. Some may only be cleared by hardware or a reset of the I2C module.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Controls the state of the I2C module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used. </td></tr>
    <tr><td class="paramname">config</td><td>is the command to be issued to the I2C module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to control the state of the controller and target send and receive operations. The <em>config</em> is a logical OR of the following options.</p>
<p>One of the following four options:</p><ul>
<li><b>I2C_CONTROLLER_SEND_MODE</b> - Controller-transmitter mode</li>
<li><b>I2C_CONTROLLER_RECEIVE_MODE</b> - Controller-receiver mode</li>
<li><b>I2C_TARGET_SEND_MODE</b> - Target-transmitter mode</li>
<li><b>I2C_TARGET_RECEIVE_MODE</b> - Target-receiver mode</li>
</ul>
<p>Any of the following:</p><ul>
<li><b>I2C_REPEAT_MODE</b> - Sends data until stop bit is set, ignores data count</li>
<li><b>I2C_START_BYTE_MODE</b> - Use start byte mode</li>
<li><b>I2C_FREE_DATA_FORMAT</b> - Use free data format, transfers have no address</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the data byte bit count the I2C module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used. </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bits per data byte.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>size</em> parameter is a value I2C_BITCOUNT_x where x is the number of bits per data byte. The default and maximum size is 8 bits.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Issues an I2C START condition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function causes the I2C module to generate a start condition. This function is only valid when the I2C module specified by the <b>base</b> parameter is a controller.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Issues an I2C STOP condition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function causes the I2C module to generate a stop condition. This function is only valid when the I2C module specified by the <b>base</b> parameter is a controller.</p>
<p>To check on the status of the STOP condition, I2C_getStopConditionStatus() can be used.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Issues a no-acknowledge (NACK) bit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function causes the I2C module to generate a NACK bit. This is only applicable when the I2C module is acting as a receiver.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Receives a byte that has been sent to the I2C.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads a byte of data from the I2C Data Receive Register.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the byte received from by the I2C cast as an uint16_t.</dd></dl>
<p>Transmits a byte from the I2C.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used. </td></tr>
    <tr><td class="paramname">data</td><td>is the data to be transmitted from the I2C Controller.</td></tr>
  </table>
  </dd>
</dl>
<p>This function places the supplied data into I2C Data Transmit Register.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get stop condition status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads and returns the stop condition bit status.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the STP bit has been set by the device to generate a stop condition when the internal data counter of the I2C module has reached 0. Returns <b>false</b> when the STP bit is zero. This bit is automatically cleared after the stop condition has been generated.</dd></dl>
<p>Set number of bytes to be to transfer or receive when repeat mode is off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used. </td></tr>
    <tr><td class="paramname">count</td><td>is the value to be put in the I2C data count register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the number of bytes to transfer or receive when repeat mode is off.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the addressing mode to either 7-bit or 10-bit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used. </td></tr>
    <tr><td class="paramname">mode</td><td>is the address mode, 7-bit or 10-bit.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the I2C module for either a 7-bit address (default) or a 10-bit address. The <em>mode</em> parameter configures the address length to 10 bits when its value is <b>I2C_ADDR_MODE_10BITS</b> and 7 bits when <b>I2C_ADDR_MODE_7BITS</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets I2C emulation mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used. </td></tr>
    <tr><td class="paramname">mode</td><td>is the emulation mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the behavior of the I2C operation when an emulation suspend occurs. The <em>mode</em> parameter can be one of the following:</p>
<ul>
<li><b>I2C_EMULATION_STOP_SCL_LOW</b> - If SCL is low when the breakpoint occurs, the I2C module stops immediately. If SCL is high, the I2C module waits until SCL becomes low and then stops.</li>
<li><b>I2C_EMULATION_FREE_RUN</b> - I2C operation continues regardless of a the suspend.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables I2C loopback mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables loopback mode. This mode is only valid during controller mode and is helpful during device testing as it causes data transmitted out of the data transmit register to be received in data receive register.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables I2C loopback mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables loopback mode. Loopback mode is disabled by default after reset.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Returns the current I2C interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the event that generated an I2C basic (non-FIFO) interrupt. The possible sources are the following:</p><ul>
<li><b>I2C_INTSRC_NONE</b> </li>
<li><b>I2C_INTSRC_ARB_LOST</b> </li>
<li><b>I2C_INTSRC_NO_ACK</b> </li>
<li><b>I2C_INTSRC_REG_ACCESS_RDY</b> </li>
<li><b>I2C_INTSRC_RX_DATA_RDY</b> </li>
<li><b>I2C_INTSRC_TX_DATA_RDY</b> </li>
<li><b>I2C_INTSRC_STOP_CONDITION</b> </li>
<li><b>I2C_INTSRC_ADDR_TARGET</b> </li>
</ul>
<p>Calling this function will result in hardware automatically clearing the current interrupt code and if ready, loading the next pending enabled interrupt. It will also clear the corresponding interrupt flag if the source is <b>I2C_INTSRC_ARB_LOST</b>, <b>I2C_INTSRC_NO_ACK</b>, or <b>I2C_INTSRC_STOP_CONDITION</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Note that this function differs from <a class="el" href="group__i2c__api.html#gae2121679de766a4e914b1304f1f4be65">I2C_getInterruptStatus()</a> in that it returns a single interrupt source. I2C_getInterruptSource() will return the status of all interrupt flags possible, including the flags that aren't necessarily enabled to generate interrupts.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the compatibility mode to support I2C Extended Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used. </td></tr>
    <tr><td class="paramname">mode</td><td>is the compatibility modes.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the I2C module for either a Forward or Backward compatibility. The <em>mode</em> parameter configures the compatibility to Forward when its value is <b>I2C_EADDR_MODE_FWD</b> and Backward when <b>I2C_EADDR_MODE_BC</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable the Extended automatic clock stretching mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the I2C module to enable extended automatic clock stretching mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable the Extended automatic clock stretching mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the I2C module to disable extended automatic clock stretching mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable the manual clock stretching mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the I2C module to enable manual clock stretching mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable the manual clock stretching mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the I2C module to disable manual clock stretching mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable the NACK compatibility mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the I2C module to enable NACK compatibility mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable the NACK compatibility mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the I2C module to disable NACK compatibility mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Global disable for INT and RTINT.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Enables an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>specifies the interrupt to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>The specified interrupt is enabled in the interrupt controller. Other enables for the interrupt (such as at the peripheral level) are unaffected by this function.</p>
<p>The available <em>intNum</em> values are supplied in <code>inc/hw_ints.h</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>specifies the interrupt to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>The specified interrupt is disabled in the interrupt controller. Other enables for the interrupt (such as at the peripheral level) are unaffected by this function.</p>
<p>The available <em>intNum</em> values are supplied in <code>inc/hw_ints.h</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Force an interrupt</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>specifies the interrupt to be forced.</td></tr>
  </table>
  </dd>
</dl>
<p>The available <em>intNum</em> values are supplied in <code>inc/hw_ints.h</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Clear the interrupt flag</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>specifies the interrupt flag to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>The available <em>intNum</em> values are supplied in <code>inc/hw_ints.h</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Clear the interrupt overflow flag</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>specifies the interrupt flag to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>The available <em>intNum</em> values are supplied in <code>inc/hw_ints.h</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Registers a function to be called when an interrupt occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>specifies the interrupt in question. </td></tr>
    <tr><td class="paramname">handler</td><td>is a pointer to the function to be called.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to specify the handler function to be called when the given interrupt is asserted to the processor. When the interrupt occurs, if it is enabled (via Interrupt_enable()), the handler function will be called in interrupt context. Since the handler function can preempt other code, care must be taken to protect memory or peripherals that are accessed by the handler and other non-handler code.</p>
<p>The available <em>intNum</em> values are supplied in <code>inc/hw_ints.h</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Unregisters the function to be called when an interrupt occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>specifies the interrupt in question.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to indicate that a default handler Interrupt_defaultHandler() should be called when the given interrupt is asserted to the processor. Call Interrupt_disable() to disable the interrupt before calling this function.</p>
<p>The available <em>intNum</em> values are supplied in <code>inc/hw_ints.h</code>.</p>
<dl class="section see"><dt>See also</dt><dd>Interrupt_register() for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the Threshold for RTINT</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>Threshold value (0-255)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Set the Interrupt Group Mask</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupMask</td><td>Group mask (0-0xFF)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Set the Interrupt Priority Level</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>specifies the interrupt in question. </td></tr>
    <tr><td class="paramname">priority</td><td>Priority level (0-255)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Set the Interrupt Context ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>specifies the interrupt in question. </td></tr>
    <tr><td class="paramname">contextID</td><td>Context ID to be set for the interrupt<ul>
<li>INTERRUPT_CONTEXTID_0</li>
<li>INTERRUPT_CONTEXTID_1</li>
<li>INTERRUPT_CONTEXTID_2</li>
<li>INTERRUPT_CONTEXT_AGNOSTIC</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Set the Interrupt Link Owner</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>specifies the interrupt in question. </td></tr>
    <tr><td class="paramname">linkOwner</td><td>LinkOwner to be set for the interrupt (SSU_LINK0..15)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Set the Access protection inheritance link</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intNum</td><td>specifies the interrupt in question. </td></tr>
    <tr><td class="paramname">apiLinkID</td><td>Access protection inheritance link for the interrupt (Use SSU_API_LINK1..15, or SSU_API_DISABLE to disable)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Set the current Context ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contextID</td><td>can be one of the following :<ul>
<li>INTERRUPT_CONTEXTID_0</li>
<li>INTERRUPT_CONTEXTID_1</li>
<li>INTERRUPT_CONTEXTID_2</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Enable Supervisor ignore INTE control</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Disable Supervisor ignore INTE control</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>RTINT Stack Warning</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Level for the RTISP to trigger the warning (0-15) </td></tr>
    <tr><td class="paramname">priority</td><td>priority level for which interrupts will be disabled</td></tr>
  </table>
  </dd>
</dl>
<p>Once RTISP &gt;= level the RTINT assertions are only for interrupts higher in priority than the configured priority</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Sets the INT Stack Pointer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>is the INT stack.</td></tr>
  </table>
  </dd>
</dl>
<p>CPU will acknowledge the INT only when its current execution stack matched with INTSP</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Lock the Boot link updates to config registers</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Lock PIPE registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registers</td><td>Registers to be locked. Can be OR of the following -<ul>
<li>INTERRUPT_LINK_REGS</li>
<li>INTERRUPT_CONFIG_REGS</li>
<li>INTERRUPT_GLOBAL_REGS</li>
<li>INTERRUPT_VECTOR_REG </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Unlock PIPE registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registers</td><td>Registers to be unlocked. Can be OR of the following -<ul>
<li>INTERRUPT_LINK_REGS</li>
<li>INTERRUPT_CONFIG_REGS</li>
<li>INTERRUPT_GLOBAL_REGS</li>
<li>INTERRUPT_VECTOR_REG </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Local core clears Local to Remote IPC Flag</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipcChannel</td><td>is the enum corresponding to the IPC instance used </td></tr>
    <tr><td class="paramname">flags</td><td>is the IPC flag mask for the flags being cleared</td></tr>
  </table>
  </dd>
</dl>
<p>This function will allow the Local core system to clear the designated IPC flags sent to the Remote core system. The <em>flags</em> parameter can be any of the IPC flag values: <b>IPC_FLAG0</b> - <b>IPC_FLAG31</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Local core triggers Interrupt to Remote</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipcChannel</td><td>is the enum corresponding to the IPC instance used</td></tr>
  </table>
  </dd>
</dl>
<p>This function will allow the Local core system to set the IPC_FLAG0 event flag for the Remote core system. This will trigger interrupt in the receiving CPU via the PIPE.</p>
<p>Note that the IPC interrupt can only be triggered by IPC flag 0.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Local core acknowledges Remote to Local IPC Flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipcChannel</td><td>is the enum corresponding to the IPC instance used </td></tr>
    <tr><td class="paramname">flags</td><td>is the IPC flag mask for the flags being acknowledged.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will allow the Local core system to acknowledge/clear the IPC flag set by the Remote core system. The <em>flags</em> parameter can be any of the IPC flag values: <b>IPC_FLAG0</b> - <b>IPC_FLAG31</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Determines whether the given IPC flags are busy or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipcChannel</td><td>is the enum corresponding to the IPC instance used </td></tr>
    <tr><td class="paramname">flags</td><td>is the Local to Remote IPC flag masks to check the status of</td></tr>
  </table>
  </dd>
</dl>
<p>Allows the caller to determine whether the designated Local to Remote IPC flags are pending. The <em>flags</em> parameter can be any of the IPC flag values: <b>IPC_FLAG0</b> - <b>IPC_FLAG31</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the any of the designated IPC flags are busy or <b>false</b> if all the designated IPC flags are free.</dd></dl>
<p>Determines whether the given Remote to Local IPC flags are busy or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipcChannel</td><td>is the enum corresponding to the IPC instance used </td></tr>
    <tr><td class="paramname">flags</td><td>is the Remote to Local IPC Flag masks to check the status of</td></tr>
  </table>
  </dd>
</dl>
<p>Allows the caller to determine whether the designated Remote to Local IPC flags are pending. The <em>flags</em> parameter can be any of the IPC flag values: <b>IPC_FLAG0</b> - <b>IPC_FLAG31</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the any of the designated IPC flags are busy or <b>false</b> if all the designated IPC flags are free.</dd></dl>
<p>Wait for the remote core to send a flag</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipcChannel</td><td>is the enum corresponding to the IPC instance used </td></tr>
    <tr><td class="paramname">flag</td><td>is the Remote to Local IPC flag mask to wait for</td></tr>
  </table>
  </dd>
</dl>
<p>Allows the caller to wait for the Remote to Local flag to be send by the remote core. The <em>flags</em> parameter can be any of the IPC flag values: <b>IPC_FLAG0</b> - <b>IPC_FLAG31</b>.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Sends the response to the command sent by remote core.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipcChannel</td><td>is the enum corresponding to the IPC instance used </td></tr>
    <tr><td class="paramname">data</td><td>is the 32-bit value of the response to be sent</td></tr>
  </table>
  </dd>
</dl>
<p>Allows the caller to send a response to the command previously sent by the remote core</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Reads the response from the remote core.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipcChannel</td><td>is the enum corresponding to the IPC instance used</td></tr>
  </table>
  </dd>
</dl>
<p>Allows the caller to read the response sent by the remote core to the command previously sent by the local core</p>
<dl class="section return"><dt>Returns</dt><dd>the 32-bit value of the response.</dd></dl>
<p>Reads the timestamp counter value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipcChannel</td><td>is the enum corresponding to the IPC instance used</td></tr>
  </table>
  </dd>
</dl>
<p>Allows the caller to read the IPC timestamp counter value.</p>
<dl class="section return"><dt>Returns</dt><dd>64-bit counter value.</dd></dl>
<p>Set Maximum Baud Rate Prescaler</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">vclk</td><td>is the LIN VCLK (Hz) </td></tr>
    <tr><td class="paramname">mbr</td><td>is the desired maximum baud rate (Hz)</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function is used to set the maximum baud rate prescaler used during synchronization phase of a responder module if the ADAPT bit is set. The operating baud rate in the LIN network must be within 10% of the provided maximum baud rate.</p>
<dl class="section note"><dt>Note</dt><dd>Use LIN_enableAutomaticBaudrate() to set the ADAPT bit and enable automatic bit rate mod detection.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set Message filtering Type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">type</td><td>is the mask filtering comparison type</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function sets the message filtering type. The <em>type</em> parameter can be one of the following values:</p><ul>
<li><b>LIN_MSG_FILTER_IDBYTE</b> - Filtering uses LIN message ID Byte</li>
<li><b>LIN_MSG_FILTER_IDRESPONDER</b> - Filtering uses the responder Task ID Byte</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable Parity mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function enables the parity check.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable Parity mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function disables the parity check.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Generate Parity Identifier</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">identifier</td><td>is the LIN header ID byte</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function generates the identifier parity bits and appends them to the identifier.</p>
<dl class="section note"><dt>Note</dt><dd>An ID must be generated with parity before header generation in LIN commander mode when parity is enabled using the function LIN_enableParity().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the identifier appended with parity bits.</dd></dl>
<p>Set ID Byte</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">identifier</td><td>is the LIN header ID byte</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function sets the message ID byte. In commander mode, writing to this ID initiates a header transmission. In responder task, this ID is used for message filtering when HGENCTRL is 0.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set ID-Responder Task Byte</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">identifier</td><td>is the Received ID comparison ID</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function sets the identifier to which the received ID of an incoming Header will be compared in order to decide whether a RX response, a TX response, or no action is required.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Send LIN wakeup signal</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function sends the LIN wakeup signal to terminate the sleep mode of any LIN node connected to the bus.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enter LIN Sleep Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function puts the LIN module into a low-power, sleep mode. This can also be called to forcefully enter sleep when there is no activity on the bus.</p>
<dl class="section note"><dt>Note</dt><dd>If this function is called while the receiver is actively receiving data and the wakeup interrupt is disabled, then the module will delay sleep mode from being entered until completion of reception.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Send Checksum Byte</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function enables the transmitter with extended frames to send a checkbyte.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Trigger Checksum Compare</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function enables the receiver for extended frames to trigger a checksum compare.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Check Tx buffer ready flag</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function checks to see if the Tx ready flag is set indicating that the Tx buffer(s) is/are ready to get another character.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the TX ready flag is set, else returns <b>false</b> </dd></dl>
<p>Set LIN Frame Length</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">length</td><td>is the number of bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function sets the number of bytes in the response field.</p>
<p>The <em>length</em> parameter must be in a range between 1 and 8.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set LIN communication mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">mode</td><td>is the selected communication mode</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function is used to choose how the length of data is conveyed. This choice relates to the version of LIN being used. The <em>mode</em> parameter can have one of two values:</p><ul>
<li><b>LIN_COMM_LIN_USELENGTHVAL</b> will use the length set with the LIN_setFrameLength() function.</li>
<li><b>LIN_COMM_LIN_ID4ID5LENCTL</b> will use ID4 and ID5 for length control.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the transmit ID mask</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">mask</td><td>is the mask value to be set</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function sets the mask used for filtering an incoming ID message to determine if the TX ID flag should be set.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the receive ID mask</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">mask</td><td>is the mask value to be set</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function sets the mask used for filtering an incoming ID message to determine if the ID RX flag should be set.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the transmit ID mask</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function gets the mask used for filtering an incoming ID message to determine if the TX ID flag should be set.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the Transmit ID Mask.</dd></dl>
<p>Gets the receive ID mask</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function gets the mask used for filtering an incoming ID message to determine if the ID RX flag should be set.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the Receive ID Mask.</dd></dl>
<p>Check if Rx data is ready</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, checks to see if the Rx ready bit is set indicating that a valid message frame has been received.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the Rx ready flag is set, else returns <b>false</b>.</dd></dl>
<p>Get last received identifier</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function gets the last received identifier.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the Received Identifier.</dd></dl>
<p>Checks for Tx ID Match Received</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function checks if an ID is received with a TX match and no ID-parity error.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if a valid ID is matched, else returns <b>false</b>.</dd></dl>
<p>Checks for Rx ID Match Received</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function checks if an ID is received with a RX match and no ID-parity error.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if a valid ID is matched, else returns <b>false</b>.</dd></dl>
<p>Enable interrupts</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of the interrupt sources to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function enables the interrupts for the specified interrupt sources.</p>
<p>The <em>intFlags</em> parameter can be set to the following value to set all the flag bits:</p><ul>
<li><b>LIN_INT_ALL</b> - All Interrupts</li>
</ul>
<p>To set individual flags, the <em>intFlags</em> parameter can be the logical OR of any of the following:</p><ul>
<li><b>LIN_INT_WAKEUP</b> - Wakeup</li>
<li><b>LIN_INT_TO</b> - Time out</li>
<li><b>LIN_INT_TOAWUS</b> - Time out after wakeup signal</li>
<li><b>LIN_INT_TOA3WUS</b> - Time out after 3 wakeup signals</li>
<li><b>LIN_INT_TX</b> - Transmit buffer ready</li>
<li><b>LIN_INT_RX</b> - Receive buffer ready</li>
<li><b>LIN_INT_ID</b> - Received matching identifier</li>
<li><b>LIN_INT_PE</b> - Parity error</li>
<li><b>LIN_INT_OE</b> - Overrun error</li>
<li><b>LIN_INT_FE</b> - Framing error</li>
<li><b>LIN_INT_NRE</b> - No response error</li>
<li><b>LIN_INT_ISFE</b> - Inconsistent sync field error</li>
<li><b>LIN_INT_CE</b> - Checksum error</li>
<li><b>LIN_INT_PBE</b> - Physical bus error</li>
<li><b>LIN_INT_BE</b> - Bit error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable interrupts</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of the interrupt sources to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function disables the interrupts for the specified interrupt sources.</p>
<p>The <em>intFlags</em> parameter can be set to the following value to disable all the flag bits:</p><ul>
<li><b>LIN_INT_ALL</b> - All Interrupts</li>
</ul>
<p>To disable individual flags, the <em>intFlags</em> parameter can be the logical OR of any of the following:</p><ul>
<li><b>LIN_INT_WAKEUP</b> - Wakeup</li>
<li><b>LIN_INT_TO</b> - Time out</li>
<li><b>LIN_INT_TOAWUS</b> - Time out after wakeup signal</li>
<li><b>LIN_INT_TOA3WUS</b> - Time out after 3 wakeup signals</li>
<li><b>LIN_INT_TX</b> - Transmit buffer ready</li>
<li><b>LIN_INT_RX</b> - Receive buffer ready</li>
<li><b>LIN_INT_ID</b> - Received matching identifier</li>
<li><b>LIN_INT_PE</b> - Parity error</li>
<li><b>LIN_INT_OE</b> - Overrun error</li>
<li><b>LIN_INT_FE</b> - Framing error</li>
<li><b>LIN_INT_NRE</b> - No response error</li>
<li><b>LIN_INT_ISFE</b> - Inconsistent sync field error</li>
<li><b>LIN_INT_CE</b> - Checksum error</li>
<li><b>LIN_INT_PBE</b> - Physical bus error</li>
<li><b>LIN_INT_BE</b> - Bit error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clear interrupt status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of the interrupt sources to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function clears the specified status flags.</p>
<p>The <em>intFlags</em> parameter can be set to the following value to clear all the flag bits:</p><ul>
<li><b>LIN_INT_ALL</b> - All Interrupts</li>
</ul>
<p>To clear individual flags, the <em>intFlags</em> parameter can be the logical OR of any of the following:</p><ul>
<li><b>LIN_INT_WAKEUP</b> - Wakeup</li>
<li><b>LIN_INT_TO</b> - Time out</li>
<li><b>LIN_INT_TOAWUS</b> - Time out after wakeup signal</li>
<li><b>LIN_INT_TOA3WUS</b> - Time out after 3 wakeup signals</li>
<li><b>LIN_INT_TX</b> - Transmit buffer ready</li>
<li><b>LIN_INT_RX</b> - Receive buffer ready</li>
<li><b>LIN_INT_ID</b> - Received matching identifier</li>
<li><b>LIN_INT_PE</b> - Parity error</li>
<li><b>LIN_INT_OE</b> - Overrun error</li>
<li><b>LIN_INT_FE</b> - Framing error</li>
<li><b>LIN_INT_NRE</b> - No response error</li>
<li><b>LIN_INT_ISFE</b> - Inconsistent sync field error</li>
<li><b>LIN_INT_CE</b> - Checksum error</li>
<li><b>LIN_INT_PBE</b> - Physical bus error</li>
<li><b>LIN_INT_BE</b> - Bit error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set interrupt level to 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of interrupt sources to be configured</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function sets the specified interrupt sources to level 0.</p>
<p>The <em>intFlags</em> parameter can be set to the following value to set all the flag bits:</p><ul>
<li><b>LIN_INT_ALL</b> - All Interrupts</li>
</ul>
<p>To set individual flags, the <em>intFlags</em> parameter can be the logical OR of any of the following:</p><ul>
<li><b>LIN_INT_WAKEUP</b> - Wakeup</li>
<li><b>LIN_INT_TO</b> - Time out</li>
<li><b>LIN_INT_TOAWUS</b> - Time out after wakeup signal</li>
<li><b>LIN_INT_TOA3WUS</b> - Time out after 3 wakeup signals</li>
<li><b>LIN_INT_TX</b> - Transmit buffer ready</li>
<li><b>LIN_INT_RX</b> - Receive buffer ready</li>
<li><b>LIN_INT_ID</b> - Received matching identifier</li>
<li><b>LIN_INT_PE</b> - Parity error</li>
<li><b>LIN_INT_OE</b> - Overrun error</li>
<li><b>LIN_INT_FE</b> - Framing error</li>
<li><b>LIN_INT_NRE</b> - No response error</li>
<li><b>LIN_INT_ISFE</b> - Inconsistent sync field error</li>
<li><b>LIN_INT_CE</b> - Checksum error</li>
<li><b>LIN_INT_PBE</b> - Physical bus error</li>
<li><b>LIN_INT_BE</b> - Bit error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set interrupt level to 1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of interrupt sources to be configured</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function sets the specified interrupt sources to level 1.</p>
<p>The <em>intFlags</em> parameter can be set to the following value to set all the flag bits:</p><ul>
<li><b>LIN_INT_ALL</b> - All Interrupts</li>
</ul>
<p>To set individual flags, the <em>intFlags</em> parameter can be the logical OR of any of the following:</p><ul>
<li><b>LIN_INT_WAKEUP</b> - Wakeup</li>
<li><b>LIN_INT_TO</b> - Time out</li>
<li><b>LIN_INT_TOAWUS</b> - Time out after wakeup signal</li>
<li><b>LIN_INT_TOA3WUS</b> - Time out after 3 wakeup signals</li>
<li><b>LIN_INT_TX</b> - Transmit buffer ready</li>
<li><b>LIN_INT_RX</b> - Receive buffer ready</li>
<li><b>LIN_INT_ID</b> - Received matching identifier</li>
<li><b>LIN_INT_PE</b> - Parity error</li>
<li><b>LIN_INT_OE</b> - Overrun error</li>
<li><b>LIN_INT_FE</b> - Framing error</li>
<li><b>LIN_INT_NRE</b> - No response error</li>
<li><b>LIN_INT_ISFE</b> - Inconsistent sync field error</li>
<li><b>LIN_INT_CE</b> - Checksum error</li>
<li><b>LIN_INT_PBE</b> - Physical bus error</li>
<li><b>LIN_INT_BE</b> - Bit error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable Module Errors for Testing</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">errors</td><td>is the specified errors to be enabled</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function enables the specified errors in the module for testing. The <em>errors</em> parameter can be a logical OR-ed result of the following values or <b>LIN_ALL_ERRORS</b> can be used to enable all of them:</p><ul>
<li><b>LIN_BIT_ERROR</b> - Simulates a bit error</li>
<li><b>LIN_BUS_ERROR</b> - Simulates a physical bus error</li>
<li><b>LIN_CHECKSUM_ERROR</b> - Simulates a checksum error</li>
<li><b>LIN_ISF_ERROR</b> - Simulates an inconsistent synch field error</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>To disable these errors, use the LIN_disableModuleErrors() function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable Module Errors for Testing</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">errors</td><td>is the specified errors to be disabled</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function disables the specified errors in the module for testing. The <em>errors</em> parameter can be a logical OR-ed result of the following values or <b>LIN_ALL_ERRORS</b> can be used to disable all of them:</p><ul>
<li><b>LIN_BIT_ERROR</b> - Simulates a bit error</li>
<li><b>LIN_BUS_ERROR</b> - Simulates a physical bus error</li>
<li><b>LIN_CHECKSUM_ERROR</b> - Simulates a checksum error</li>
<li><b>LIN_ISF_ERROR</b> - Simulates an inconsistent synch field error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable Automatic Baudrate Adjustment</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function enables the automatic baudrate adjustment mode during the detection of the Synch Field.</p>
<dl class="section note"><dt>Note</dt><dd>The baudrate selection register will be updated automatically by a responder node if this mode is enabled.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable Automatic Baudrate Adjustment</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function disables the automatic baudrate adjustment mode during the detection of the Synch Field. This results in a fixed baud rate.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Stops LIN Extended Frame Communication</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function stops the extended frame communication. Once stopped, the bit is automatically cleared.</p>
<dl class="section note"><dt>Note</dt><dd>This function can only be called during extended frame communication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set Checksum Type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">type</td><td>is the checksum type</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function sets the checksum type. The <em>type</em> parameter can be one of the following two values:</p><ul>
<li><b>LIN_CHECKSUM_CLASSIC</b> - Checksum Classic</li>
<li><b>LIN_CHECKSUM_ENHANCED</b> - Checksum Enhanced</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set Sync Break Extend and Delimiter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">syncBreak</td><td>is the sync break extend value </td></tr>
    <tr><td class="paramname">delimiter</td><td>is the sync delimiter value</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN mode only, this function sets the 3-bit sync break extend value and the 2-bit sync delimiter compare value.</p>
<p>The <em>break</em> parameter can be a value between 0 to 7. Details:</p><ul>
<li><b>0</b> - Sync Break has no additional T-bit</li>
<li><b>1</b> - Sync Break has 1 additional T-bit</li>
<li><b></b>...</li>
<li><b>7</b> - Sync Break has 7 additional T-bits</li>
</ul>
<p>The <em>delimiter</em> parameter can be a value between 1 to 4. Details:</p><ul>
<li><b>1</b> - Delimiter has 1 T-bit</li>
<li><b>2</b> - Delimiter has 2 T-bits</li>
<li><b>3</b> - Delimiter has 3 T-bits</li>
<li><b>4</b> - Delimiter has 4 T-bits</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable SCI Mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the LIN peripheral to function as a SCI.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable SCI Mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the SCI mode of the LIN peripheral.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set SCI communication mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">mode</td><td>is the selected communication mode</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function is used to select between idle-line mode and address-bit mode. The <em>mode</em> parameter can have one of the following values:</p><ul>
<li><b>LIN_COMM_SCI_IDLELINE</b> - Idle-line mode.</li>
<li><b>LIN_COMM_SCI_ADDRBIT</b> - Address-bit mode.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable SCI Parity mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">parity</td><td>is the SCI parity type</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function enables the parity check and sets the parity type. The <em>parity</em> parameter can one of the following values:</p><ul>
<li><b>LIN_SCI_PAR_ODD</b> - Sets Odd parity</li>
<li><b>LIN_SCI_PAR_EVEN</b> - Sets Even parity</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable SCI Parity mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function disables the parity check.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the number of stop bits for SCI</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">number</td><td>is the number of stop bits</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function sets the number of stop bits transmitted. The <em>number</em> parameter can be one of the following values:</p><ul>
<li><b>LIN_SCI_STOP_ONE</b> - Set one stop bit</li>
<li><b>LIN_SCI_STOP_TWO</b> - Set two stop bits</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable SCI Sleep mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function enables the receive sleep mode functionality.</p>
<dl class="section note"><dt>Note</dt><dd>The receiver still operates when the sleep mode is enabled, however, RXRDY is updated and SCIRD is loaded with new data only when an address frame is detected.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable SCI Sleep mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function disables the receive sleep mode functionality.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enter SCI Local Low-Power Mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function enters the SCI local low-power mode.</p>
<dl class="section note"><dt>Note</dt><dd>If this function is called while the receiver is actively receiving data and the wakeup interrupt is disabled, then the module will delay sleep mode from being entered until completion of reception.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Exit SCI Local Low-Power Mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function exits the SCI local low-power mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set SCI character length</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">numBits</td><td>is the number of bits per character.</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function sets the number of bits per character.</p>
<p>The <em>numBits</em> parameter must be in a range between 1 and 8.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set SCI Frame Length</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">length</td><td>is the number of characters</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function sets the number of characters in the response field.</p>
<p>The <em>length</em> parameter must be in a range between 1 and 8.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Check if new SCI data is ready to be read</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function checks to see if the Rx ready bit is set indicating that a new data has been received.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the Rx ready flag is set, else returns <b>false</b>.</dd></dl>
<p>Check if space is available in SCI Transmit Buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function checks to see if the Tx ready flag is set indicating that the Tx buffer(s) is/are ready to get another character.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the TX ready flag is set, else returns <b>false</b> </dd></dl>
<p>Reads a SCI character without blocking</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">emulation</td><td>sets whether the data is being read by an emulator or not</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function gets the byte of data received. The <em>emulation</em> parameter can have one of the following values:</p><ul>
<li><b>true</b> - Emulator is being used, the RXRDY flag won't be cleared</li>
<li><b>false</b> - Emulator isn't being used, the RXRDY flag will be cleared automatically on read</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>If the SCI receives data that is fewer than 8 bits in length, the data is left-justified and padded with trailing zeros.</li>
<li>To determine if new data is available to read, use the function LIN_isSCIDataAvailable().</li>
</ol>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the received data.</dd></dl>
<p>Reads a SCI character with Blocking</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">emulation</td><td>sets whether the data is being read by an emulator or not</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function gets the byte of data received. If new data isn't available, this function will wait until new data arrives. The <em>emulation</em> parameter can have one of the following values:</p><ul>
<li><b>true</b> - Emulator is being used, the RXRDY flag won't be cleared</li>
<li><b>false</b> - Emulator isn't being used, the RXRDY flag will be cleared automatically on read</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If the SCI receives data that is fewer than 8 bits in length, the data is left-justified and padded with trailing zeros.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the received data.</dd></dl>
<p>Sends a SCI character without blocking</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">data</td><td>is the byte of data to be transmitted</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function sets the byte of data to be transmitted without blocking.</p>
<dl class="section note"><dt>Note</dt><dd>The transmit ready flag gets set when this buffer is ready to be loaded with another byte of data. Use LIN_isSCISpaceAvailable() to determine if space is available to write another character.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sends a SCI character with blocking</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">data</td><td>is the byte of data to be transmitted</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function sets the byte of data to be transmitted with blocking functionality. If the buffer isn't ready to get new data written to, this function will wait until space is available.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable SCI Module Errors for Testing</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">errors</td><td>is the specified errors to be enabled</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function enables the specified errors in the module for testing. The <em>errors</em> parameter can be a logical OR-ed result of the following values or <b>LIN_SCI_ALL_ERRORS</b> can be used to enable all of them:</p><ul>
<li><b>LIN_SCI_FRAME_ERROR</b> - Simulates a frame error</li>
<li><b>LIN_SCI_PARITY_ERROR</b> - Simulates a parity error</li>
<li><b>LIN_SCI_BREAK_ERROR</b> - Simulates a break detect error</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>To disable these errors, use the LIN_disableSCIModuleErrors() function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable SCI Module Errors for Testing</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">errors</td><td>is the specified errors to be disabled</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function disables the specified errors in the module for testing. The <em>errors</em> parameter can be a logical OR-ed result of the following values or <b>LIN_SCI_ALL_ERRORS</b> can be used to enable all of them:</p><ul>
<li><b>LIN_SCI_FRAME_ERROR</b> - Simulates a frame error</li>
<li><b>LIN_SCI_PARITY_ERROR</b> - Simulates a parity error</li>
<li><b>LIN_SCI_BREAK_ERROR</b> - Simulates a break detect error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable SCI interrupts</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of the interrupt sources to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function enables the interrupts for the specified interrupt sources.</p>
<p>The <em>intFlags</em> parameter can be set to the following value to set all the flag bits:</p><ul>
<li><b>LIN_SCI_INT_ALL</b> - All Interrupts</li>
</ul>
<p>To set individual flags, the <em>intFlags</em> parameter can be the logical OR of any of the following:</p><ul>
<li><b>LIN_SCI_INT_BREAK</b> - Break Detect</li>
<li><b>LIN_SCI_INT_WAKEUP</b> - Wakeup</li>
<li><b>LIN_SCI_INT_TX</b> - Transmit Buffer</li>
<li><b>LIN_SCI_INT_RX</b> - Receive Buffer</li>
<li><b>LIN_SCI_INT_TX_DMA</b> - DMA Transmit</li>
<li><b>LIN_SCI_INT_RX_DMA</b> - DMA Receive</li>
<li><b>LIN_SCI_INT_RX_DMA_ALL</b> - DMA Receive All</li>
<li><b>LIN_SCI_INT_PARITY</b> - Parity Error</li>
<li><b>LIN_SCI_INT_OVERRUN</b> - Overrun Error</li>
<li><b>LIN_SCI_INT_FRAME</b> - Framing Error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable SCI interrupts</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of the interrupt sources to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function disables the interrupts for the specified interrupt sources.</p>
<p>The <em>intFlags</em> parameter can be set to the following value to disable all the flag bits:</p><ul>
<li><b>LIN_SCI_INT_ALL</b> - All Interrupts</li>
</ul>
<p>To disable individual flags, the <em>intFlags</em> parameter can be the logical OR of any of the following:</p><ul>
<li><b>LIN_SCI_INT_BREAK</b> - Break Detect</li>
<li><b>LIN_SCI_INT_WAKEUP</b> - Wakeup</li>
<li><b>LIN_SCI_INT_TX</b> - Transmit Buffer</li>
<li><b>LIN_SCI_INT_RX</b> - Receive Buffer</li>
<li><b>LIN_SCI_INT_TX_DMA</b> - DMA Transmit</li>
<li><b>LIN_SCI_INT_RX_DMA</b> - DMA Receive</li>
<li><b>LIN_SCI_INT_RX_DMA_ALL</b> - DMA Receive All</li>
<li><b>LIN_SCI_INT_PARITY</b> - Parity Error</li>
<li><b>LIN_SCI_INT_OVERRUN</b> - Overrun Error</li>
<li><b>LIN_SCI_INT_FRAME</b> - Framing Error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clear SCI interrupt status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of the interrupt sources to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function clears the specified status flags.</p>
<p>The <em>intFlags</em> parameter can be set to the following value to clear all the flag bits:</p><ul>
<li><b>LIN_SCI_INT_ALL</b> - All Interrupts</li>
</ul>
<p>To clear individual flags, the <em>intFlags</em> parameter can be the logical OR of any of the following:</p><ul>
<li><b>LIN_SCI_INT_BREAK</b> - Break Detect</li>
<li><b>LIN_SCI_INT_WAKEUP</b> - Wakeup</li>
<li><b>LIN_SCI_INT_TX</b> - Transmit Buffer</li>
<li><b>LIN_SCI_INT_RX</b> - Receive Buffer</li>
<li><b>LIN_SCI_INT_TX_DMA</b> - DMA Transmit</li>
<li><b>LIN_SCI_INT_RX_DMA</b> - DMA Receive</li>
<li><b>LIN_SCI_INT_RX_DMA_ALL</b> - DMA Receive All</li>
<li><b>LIN_SCI_INT_PARITY</b> - Parity Error</li>
<li><b>LIN_SCI_INT_OVERRUN</b> - Overrun Error</li>
<li><b>LIN_SCI_INT_FRAME</b> - Framing Error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set SCI interrupt level to 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of interrupt sources to be configured</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function sets the specified interrupt sources to level 0.</p>
<p>The <em>intFlags</em> parameter can be set to the following value to set all the flag bits:</p><ul>
<li><b>LIN_SCI_INT_ALL</b> - All Interrupts</li>
</ul>
<p>To set individual flags, the <em>intFlags</em> parameter can be the logical OR of any of the following:</p><ul>
<li><b>LIN_SCI_INT_BREAK</b> - Break Detect</li>
<li><b>LIN_SCI_INT_WAKEUP</b> - Wakeup</li>
<li><b>LIN_SCI_INT_TX</b> - Transmit Buffer</li>
<li><b>LIN_SCI_INT_RX</b> - Receive Buffer</li>
<li><b>LIN_SCI_INT_TX_DMA</b> - DMA Transmit</li>
<li><b>LIN_SCI_INT_RX_DMA</b> - DMA Receive</li>
<li><b>LIN_SCI_INT_RX_DMA_ALL</b> - DMA Receive All</li>
<li><b>LIN_SCI_INT_PARITY</b> - Parity Error</li>
<li><b>LIN_SCI_INT_OVERRUN</b> - Overrun Error</li>
<li><b>LIN_SCI_INT_FRAME</b> - Framing Error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set SCI interrupt level to 1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of interrupt sources to be configured</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function sets the specified interrupt sources to level 1.</p>
<p>The <em>intFlags</em> parameter can be set to the following value to set all the flag bits:</p><ul>
<li><b>LIN_SCI_INT_ALL</b> - All Interrupts</li>
</ul>
<p>To set individual flags, the <em>intFlags</em> parameter can be the logical OR of any of the following:</p><ul>
<li><b>LIN_SCI_INT_BREAK</b> - Break Detect</li>
<li><b>LIN_SCI_INT_WAKEUP</b> - Wakeup</li>
<li><b>LIN_SCI_INT_TX</b> - Transmit Buffer</li>
<li><b>LIN_SCI_INT_RX</b> - Receive Buffer</li>
<li><b>LIN_SCI_INT_TX_DMA</b> - DMA Transmit</li>
<li><b>LIN_SCI_INT_RX_DMA</b> - DMA Receive</li>
<li><b>LIN_SCI_INT_RX_DMA_ALL</b> - DMA Receive All</li>
<li><b>LIN_SCI_INT_PARITY</b> - Parity Error</li>
<li><b>LIN_SCI_INT_OVERRUN</b> - Overrun Error</li>
<li><b>LIN_SCI_INT_FRAME</b> - Framing Error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Check if SCI Receiver is Idle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function checks if the receiver is in an idle state.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the state is idle, else returns <b>false</b>.</dd></dl>
<p>Gets the SCI Transmit Frame Type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function gets the transmit frame type which can be either data or an address.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the frame will be an address, and returns <b>false</b> if the frame will be data.</dd></dl>
<p>Gets the SCI Receiver Frame Type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function gets the receiver frame type which can be either an address or not an address.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the frame is an address, and returns <b>false</b> if the frame isn't an address.</dd></dl>
<p>Check if SCI Detected a Break Condition</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In SCI mode only, this function checks if the module detected a break condition on the Rx pin.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if break detected, else returns <b>false</b>.</dd></dl>
<p>Enables the LIN module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function sets the RESET bit of the SCIGCR0 register. Registers in this module are not writable until this has been done. Additionally, the transmit and receive pin control functionality is enabled.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable the LIN module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function clears the RESET bit of the SCIGCR0 register. Registers in this module are not writable when this bit is cleared. Additionally, the transmit and receive pin control functionality is disabled.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set Baud Rate Prescaler</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">prescaler</td><td>is the 24-bit integer prescaler </td></tr>
    <tr><td class="paramname">divider</td><td>is the 4-bit fractional divider</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function is used to set the baudrate based on the <em>prescaler</em> and <em>divider</em> values.</p>
<p>P = Prescaler <br  />
M = Fractional Divider <br  />
Bitrate = (SYSCLOCK) / ((P + 1 + M/16) * 16) <br  />
 </p><dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable Transmit Data Transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function enables the transfer of data from SCITD or TDy to the transmit shift register.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable Transmit Data Transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function disables the transfer of data from SCITD or TDy to the transmit shift register.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable Receive Data Transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function enables the receiver to transfer data from the shift buffer register to the receive buffer or multi-buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable Receive Data Transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function disables the receiver to transfer data from the shift buffer register to the receive buffer or multi-buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Perform software reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function will reset the LIN state machine and clear all pending flags. It is required to call this function after a wakeup signal has been sent.</p>
<p>To enter the reset state separately, use LIN_enterSoftwareReset(). To come out of reset, use LIN_exitSoftwareReset().</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Put LIN into its reset state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function will reset the LIN state machine and clear all pending flags. It is required to call this function after a wakeup signal has been sent. When in this state, changes to the configuration of this module may be made.</p>
<p>To take LIN out of the reset state and back into the ready state, use LIN_exitSoftwareReset().</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Put LIN into its ready state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function will put LIN into its ready state. Transmission and reception can be done in this state. While in the ready state, configuration of the module should not be changed.</p>
<p>To put the module into its reset state, use LIN_enterSoftwareReset().</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Check if Bus is busy</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function checks if the receiver bus is busy receiving a frame.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the bus is busy, else returns <b>false</b>.</dd></dl>
<p>Check if the Transmit Buffer is Empty</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function checks if the transmit buffer is empty or not.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the Tx buffer is empty, else returns <b>false</b>.</dd></dl>
<p>Enable External Loopback mode for self test</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">loopbackType</td><td>is the loopback type (analog or digital) </td></tr>
    <tr><td class="paramname">path</td><td>sets the transmit or receive pin to be included in the communication path (Analog loopback mode only)</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function enables the external Loopback mode for self test. The <em>loopbackType</em> parameter can be one of the following values:</p><ul>
<li><b>LIN_LOOPBACK_DIGITAL</b> - Digital Loopback</li>
<li><b>LIN_LOOPBACK_ANALOG</b> - Analog Loopback</li>
</ul>
<p>The <em>path</em> parameter is only applicable in analog loopback mode and can be one of the following values:</p><ul>
<li><b>LIN_ANALOG_LOOP_NONE</b> - Default option for digital loopback mode</li>
<li><b>LIN_ANALOG_LOOP_TX</b> - Enables analog loopback through the Tx pin</li>
<li><b>LIN_ANALOG_LOOP_RX</b> - Enables analog loopback through the Rx pin</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable External Loopback mode for self test</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function disables the external Loopback mode.</p>
<dl class="section note"><dt>Note</dt><dd>This function also resets the analog loopback communication path to the default transmit pin.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable Internal Loopback mode for self test</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function enables the internal Loopback mode for self test.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable Internal Loopback mode for self test</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function disables the internal Loopback mode for self test.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get Interrupt Flags Status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function returns the interrupt status register.</p>
<p>The following flags can be used to mask the value returned:</p><ul>
<li><b>LIN_FLAG_BREAK</b> - Break Detect Flag (SCI mode only)</li>
<li><b>LIN_FLAG_WAKEUP</b> - Wake-up Flag</li>
<li><b>LIN_FLAG_IDLE</b> - Receiver in Idle State (SCI mode only)</li>
<li><b>LIN_FLAG_BUSY</b> - Busy Flag</li>
<li><b>LIN_FLAG_TO</b> - Bus Idle Timeout Flag (LIN mode only)</li>
<li><b>LIN_FLAG_TOAWUS</b> - Timeout after Wakeup Signal (LIN mode only)</li>
<li><b>LIN_FLAG_TOA3WUS</b> - Timeout after 3 Wakeup Signals (LIN mode only)</li>
<li><b>LIN_FLAG_TXRDY</b> - Transmitter Buffer Ready Flag</li>
<li><b>LIN_FLAG_RXRDY</b> - Receiver Buffer Ready Flag</li>
<li><b>LIN_FLAG_TXWAKE</b> - Transmitter Wakeup Method Select (SCI mode only)</li>
<li><b>LIN_FLAG_TXEMPTY</b> - Transmitter Empty Flag</li>
<li><b>LIN_FLAG_RXWAKE</b> - Receiver Wakeup Detect Flag</li>
<li><b>LIN_FLAG_TXID</b> - Identifier on Transmit Flag (LIN mode only)</li>
<li><b>LIN_FLAG_RXID</b> - Identifier on Receive Flag (LIN mode only)</li>
<li><b>LIN_FLAG_PE</b> - Parity Error Flag</li>
<li><b>LIN_FLAG_OE</b> - Overrun Error Flag</li>
<li><b>LIN_FLAG_FE</b> - Framing Error Flag</li>
<li><b>LIN_FLAG_NRE</b> - No-Response Error Flag (LIN mode only)</li>
<li><b>LIN_FLAG_ISFE</b> - Inconsistent Synch Field Error Flag (LIN mode only)</li>
<li><b>LIN_FLAG_CE</b> - Checksum Error Flag (LIN mode only)</li>
<li><b>LIN_FLAG_PBE</b> - Physical Bus Error Flag (LIN mode only)</li>
<li><b>LIN_FLAG_BE</b> - Bit Error Flag (LIN mode only)</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns the status flag register.</dd></dl>
<p>Get the Interrupt Level</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function gets the interrupt level status for all interrupt sources.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of the interrupt level register.</dd></dl>
<p>Gets the Interrupt Vector Offset for Line 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function gets the offset for interrupt line 0. A read to the specified line register updates its value to the next highest priority pending interrupt in the flag register and clears the flag corresponding to the offset that was read.</p>
<dl class="section note"><dt>Note</dt><dd>The flags for the receive and the transmit interrupts cannot be cleared by reading the corresponding offset vector in this function.</dd></dl>
<p>The following are values that can be returned:</p><ul>
<li><b>LIN_VECT_NONE</b> - No Interrupt</li>
<li><b>LIN_VECT_WAKEUP</b> - Wakeup</li>
<li><b>LIN_VECT_ISFE</b> - Inconsistent-sync-field Error</li>
<li><b>LIN_VECT_PE</b> - Parity Error</li>
<li><b>LIN_VECT_ID</b> - ID Interrupt</li>
<li><b>LIN_VECT_PBE</b> - Physical Bus Error</li>
<li><b>LIN_VECT_FE</b> - Frame Error</li>
<li><b>LIN_VECT_BREAK</b> - Break detect</li>
<li><b>LIN_VECT_CE</b> - Checksum Error</li>
<li><b>LIN_VECT_OE</b> - Overrun Error</li>
<li><b>LIN_VECT_BE</b> - Bit Error</li>
<li><b>LIN_VECT_RX</b> - Receive Interrupt</li>
<li><b>LIN_VECT_TX</b> - Transmit Interrupt</li>
<li><b>LIN_VECT_NRE</b> - No-response Error</li>
<li><b>LIN_VECT_TOAWUS</b> - Timeout after wakeup signal</li>
<li><b>LIN_VECT_TOA3WUS</b> - Timeout after 3 wakeup signals</li>
<li><b>LIN_VECT_TO</b> - Timeout (Bus Idle)</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns the interrupt vector offset for interrupt line 0.</dd></dl>
<p>Gets the Interrupt Vector Offset for Line 1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function gets the offset for interrupt line 1. A read to the specified line register updates its value to the next highest priority pending interrupt in the flag register and clears the flag corresponding to the offset that was read.</p>
<dl class="section note"><dt>Note</dt><dd>The flags for the receive and the transmit interrupts cannot be cleared by reading the corresponding offset vector in this function.</dd></dl>
<p>The following are values that can be returned:</p><ul>
<li><b>LIN_VECT_NONE</b> - No Interrupt</li>
<li><b>LIN_VECT_WAKEUP</b> - Wakeup</li>
<li><b>LIN_VECT_ISFE</b> - Inconsistent-sync-field Error</li>
<li><b>LIN_VECT_PE</b> - Parity Error</li>
<li><b>LIN_VECT_ID</b> - ID Interrupt</li>
<li><b>LIN_VECT_PBE</b> - Physical Bus Error</li>
<li><b>LIN_VECT_FE</b> - Frame Error</li>
<li><b>LIN_VECT_BREAK</b> - Break detect</li>
<li><b>LIN_VECT_CE</b> - Checksum Error</li>
<li><b>LIN_VECT_OE</b> - Overrun Error</li>
<li><b>LIN_VECT_BE</b> - Bit Error</li>
<li><b>LIN_VECT_RX</b> - Receive Interrupt</li>
<li><b>LIN_VECT_TX</b> - Transmit Interrupt</li>
<li><b>LIN_VECT_NRE</b> - No-response Error</li>
<li><b>LIN_VECT_TOAWUS</b> - Timeout after wakeup signal</li>
<li><b>LIN_VECT_TOA3WUS</b> - Timeout after 3 wakeup signals</li>
<li><b>LIN_VECT_TO</b> - Timeout (Bus Idle)</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns the interrupt vector offset for interrupt line 1.</dd></dl>
<p>Enable Multi-buffer Mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function enables the multi-buffer mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable Multi-buffer Mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function disables the multi-buffer mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set Transmit Pin Delay</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">delay</td><td>is number of clock delays for the Tx pin (0 to 7)</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function sets the delay by which the value on the transmit pin is delayed so that the value on the receive pin is asynchronous.</p>
<dl class="section note"><dt>Note</dt><dd>This is not applicable to the Start bit.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set Pin Sample Mask</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">mask</td><td>is the pin sample mask to be set</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function sets sample number at which the transmit pin value that is being transmitted will be inverted to verify the receive pin samples correctly with the majority detection circuitry. The <em>mask</em> parameter can be one of the following values:</p><ul>
<li><b>LIN_PINMASK_NONE</b> - No mask</li>
<li><b>LIN_PINMASK_CENTER</b> - Invert Tx Pin value at T-bit center</li>
<li><b>LIN_PINMASK_CENTER_SCLK</b> - Invert Tx Pin value at T-bit center + SCLK</li>
<li><b>LIN_PINMASK_CENTER_2SCLK</b> - Invert Tx Pin value at T-bit center + 2 SCLK</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the Debug Suspended Mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">mode</td><td>is the debug mode</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function sets how the module operates when the program is suspended and being debugged with an emulator. The <em>mode</em> parameter can be one of the following values:</p><ul>
<li><b>LIN_DEBUG_FROZEN</b> - The module state machine is frozen; transmissions and LIN counters are halted until debug mode is exited.</li>
<li><b>LIN_DEBUG_COMPLETE</b> - The module continues to operate until the current transmit and receive functions are complete.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables a LIN global interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">line</td><td>is specified interrupt vector line</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function globally enables an interrupt corresponding to a specified interrupt line. The <em>line</em> parameter can be one of the following enumerated values:</p>
<ul>
<li><b>LIN_INTERRUPT_LINE0</b> - Interrupt Vector Line 0</li>
<li><b>LIN_INTERRUPT_LINE1</b> - Interrupt Vector Line 1</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables a LIN global interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">line</td><td>is specified interrupt vector line</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function globally disables an interrupt corresponding to a specified interrupt line. The <em>line</em> parameter can be one of the following enumerated values:</p>
<ul>
<li><b>LIN_INTERRUPT_LINE0</b> - Interrupt Vector Line 0</li>
<li><b>LIN_INTERRUPT_LINE1</b> - Interrupt Vector Line 1</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clears a LIN global interrupt flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">line</td><td>is specified interrupt vector line</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function clears the global interrupt flag that corresponds to a specified interrupt line. The <em>line</em> parameter can be one of the following enumerated values:</p>
<ul>
<li><b>LIN_INTERRUPT_LINE0</b> - Interrupt Vector Line 0</li>
<li><b>LIN_INTERRUPT_LINE1</b> - Interrupt Vector Line 1</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Returns a LIN global interrupt flag status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">line</td><td>is specified interrupt vector line</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function returns the status of a global interrupt flag that corresponds to a specified interrupt line. The <em>line</em> parameter can be one of the following enumerated values:</p>
<ul>
<li><b>LIN_INTERRUPT_LINE0</b> - Interrupt Vector Line 0</li>
<li><b>LIN_INTERRUPT_LINE1</b> - Interrupt Vector Line 1</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the interrupt flag is set. Return <b>false</b> if not.</dd></dl>
<p>Get the Status of LIN TX/RX Pin status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the LIN module base address </td></tr>
    <tr><td class="paramname">pin</td><td>is the type of pin that is being read.</td></tr>
  </table>
  </dd>
</dl>
<p>In LIN and SCI mode, this function indicates the current status of LINTX and LINRX pins. the <em>pin</em> parameter can be either LIN_PINTYPE_TX or LIN_PINTYPE_RX.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the pin is high else <b>false</b> if low.</dd></dl>
<p>Enables the PMBus module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables operation of the PMBus module by removing it from the reset state</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables PMBus interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of the interrupt sources to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated PMBus interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt. Disabled sources have no effect on the processor.</p>
<p>The <em>intFlags</em> parameter is the logical OR of any of the following:</p>
<ul>
<li><b>PMBUS_INT_BUS_FREE</b> - Bus Free Interrupt</li>
<li><b>PMBUS_INT_CLK_LOW_TIMEOUT</b> - Clock Low Time-out Interrupt</li>
<li><b>PMBUS_INT_DATA_READY</b> - Data Ready Interrupt</li>
<li><b>PMBUS_INT_DATA_REQUEST</b> - Data Request Interrupt</li>
<li><b>PMBUS_INT_TARGET_ADDR_READY</b> - Target Address Ready Interrupt</li>
<li><b>PMBUS_INT_EOM</b> - End of Message Interrupt</li>
<li><b>PMBUS_INT_ALERT</b> - Alert Detection Interrupt</li>
<li><b>PMBUS_INT_CONTROL</b> - Control Detection Interrupt</li>
<li><b>PMBUS_INT_LOST_ARB</b> - Lost Arbitration Interrupt</li>
<li><b>PMBUS_INT_CLK_HIGH_DETECT</b> - Clock High Detection Interrupt</li>
<li><b>PMBUS_INT_ALL</b> - all PMBus interrupts</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables PMBus interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of the interrupt sources to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated PMBus interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt. Disabled sources have no effect on the processor.</p>
<p>The <em>intFlags</em> parameter has the same definition as the <em>intFlags</em> parameter to PMBus_enableInterrupt().</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Indicates whether or not the PMBus bus is busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>the value of the status register (PMBUS_O_PMBSTS)</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns an indication of whether or not the PMBus bus is busy</p>
<dl class="section note"><dt>Note</dt><dd>The status register is cleared each time it is read, therefore, it should be read once at the beginning of an interrupt service routine using <a class="el" href="group__pmbus__api.html#ga66d713691e1d90751170715f198a16dd">PMBus_getInterruptStatus()</a> and saved to a temporary variable for further processing.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the PMBus bus is busy; otherwise, returns <b>false</b>.</dd></dl>
<p>Indicates whether or not the PEC is valid</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>the value of the status register (PMBUS_O_PMBSTS)</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns an indication of whether or not the received PEC was valid</p>
<dl class="section note"><dt>Note</dt><dd>The status register is cleared each time it is read, therefore, it should be read once at the beginning of an interrupt service routine using PMBus_getStatus() and saved to a temporary variable for further processing.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the PEC is valid; otherwise, returns <b>false</b>.</dd></dl>
<p>Enable I2C mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the PMBus module to work in I2C mode</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable I2C mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the PMBus module to work in PMBus mode</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Read the status register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Contents of the status register.</dd></dl>
<p>Acknowledge the transaction by writing to the PMBACK register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Nack the transaction by writing to the PMBACK register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Alert the controller by asserting the ALERT line</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>A target PMBus can alert the controller by pulling the alert line low. This triggers an Alert Response from the controller`, where the ,controller issues the <b>Alert</b> <b>Response</b> <b>Address</b> on the bus with a read bit and the alerting target is required to reply with its address.</p>
<dl class="section note"><dt>Note</dt><dd>The alerting device should be in target mode.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>De-assert the alert line</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configure the PMBus operation in Controller Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used. </td></tr>
    <tr><td class="paramname">targetAddress</td><td>address of the Target device </td></tr>
    <tr><td class="paramname">byteCount</td><td>number of bytes transmitted (or read) in the message (up to 255) </td></tr>
    <tr><td class="paramname">configWord</td><td>can be a combination of the following<ol type="1">
<li>PMBUS_CONTROLLER_ENABLE_PRC_CALL</li>
<li>PMBUS_CONTROLLER_ENABLE_GRP_CMD</li>
<li>PMBUS_CONTROLLER_ENABLE_PEC</li>
<li>PMBUS_CONTROLLER_ENABLE_EXT_CMD</li>
<li>PMBUS_CONTROLLER_ENABLE_CMD</li>
<li>PMBUS_CONTROLLER_ENABLE_READ</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<p>Assuming the PMBus module is set to Controller mode this function will configure the PMBCCR register. It overwrites the contents of the PMBCCR register. </p><dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>Writing to the PMBCCR register initiates a message on the bus once the bus is free. In the event of a write the TXBUF must be loaded prior to configuration, or very quickly after configuration, before the module starts the bus clock.</li>
<li>If the user does not specify an option for example, PMBUS_CONTROLLER_ENABLE_READ, the code will write a 0 (a write) in its bit field.</li>
<li>setting byteCount to 0U (on a write) triggers a quick command; there is no need to precede this command with the <a class="el" href="group__pmbus__api.html#gaed3c78be30c0bc1f2a98974307db7fa5">PMBus_putControllerData()</a></li>
<li>If transmitting with a non-zero byteCount the user must precede this with the PMBus_putControlllerData(), supplying it with the location of the data and the number of bytes (&lt;= 4). For block transmissions the user will have to call <a class="el" href="group__pmbus__api.html#gaed3c78be30c0bc1f2a98974307db7fa5">PMBus_putControllerData()</a>, PMBus_configController() and then continue calling <a class="el" href="group__pmbus__api.html#gaed3c78be30c0bc1f2a98974307db7fa5">PMBus_putControllerData()</a> transmitting 4 (or less for the final transmit) bytes at a time till all the data bytes are transmitted.</li>
<li>If receiving the user must follow up with the <a class="el" href="group__pmbus__api.html#ga3626236de2910e25587dea923e6008db">PMBus_getData()</a>, supplying it with the location of an empty buffer and the status byte</li>
<li>In cases where the controller must transmit for example, process call, the user must call <a class="el" href="group__pmbus__api.html#gaed3c78be30c0bc1f2a98974307db7fa5">PMBus_putControllerData()</a>, then configure the controlller to transmit the command and two bytes, then call <a class="el" href="group__pmbus__api.html#ga3626236de2910e25587dea923e6008db">PMBus_getData()</a> to read two bytes from the target. The controller module need not be reconfigured between write and read whenever a repeated start is involved in the transaction </li>
</ol>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get the address that the PMBus module will respond to (in target mode)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will query the PMBUS_O_PMBHTA register, this will be the address of the module when used in Target Mode. </p><dl class="section return"><dt>Returns</dt><dd>Address of the PMBus device (in slave mode).</dd></dl>
<p>Set the current device address</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used. </td></tr>
    <tr><td class="paramname">Ownaddress</td><td>: Address to be configured.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the current device address, this will be the own address of the module. </p><dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the target address</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used. </td></tr>
    <tr><td class="paramname">targetAddress</td><td>: Target Address to be configured.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the current device address, this will be the target address. </p><dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Determine the current access (read/write) type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will query the PMBUS_O_PMBHTA register, to determine if the current access type was a read or write access. This bit is relevant only when the PMBus module is addressed as a target.</p>
<dl class="section return"><dt>Returns</dt><dd>an enum of the type PMBus_accessType which specifies if the device, in target mode, was addressed for a read or write operation</dd></dl>
<p>Sets the triggering edge of the Control Interrupt</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used. </td></tr>
    <tr><td class="paramname">intEdge</td><td>interrupt to trigger on rising or falling edge</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the triggering edge of the Clock Low Time-out Interrupt</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used. </td></tr>
    <tr><td class="paramname">intEdge</td><td>interrupt to trigger on rising or falling edge</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables the Zero hold support as opposed to the standard 300 ns hold time</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the Zero hold support to use the standard 300 ns hold time</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the PMBus instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables peripherals to trigger a DMA transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the selected peripheral trigger to start a DMA transfer on the specified channel.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables peripherals from triggering a DMA transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the selected peripheral trigger from starting a DMA transfer on the specified channel. This also disables the use of the software force using the DMA_forceTrigger() API.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Force a peripheral trigger to a DMA channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the peripheral trigger flag and if triggering a DMA burst is enabled (see DMA_enableTrigger()), a DMA burst transfer will be forced.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clears a DMA channel's peripheral trigger flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the peripheral trigger flag. Normally, you would use this function when initializing the DMA for the first time. The flag is cleared automatically when the DMA starts the first burst of a transfer.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the status of a DMA channel's Transfer Status Flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns <b>true</b> if the Transfer Status Flag is set, which means a DMA transfer has begun. This flag is cleared when TRANSFER_COUNT reaches zero, or when the HARDRESET or SOFTRESET bit is set.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the Transfer Status Flag is set. Returns <b>false</b> otherwise.</dd></dl>
<p>Gets the status of a DMA channel's Burst Status Flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns <b>true</b> if the Burst Status Flag is set, which means a DMA burst has begun. This flag is cleared when BURST_COUNT reaches zero, or when the HARDRESET or SOFTRESET bit is set.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the Burst Status Flag is set. Returns <b>false</b> otherwise.</dd></dl>
<p>Gets the status of a DMA channel's Run Status Flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns <b>true</b> if the Run Status Flag is set, which means the DMA channel is enabled. This flag is cleared when a transfer completes (TRANSFER_COUNT = 0) and continuous mode is disabled, or when the HARDRESET, SOFTRESET, or HALT bit is set.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the channel is enabled. Returns <b>false</b> otherwise.</dd></dl>
<p>Gets the status of a DMA channel's Overflow Flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns <b>true</b> if the Overflow Flag is set, which means peripheral event trigger was received while Peripheral Event Trigger Flag was already set. This flag can be cleared by writing to ERRCLR bit, using the function DMA_clearErrorFlag().</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the channel is enabled. Returns <b>false</b> otherwise.</dd></dl>
<p>Gets the status of a DMA channel's peripheral trigger flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns <b>true</b> if a peripheral trigger event has occurred The flag is automatically cleared when the first burst transfer begins, but if needed, it can be cleared using DMA_clearTriggerFlag().</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if a peripheral trigger event has occurred and its flag is set. Returns <b>false</b> otherwise.</dd></dl>
<p>Starts a DMA channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function starts the DMA running, typically after you have configured it. It will wait for the first trigger event to start operation. To halt the channel use DMA_stopChannel().</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Halts a DMA channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function halts the DMA at its current state and any current read-write access is completed. To start the channel again use DMA_startChannel().</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the interrupt generation mode of a DMA channel interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers. </td></tr>
    <tr><td class="paramname">mode</td><td>is a flag to indicate the channel interrupt mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the channel interrupt mode. When the <em>mode</em> parameter is</p><ul>
<li><b>DMA_INT_AT_END</b>, the DMA channel interrupt will be generated at the end of the transfer.</li>
<li><b>DMA_INT_AT_BEGINNING</b>, the interrupt will be generated at the beginning of a new transfer. Generating at the beginning of a new transfer is the default behavior.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables a DMA channel interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated DMA channel;s CPU interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables a DMA channel interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated DMA channel's CPU interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables the DMA channel overrun interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated DMA channel's ability to generate an interrupt upon the detection of an overrun. An overrun is when a peripheral event trigger is received by the DMA before a previous trigger on that channel had been serviced and its flag had been cleared.</p>
<p>Note that this is the same interrupt signal as the interrupt that gets generated at the beginning/end of a transfer. That interrupt must first be enabled using DMA_enableInterrupt() in order for the overrun interrupt to be generated.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the DMA channel overrun interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated DMA channel's ability to generate an interrupt upon the detection of an overrun.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clears the DMA channel error flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears both the DMA channel's sync error flag and its overrun error flag.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the source address for the DMA channel</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers. </td></tr>
    <tr><td class="paramname">*srcAddr</td><td>is a source address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the source address of a DMA channel.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the destination address for the DMA channel</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers. </td></tr>
    <tr><td class="paramname">*destAddr</td><td>is the destination address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the destinaton address of a DMA channel.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the modes supported during burst operation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers. </td></tr>
    <tr><td class="paramname">mode</td><td>is the mode</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the modes supported during burst operation. The Burst signaling can be enabled/ disabled. If enabled, it can be configured to be interrupted or not be interrupted.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Locks the channel configuration registers of all DMA channels</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the first DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>The configuration registers of all the channels are locked (writes will have no effect on them). This can only be done if the corresponding CHCFG_COMMIT.COMMIT is cleared.</p>
<p>This function locks the configuration registers of all the DMA channels</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Unlocks the channel configuration registers of all DMA channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the first DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>The configuration registers of the specified channel are unlocked and can be modified. This can only be done if CHCFG_COMMIT.COMMIT is cleared.</p>
<p>This function unlocks the DMA configuration registers.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Commits the channel configuration registers of all DMA channels</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the first DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function commits the lock on the corresponding DMA channel configuration registers. Once committed, it cannot be revoked except by reset.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Locks the DMA channel configuration registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>The configuration registers of the specified channel are locked (writes will have no effect on them). This will only be done if CHCFG_COMMIT.COMMIT is cleared.</p>
<p>This function locks the DMA channel configuration registers</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Unlocks the DMA channel configuration registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>The configuration registers of the specified channel are unlocked and can be modified. This can only be done if CHCFG_COMMIT.COMMIT is cleared.</p>
<p>This function unlocks the DMA configuration registers.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Commits the DMA channel configuration registers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the DMA channel control registers.</td></tr>
  </table>
  </dd>
</dl>
<p>This function commits the lock on the corresponding DMA channel configuration registers. Once committed, cannot be revoked except by reset.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Disables CSENT receiver</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the CSENT Receiver.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables CRC for fast and slow channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables CRC for fast channel and slow channel to calculate and check.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables CRC for fast and slow channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables CRC calculation and check.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables Pause Pulse after the CRC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables Pause Pulse which will be expected after the CRC. The RX_PPENB must be enabled for frequency drift's detection on the fixed length frames.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables Pause Pulse after the CRC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the pause pulse and sensor will continuously supplying SENT data that calibration pulse follows immediately after CRC.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set CRC Type for CRC checksum calculation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">crcType</td><td>indicates the type for CRC checksum calculation.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the type for CRC checksum calculation. The <em>CRCType</em> specifies the type of CRC used. Valid values can be refered from the enum <em>SENT_CRCType</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set CRC Width for fast channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">crcWidth</td><td>is the number of CRC bits for fast channel.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the CRC Width for fast channel.</p>
<p>The <em>CRCWidth</em> specifies the expected number of CRC bits. Valid values can be refered from the enum <em>SENT_CRCWidth</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the number of data nibbles for standard SENT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">dataNibble</td><td>is the number of data nibbles.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the number of data nibbles for standard SENT.</p>
<p>The <em>dataNibble</em> specifies the number of number of data nibbles should be expected for standard SENT. Some of the enhanced sensors support 7 and 8 nibbles. Valid values can be refered from the enum <em>SENT_DataNibble</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the number of clock cycle per Tick.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">ttClock</td><td>is the number of clock cycle per tick.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the number of clock cycle per tick when generating the internal tick clock. This tick clock is used for the initial calculation of calibration Sync errors (25% differential). The default is 300 (12Ch), which is typically 3 us ticks for 100 Mhz clock.</p>
<p>The <em>ttClock</em> specifies the number of clock cycle per tick. It should be a value between 1 and 65536 clock cycles inclusive.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the CRC checksum calculation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">rxCRC</td><td>is the CRC checksum calculation for data nibbles.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the CRC checksum calculation.</p>
<p>Valid values for <em>rxCRC</em> parameter are:</p><ul>
<li><em>SENT_RX_CRC_WITHOUT_STATUS</em> - CRC checksum calculation for the data nibbles only</li>
<li><em>SENT_RX_CRC_WITH_STATUS</em> - CRC checksum calculation for status nibble and data nibble</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get SENT FIFO data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the received SENT fast channel data located at the top of the receive FIFO. The read data can be timestamp or data0 or data1.</p>
<dl class="section return"><dt>Returns</dt><dd>the received SENT fast channel data.</dd></dl>
<p>Enables DMA Trigger.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables DMA Trigger. The receiver FIFO DMA trigger is generated when the FIFO level is &gt;= trigger level (RFIFO_TRIGLEV)</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables DMA Trigger.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables DMA Trigger.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configure the FIFO Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">fifoMode</td><td>is the FIFO mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the FIFO mode.</p>
<p>The <em>fifoMode</em> specifies whether the Timestamp, data0 and data1 data will be mapped directly to a memory or in FIFO. Valid values can be refered from the enum <em>SENT_FIFOMode</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the number of clock cycle on the Receiver Serial Data input to be filtered out.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">gFiltClock</td><td>is the number of clock cycle to be filtered out.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the number of clock cycle pulse on the Receiver Serial Data input that will be filtered out. Valid values for <em>gFiltClock</em> parameter is range from 0 (bypass) to 255 clock cycles.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables Time Stamp and record at the start of the incoming frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables Time Stamp. The timestamp will be written to the memory and will be recorded at the start of the incoming frame.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables Time Stamp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the Time Stamp.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables write to the memory although data contains error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables ERRDATA write which will write to the memory although the data contains errors.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables write to the memory if data contains error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables NOWR_ERRDATA. The received message with errors will not be written to the FIFO or memory.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables MTP Mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables MTP_Mode. This mode indicates that the Receiver will send the master trigger pulse(s) and then expects Sensor's data response.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables MTP Mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables MTP_Mode. The receiver will not send the master trigger pulses.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the trigger level for receiver FIFO triggerinterrupt and DMA trigger.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">triggerLevel</td><td>is the trigger level.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the trigger level for the receiver FIFO trigger interrupt and the DMA trigger. The <em>triggerLevel</em> level can be from 1 up to the maximum level of the FIFOs depth (16). This field is used only when the FIFO_MODE is 1. Receiver FIFO trigger interrupt will be disabled if RFIFO_TRIGLEV is set to 0 (default value)</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables software reset for SENT module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables software reset for the SENT module.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables software reset for SENT module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables software reset for SENT module.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configure the receiver data sorting format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">dataNumber</td><td>indicates the number of data where the nibbles will be stored. </td></tr>
    <tr><td class="paramname">nibbleNum</td><td>is the number of nibble which will be stored. </td></tr>
    <tr><td class="paramname">nibble</td><td>is the type of nibble.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures where the received nibbles are stored in data0/1 map, as well as where the data nibble or CRC nibble are stored in corresponding FIFO or direct memory location.</p>
<p>The <em>dataNumber</em> number is a desired data number for the received nibbles to be stored. Valid values for this parameter can be referred from enum <em>SENT_DataNumber</em>.</p>
<p>The <em>nibbleNum</em> specifies where the specified <em>nibble</em> will be stored in data 0 or 1.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the timout in clock tick for SENT module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">timeOut</td><td>is specified timout in clock tick unit.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the timeout setting to indicate that no synchronization pulse has been received within the timeout specified. This can be used for functional safety and a timeout interrupt will occur when this time as expired. The Timeout functionality is enabled only after receiving a synchronization pulse.</p>
<p>The <em>timeOut</em> value is specified in clock tick units and it can be disabled by setting the value to 0.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Reads the synchronized serial data input value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the synchronized serial data input value that corresponds to the base address passed into <em>base</em>. It is used to debug 1 bit of the SENT receive at a time.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the synchronized serial data input value.</dd></dl>
<p>Enables an SENT interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of the interrupt sources to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the interrupts for the specified interrupt sources.</p>
<p>To set individual flags, the <em>intFlags</em> parameter can be the logical OR of any of the following:</p><ul>
<li><b>SENT_INT_RFAST_S1DV</b> - Sensor 1 Fast channel valid data</li>
<li><b>SENT_INT_RFAST_S2DV</b> - Sensor 2 Fast channel valid data</li>
<li><b>SENT_INT_RFAST_S3DV</b> - Sensor 3 Fast channel valid data</li>
<li><b>SENT_INT_RFAST_S4DV</b> - Sensor 4 Fast channel valid data</li>
<li><b>SENT_INT_RSLOW_DV</b> - Slow channel data with valid data</li>
<li><b>SENT_INT_RSLOW_CRCERR</b> - Slow channel data with CRC Error</li>
<li><b>SENT_INT_RSLOW_FORMATERR</b> - Slow channel data with Format Error</li>
<li><b>SENT_INT_RFAST_S1CRCE</b> - Sensor 1 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S2CRCE</b> - Sensor 2 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S3CRCE</b> - Sensor 3 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S4CRCE</b> - Sensor 4 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S1FRME</b> - Sensor 1 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RFAST_S2FRME</b> - Sensor 2 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RFAST_S3FRME</b> - Sensor 3 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RFAST_S4FRME</b> - Sensor 4 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RTIMEOUT_S1ERR</b> - Sensor 1 timeout error</li>
<li><b>SENT_INT_RTIMEOUT_S2ERR</b> - Sensor 2 timeout error</li>
<li><b>SENT_INT_RTIMEOUT_S3ERR</b> - Sensor 3 timeout error</li>
<li><b>SENT_INT_RTIMEOUT_S4ERR</b> - Sensor 4 timeout error</li>
<li><b>SENT_INT_RFAST_SYNCERR25</b> - Fast channel sync pulse</li>
<li><b>SENT_INT_RFAST_SYNCERR</b> - Successive calibration pulse error</li>
<li><b>SENT_INT_FREQDRIFT_ERR</b> - Frequency drift error event</li>
<li><b>SENT_INT_RFIFO_TRIGGER</b> - FIFO trigger event</li>
<li><b>SENT_INT_RFIFO_OVFERR</b> - FIFO Overflow Error event</li>
<li><b>SENT_INT_RFIFO_UNDFERR</b> - FIFO Underflow Error event</li>
<li><b>SENT_INT_OVFTRIG_BCERR</b> - Broadcast channel overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S1ERR</b> - Sensor 1 overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S2ERR</b> - Sensor 2 overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S3ERR</b> - Sensor 3 overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S4ERR</b> - Sensor 4 overflow trigger error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables an SENT interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of the interrupt sources to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the interrupts for the specified interrupt sources.</p>
<p>To disable individual flags, the <em>intFlags</em> parameter can be the logical OR of any of the following:</p><ul>
<li><b>SENT_INT_RFAST_S1DV</b> - Sensor 1 Fast channel valid data</li>
<li><b>SENT_INT_RFAST_S2DV</b> - Sensor 2 Fast channel valid data</li>
<li><b>SENT_INT_RFAST_S3DV</b> - Sensor 3 Fast channel valid data</li>
<li><b>SENT_INT_RFAST_S4DV</b> - Sensor 4 Fast channel valid data</li>
<li><b>SENT_INT_RSLOW_DV</b> - Slow channel data with valid data</li>
<li><b>SENT_INT_RSLOW_CRCERR</b> - Slow channel data with CRC Error</li>
<li><b>SENT_INT_RSLOW_FORMATERR</b> - Slow channel data with Format Error</li>
<li><b>SENT_INT_RFAST_S1CRCE</b> - Sensor 1 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S2CRCE</b> - Sensor 2 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S3CRCE</b> - Sensor 3 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S4CRCE</b> - Sensor 4 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S1FRME</b> - Sensor 1 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RFAST_S2FRME</b> - Sensor 2 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RFAST_S3FRME</b> - Sensor 3 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RFAST_S4FRME</b> - Sensor 4 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RTIMEOUT_S1ERR</b> - Sensor 1 timeout error</li>
<li><b>SENT_INT_RTIMEOUT_S2ERR</b> - Sensor 2 timeout error</li>
<li><b>SENT_INT_RTIMEOUT_S3ERR</b> - Sensor 3 timeout error</li>
<li><b>SENT_INT_RTIMEOUT_S4ERR</b> - Sensor 4 timeout error</li>
<li><b>SENT_INT_RFAST_SYNCERR25</b> - Fast channel sync pulse</li>
<li><b>SENT_INT_RFAST_SYNCERR</b> - Successive calibration pulse error</li>
<li><b>SENT_INT_FREQDRIFT_ERR</b> - Frequency drift error event</li>
<li><b>SENT_INT_RFIFO_TRIGGER</b> - FIFO trigger event</li>
<li><b>SENT_INT_RFIFO_OVFERR</b> - FIFO Overflow Error event</li>
<li><b>SENT_INT_RFIFO_UNDFERR</b> - FIFO Underflow Error event</li>
<li><b>SENT_INT_OVFTRIG_BCERR</b> - Broadcast channel overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S1ERR</b> - Sensor 1 overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S2ERR</b> - Sensor 2 overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S3ERR</b> - Sensor 3 overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S4ERR</b> - Sensor 4 overflow trigger error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets an SENT interrupt source status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of the interrupt sources to get the status.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the interrupt status for the specified interrupt sources.</p>
<p>To get individual flags, the <em>intFlags</em> parameter can be the logical OR of any of the following:</p><ul>
<li><b>SENT_INT_GLBL</b> - whenever interrupt occurs</li>
<li><b>SENT_INT_RFAST_S1DV</b> - Sensor 1 Fast channel valid data</li>
<li><b>SENT_INT_RFAST_S2DV</b> - Sensor 2 Fast channel valid data</li>
<li><b>SENT_INT_RFAST_S3DV</b> - Sensor 3 Fast channel valid data</li>
<li><b>SENT_INT_RFAST_S4DV</b> - Sensor 4 Fast channel valid data</li>
<li><b>SENT_INT_RSLOW_DV</b> - Slow channel data with valid data</li>
<li><b>SENT_INT_RSLOW_CRCERR</b> - Slow channel data with CRC Error</li>
<li><b>SENT_INT_RSLOW_FORMATERR</b> - Slow channel data with Format Error</li>
<li><b>SENT_INT_RFAST_S1CRCE</b> - Sensor 1 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S2CRCE</b> - Sensor 2 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S3CRCE</b> - Sensor 3 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S4CRCE</b> - Sensor 4 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S1FRME</b> - Sensor 1 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RFAST_S2FRME</b> - Sensor 2 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RFAST_S3FRME</b> - Sensor 3 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RFAST_S4FRME</b> - Sensor 4 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RTIMEOUT_S1ERR</b> - Sensor 1 timeout error</li>
<li><b>SENT_INT_RTIMEOUT_S2ERR</b> - Sensor 2 timeout error</li>
<li><b>SENT_INT_RTIMEOUT_S3ERR</b> - Sensor 3 timeout error</li>
<li><b>SENT_INT_RTIMEOUT_S4ERR</b> - Sensor 4 timeout error</li>
<li><b>SENT_INT_RFAST_SYNCERR25</b> - Fast channel sync pulse</li>
<li><b>SENT_INT_RFAST_SYNCERR</b> - Successive calibration pulse error</li>
<li><b>SENT_INT_FREQDRIFT_ERR</b> - Frequency drift error event</li>
<li><b>SENT_INT_RFIFO_TRIGGER</b> - FIFO trigger event</li>
<li><b>SENT_INT_RFIFO_OVFERR</b> - FIFO Overflow Error event</li>
<li><b>SENT_INT_RFIFO_UNDFERR</b> - FIFO Underflow Error event</li>
<li><b>SENT_INT_OVFTRIG_BCERR</b> - Broadcast channel overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S1ERR</b> - Sensor 1 overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S2ERR</b> - Sensor 2 overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S3ERR</b> - Sensor 3 overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S4ERR</b> - Sensor 4 overflow trigger error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets an SENT Software interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of the interrupt sources to be set.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the interrupts for the specified interrupt sources.</p>
<p>To set individual flags, the <em>intFlags</em> parameter can be the logical OR of any of the following:</p><ul>
<li><b>SENT_INT_RFAST_S1DV</b> - Sensor 1 Fast channel valid data</li>
<li><b>SENT_INT_RFAST_S2DV</b> - Sensor 2 Fast channel valid data</li>
<li><b>SENT_INT_RFAST_S3DV</b> - Sensor 3 Fast channel valid data</li>
<li><b>SENT_INT_RFAST_S4DV</b> - Sensor 4 Fast channel valid data</li>
<li><b>SENT_INT_RSLOW_DV</b> - Slow channel data with valid data</li>
<li><b>SENT_INT_RSLOW_CRCERR</b> - Slow channel data with CRC Error</li>
<li><b>SENT_INT_RSLOW_FORMATERR</b> - Slow channel data with Format Error</li>
<li><b>SENT_INT_RFAST_S1CRCE</b> - Sensor 1 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S2CRCE</b> - Sensor 2 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S3CRCE</b> - Sensor 3 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S4CRCE</b> - Sensor 4 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S1FRME</b> - Sensor 1 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RFAST_S2FRME</b> - Sensor 2 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RFAST_S3FRME</b> - Sensor 3 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RFAST_S4FRME</b> - Sensor 4 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RTIMEOUT_S1ERR</b> - Sensor 1 timeout error</li>
<li><b>SENT_INT_RTIMEOUT_S2ERR</b> - Sensor 2 timeout error</li>
<li><b>SENT_INT_RTIMEOUT_S3ERR</b> - Sensor 3 timeout error</li>
<li><b>SENT_INT_RTIMEOUT_S4ERR</b> - Sensor 4 timeout error</li>
<li><b>SENT_INT_RFAST_SYNCERR25</b> - Fast channel sync pulse</li>
<li><b>SENT_INT_RFAST_SYNCERR</b> - Successive calibration pulse error</li>
<li><b>SENT_INT_FREQDRIFT_ERR</b> - Frequency drift error event</li>
<li><b>SENT_INT_RFIFO_TRIGGER</b> - FIFO trigger event</li>
<li><b>SENT_INT_RFIFO_OVFERR</b> - FIFO Overflow Error event</li>
<li><b>SENT_INT_RFIFO_UNDFERR</b> - FIFO Underflow Error event</li>
<li><b>SENT_INT_OVFTRIG_BCERR</b> - Broadcast channel overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S1ERR</b> - Sensor 1 overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S2ERR</b> - Sensor 2 overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S3ERR</b> - Sensor 3 overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S4ERR</b> - Sensor 4 overflow trigger error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clears an SENT Software interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of the interrupt sources to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the interrupts for the specified interrupt sources.</p>
<p>To clear individual flags, the <em>intFlags</em> parameter can be the logical OR of any of the following:</p><ul>
<li><b>SENT_INT_RFAST_S1DV</b> - Sensor 1 Fast channel valid data</li>
<li><b>SENT_INT_RFAST_S2DV</b> - Sensor 2 Fast channel valid data</li>
<li><b>SENT_INT_RFAST_S3DV</b> - Sensor 3 Fast channel valid data</li>
<li><b>SENT_INT_RFAST_S4DV</b> - Sensor 4 Fast channel valid data</li>
<li><b>SENT_INT_RSLOW_DV</b> - Slow channel data with valid data</li>
<li><b>SENT_INT_RSLOW_CRCERR</b> - Slow channel data with CRC Error</li>
<li><b>SENT_INT_RSLOW_FORMATERR</b> - Slow channel data with Format Error</li>
<li><b>SENT_INT_RFAST_S1CRCE</b> - Sensor 1 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S2CRCE</b> - Sensor 2 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S3CRCE</b> - Sensor 3 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S4CRCE</b> - Sensor 4 Fast channel data with CRC Error</li>
<li><b>SENT_INT_RFAST_S1FRME</b> - Sensor 1 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RFAST_S2FRME</b> - Sensor 2 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RFAST_S3FRME</b> - Sensor 3 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RFAST_S4FRME</b> - Sensor 4 Fast channel data with Frame Err</li>
<li><b>SENT_INT_RTIMEOUT_S1ERR</b> - Sensor 1 timeout error</li>
<li><b>SENT_INT_RTIMEOUT_S2ERR</b> - Sensor 2 timeout error</li>
<li><b>SENT_INT_RTIMEOUT_S3ERR</b> - Sensor 3 timeout error</li>
<li><b>SENT_INT_RTIMEOUT_S4ERR</b> - Sensor 4 timeout error</li>
<li><b>SENT_INT_RFAST_SYNCERR25</b> - Fast channel sync pulse</li>
<li><b>SENT_INT_RFAST_SYNCERR</b> - Successive calibration pulse error</li>
<li><b>SENT_INT_FREQDRIFT_ERR</b> - Frequency drift error event</li>
<li><b>SENT_INT_RFIFO_TRIGGER</b> - FIFO trigger event</li>
<li><b>SENT_INT_RFIFO_OVFERR</b> - FIFO Overflow Error event</li>
<li><b>SENT_INT_RFIFO_UNDFERR</b> - FIFO Underflow Error event</li>
<li><b>SENT_INT_OVFTRIG_BCERR</b> - Broadcast channel overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S1ERR</b> - Sensor 1 overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S2ERR</b> - Sensor 2 overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S3ERR</b> - Sensor 3 overflow trigger error</li>
<li><b>SENT_INT_OVFTRIG_S4ERR</b> - Sensor 4 overflow trigger error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get SENT Memory data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">SENTWord</td><td>is the number of word you want to read from memory</td></tr>
  </table>
  </dd>
</dl>
<p>This function will return the SENT fast channel data located at the receive FIFO. The read data can be timestamp or data0 or data1. Valid values for SENTWord are between 0 to 15 inclusive.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables channels to generate trigger pulses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">channel</td><td>is the desired MTPG channel.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables channels specified by <em>channel</em> to generate trigger pulses when it is triggered via Hardware or Softwar.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables channels to generate trigger pulses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">channel</td><td>is the desired MTPG channel.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables channels specified by <em>channel</em> to generate trigger pulses when it is triggered via Hardware or Softwar.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the period for Master Trigger Pulse Generator channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">channel</td><td>is the desired MTPG channel. </td></tr>
    <tr><td class="paramname">period</td><td>is the period for MTPG channels.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the total time that the master trigger pulse output waveform is active for the desired channel specified by <em>channel</em>. The <em>period</em> must be larger than all desired Channel Compares' TOGGLETIME value.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Select hardware trigger source for Master Trigger Pulse Generator channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">channel</td><td>is the desired MTPG channel. </td></tr>
    <tr><td class="paramname">triggerSel</td><td>is the trigger source for MTPG.</td></tr>
  </table>
  </dd>
</dl>
<p>This function specifies which hardware trigger source enables the Master Trigger Pulse Generator for specified channel. When the SENT bus is idle and the trigger is received, the start of the pulse trigger is generated by the selected source from <em>triggerSel</em> in the respective <em>channel</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables software trigger for Master Trigger Pulse Generator channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">channel</td><td>is the desired MTPG channel.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables software trigger request for the desired channel specified by the <em>channel</em>. This bit will be cleared automatically after the software trigger request is in service.</p>
<dl class="section note"><dt>Note</dt><dd>The MTPG must be enabled before for desired channel by SENT_enableMTPChannel() API.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables software trigger for Master Trigger Pulse Generator channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">channel</td><td>is the desired MTPG channel.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables software trigger request for the desired channel specified by the <em>channel</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the timout for Sensor channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">timeOut</td><td>is specified timout in clock tick unit.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the timeout setting to indicate that no synchronization pulse has been received within the timeout specified. This can be used for functional safety and a timeout interrupt will occur when this time as expired. The Timeout functionality is enabled only after receiving a synchronization pulse.</p>
<p>The <em>timeOut</em> value is specified in clock tick units and it can be disabled by setting the value to 0.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the toggle time for MTPG output of broadcast channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">compare</td><td>is the desired compare register. </td></tr>
    <tr><td class="paramname">toggleTime</td><td>contains the time of the broadcast channel's MTPG output to be toggled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the toggle time to toggle the broadcast channel's output when the channel couter matches the value specified by <em>compare</em>. The maximum number of toggles possible are limited by the number of compare register (9 for the broadcast channel). To generate one trigger pulse, two compare registers must be non-zero. It is because the compare registers are triggered in sequence, so for example the BC_MTP_CMP9 register must be larger than BC_MTP_CMP8, which must be larger than BC_MTP_CMP7, and so on.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the toggle time for MTPG output of Sensor 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">compare</td><td>is the desired compare register. </td></tr>
    <tr><td class="paramname">toggleTime</td><td>contains the time of the Sensor 1 channel's MTPG output to be toggled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the toggle time to toggle the Sensor 1 channel's output when the channel couter matches the value specified by <em>compare</em>. The maximum number of toggles possible are limited by the number of compare register (9 for the Sensor1 channel and 10th control when the receiver is enabled to sample the RX line). To generate one trigger pulse, two compare registers must be non-zero. It is because the compare registers are triggered in sequence, so for example the S1_MTP_CMP9 register must be larger than S1_MTP_CMP8, which must be larger than S1_MTP_CMP7, and so on. The Sx_MTP_CMP10RE register (where x is 1 to 4) is only used if receiver input gating needs to occur earlier than the period time.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the toggle time for MTPG output of Sensor 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">compare</td><td>is the desired compare register. </td></tr>
    <tr><td class="paramname">toggleTime</td><td>contains the time of the Sensor 2 channel's MTPG output to be toggled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the toggle time to toggle the Sensor 2 channel's output when the channel couter matches the value specified by <em>compare</em>. The maximum number of toggles possible are limited by the number of compare register (9 for the Sensor2 channel and 10th control when the receiver is enabled to sample the RX line). To generate one trigger pulse, two compare registers must be non-zero. It is because the compare registers are triggered in sequence, so for example the S2_MTP_CMP9 register must be larger than S2_MTP_CMP8, which must be larger than S2_MTP_CMP7, and so on. The Sx_MTP_CMP10RE register (where x is 1 to 4) is only used if receiver input gating needs to occur earlier than the period time.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the toggle time for MTPG output of Sensor 3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">compare</td><td>is the desired compare register. </td></tr>
    <tr><td class="paramname">toggleTime</td><td>contains the time of the Sensor 3 channel's MTPG output to be toggled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the toggle time to toggle the Sensor 3 channel's output when the channel couter matches the value specified by <em>compare</em>. The maximum number of toggles possible are limited by the number of compare register (9 for the Sensor3 channel and 10th control when the receiver is enabled to sample the RX line). To generate one trigger pulse, two compare registers must be non-zero. It is because the compare registers are triggered in sequence, so for example the S3_MTP_CMP9 register must be larger than S3_MTP_CMP8, which must be larger than S3_MTP_CMP7, and so on. The Sx_MTP_CMP10RE register (where x is 1 to 4) is only used if receiver input gating needs to occur earlier than the period time.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the toggle time for MTPG output of Sensor 4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">compare</td><td>is the desired compare register. </td></tr>
    <tr><td class="paramname">toggleTime</td><td>contains the time of the Sensor 4 channel's MTPG output to be toggled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the toggle time to toggle the Sensor 4 channel's output when the channel couter matches the value specified by <em>compare</em>. The maximum number of toggles possible are limited by the number of compare register (9 for the Sensor4 channel and 10th control when the receiver is enabled to sample the RX line). To generate one trigger pulse, two compare registers must be non-zero. It is because the compare registers are triggered in sequence, so for example the S4_MTP_CMP9 register must be larger than S4_MTP_CMP8, which must be larger than S4_MTP_CMP7, and so on. The Sx_MTP_CMP10RE register (where x is 1 to 4) is only used if receiver input gating needs to occur earlier than the period time.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the global wait time in clock tick for MTP module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module. </td></tr>
    <tr><td class="paramname">waitTime</td><td>is specified global wait time in clock tick unit.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the global wait time which indicates the delay between the last data frame received to the new master trigger pulse to be generated. After the Sensor's frame received, the trigger generator will wait for WAITTIME before processing the next trigger request.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the MTPG global software reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SENT module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the MTPG global software reset and all the registers will have their default value.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable external reset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables data filter from being reset by an external source (PWM compare output).</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable filter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the filter specified by the <em>filterNumber</em> variable.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable filter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the filter specified by the <em>filterNumber</em> variable.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable FIFO buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the filter FIFO buffer specified by the <em>filterNumber</em> variable.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable FIFO buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the filter FIFO buffer specified by the <em>filterNumber</em> variable.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Return the Zero Cross Trip status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the Zero Cross Trip status for the filter specified by filterNumber variable.</p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if Comparator filter output &gt;= High-level threshold (Z) <b>false</b> if Comparator filter output &lt; High-level threshold (Z)</dd></dl>
<p>Clear the Zero Cross Trip status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the Zero Cross Trip status for the filter specified by filterNumber variable.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable Comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the Comparator for the selected filter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable Comparator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the Comparator for the selected filter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Selects Comparator Event Source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number </td></tr>
    <tr><td class="paramname">compEventNum</td><td>is the event number </td></tr>
    <tr><td class="paramname">compEventSource</td><td>is the event source</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the comparator event source. Valid values for <em>compEventNum</em> are:</p><ul>
<li>SDFM_COMP_EVENT_1 - Selects comparator event 1</li>
<li>SDFM_COMP_EVENT_2 - Selects comparator event 2 Valid values for <em>SDFM_COMP_EVENT_1</em> are:</li>
<li>SDFM_COMP_EVENT_SRC_COMPH1 - COMPH1 event is the source for selected event</li>
<li>SDFM_COMP_EVENT_SRC_COMPH1_L1 - Either of COMPH1 or COMPL1 event can be the source for selected event</li>
<li>SDFM_COMP_EVENT_SRC_COMPH2 - COMPH2 event is the source for selected event</li>
<li>SDFM_COMP_EVENT_SRC_COMPH2_L2 - Either of COMPH2 or COMPL2 event can be the source for selected event</li>
</ul>
<p>Valid values for <em>SDFM_COMP_EVENT_2</em> are:</p><ul>
<li>SDFM_COMP_EVENT_SRC_COMPL1 - COMPL1 event is the source for selected event</li>
<li>SDFM_COMP_EVENT_SRC_COMPH1_L1 - Either of COMPH1 or COMPL1 event can be the source for selected event</li>
<li>SDFM_COMP_EVENT_SRC_COMPL2 - COMPL2 event is the source for selected event</li>
<li>SDFM_COMP_EVENT_SRC_COMPH2_L2 - Either of COMPH2 or COMPL2 event can be the source for selected event</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set filter type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">filterType</td><td>is the filter type or structure.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the filter type or structure to be used as specified by filterType for the selected filter number as specified by filterNumber.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set data filter over sampling ratio.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">overSamplingRatio</td><td>is the data filter over sampling ratio.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the filter oversampling ratio for the filter specified by the filterNumber variable.Valid values for the variable overSamplingRatio are 0 to 255 inclusive. The actual oversampling ratio will be this value plus one.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set modulator clock mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">clockMode</td><td>is the modulator clock mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the modulator clock mode specified by clockMode for the filter specified by filterNumber.</p>
<dl class="section note"><dt>Note</dt><dd>This function also enables the data and clock synchronizers for the specified filter.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the output data format</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">dataFormat</td><td>is the output data format.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the output data format for the filter specified by filterNumber.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set data shift value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">shiftValue</td><td>is the data shift value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the shift value for the 16 bit 2's complement data format. The valid maximum value for shiftValue is 31.</p>
<p><b>Note:</b> Use this function with 16 bit 2's complement data format only.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set Filter output high-level threshold.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">highThreshold</td><td>is the high-level threshold 1 &amp; 2.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the unsigned high-level threshold value for the Comparator filter output. If the output value of the filter exceeds highThreshold and interrupt generation is enabled, an interrupt will be issued. The param <b>highThreshold</b> takes both high threshold 1 &amp; 2 values. The upper 16-bits represent the high threshold 2 value while lower 16-bits represent the threshold 1 values.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set Filter output low-level threshold.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number </td></tr>
    <tr><td class="paramname">lowThreshold</td><td>is the low-level threshold</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the unsigned low-level threshold value 1 or 2 for the Comparator filter output. If the output value of the filter gets below lowThreshold and interrupt generation is enabled, an interrupt will be issued. The param <b>lowThreshold</b> takes both low threshold 1 &amp; 2 values. The upper 16-bits represent the low threshold 2 value while lower 16-bits represent the threshold 1 values.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set Filter output zero-cross threshold.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">zeroCrossThreshold</td><td>is the zero-cross threshold.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the unsigned zero-cross threshold value for the Comparator filter output.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable zero-cross Edge detect mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables Zero Cross Edge detection.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable zero-cross Edge detect mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables Zero Cross Edge detection.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable SDFM interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the interrupt source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the low threshold , high threshold or modulator failure interrupt as determined by intFlags for the filter specified by filterNumber. Valid values for intFlags are: SDFM_MODULATOR_FAILURE_INTERRUPT , SDFM_LOW_LEVEL_THRESHOLD_INTERRUPT, SDFM_HIGH_LEVEL_THRESHOLD_INTERRUPT, SDFM_FIFO_INTERRUPT, SDFM_FIFO_OVERFLOW_INTERRUPT,SDFM_DATA_FILTER_ACKNOWLEDGE_INTERRUPT</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable SDFM interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the interrupt source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the low threshold , high threshold or modulator failure interrupt as determined by intFlags for the filter specified by filterNumber. Valid values for intFlags are: SDFM_MODULATOR_FAILURE_INTERRUPT , SDFM_LOW_LEVEL_THRESHOLD_INTERRUPT, SDFM_HIGH_LEVEL_THRESHOLD_INTERRUPT, SDFM_FIFO_INTERRUPT, SDFM_FIFO_OVERFLOW_INTERRUPT,SDFM_DATA_FILTER_ACKNOWLEDGE_INTERRUPT</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the comparator filter type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">filterType</td><td>is the comparator filter type or structure.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the Comparator filter type or structure to be used as specified by filterType for the selected filter number as specified by filterNumber.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set Comparator filter over sampling ratio.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">overSamplingRatio</td><td>is the comparator filter over sampling ration.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the comparator filter oversampling ratio for the filter specified by the filterNumber.Valid values for the variable overSamplingRatio are 0 to 31 inclusive. The actual oversampling ratio will be this value plus one.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get the filter data output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the latest data filter output. Depending on the filter data output format selected, the valid value will be the lower 16 bits or the whole 32 bits of the returned value.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the latest data filter output.</dd></dl>
<p>Get the Comparator threshold status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the Comparator output threshold status for the given filterNumber.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the following status flags.<ul>
<li><b>SDFM_OUTPUT_WITHIN_THRESHOLD</b> if the output is within the specified threshold.</li>
<li><b>SDFM_OUTPUT_ABOVE_THRESHOLD</b> if the output is above the high threshold</li>
<li><b>SDFM_OUTPUT_BELOW_THRESHOLD</b> if the output is below the low threshold.</li>
</ul>
</dd></dl>
<p>Get the Modulator status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the Modulator status.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the Modulator is operating normally Returns false if the Modulator has failed</dd></dl>
<p>Check if new Filter data is available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns new filter data status.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if new filter data is available Returns <b>false</b> if no new filter data is available</dd></dl>
<p>Check if FIFO buffer is overflowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the status of the FIFO buffer overflow for the given filter value.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if FIFO buffer is overflowed Returns <b>false</b> if FIFO buffer is not overflowed</dd></dl>
<p>Check FIFO buffer interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the status of the FIFO buffer interrupt for the given filter.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if FIFO buffer interrupt has occurred. Returns <b>false</b> if FIFO buffer interrupt has not occurred.</dd></dl>
<p>Get pending interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns any pending interrupt status.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if there is a pending interrupt. Returns <b>false</b> if no interrupt is pending.</dd></dl>
<p>Clear pending flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">flag</td><td>is the SDFM status</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the specified pending interrupt flag. Valid values are SDFM_MAIN_INTERRUPT_FLAG,SDFM_FILTER_1_NEW_DATA_FLAG, SDFM_FILTER_2_NEW_DATA_FLAG,SDFM_FILTER_3_NEW_DATA_FLAG, SDFM_FILTER_4_NEW_DATA_FLAG,SDFM_FILTER_1_MOD_FAILED_FLAG, SDFM_FILTER_2_MOD_FAILED_FLAG,SDFM_FILTER_3_MOD_FAILED_FLAG, SDFM_FILTER_4_MOD_FAILED_FLAG,SDFM_FILTER_1_HIGH_THRESHOLD_FLAG, SDFM_FILTER_1_LOW_THRESHOLD_FLAG,SDFM_FILTER_2_HIGH_THRESHOLD_FLAG, SDFM_FILTER_2_LOW_THRESHOLD_FLAG,SDFM_FILTER_3_HIGH_THRESHOLD_FLAG, SDFM_FILTER_3_LOW_THRESHOLD_FLAG,SDFM_FILTER_4_HIGH_THRESHOLD_FLAG, SDFM_FILTER_4_LOW_THRESHOLD_FLAG,SDFM_FILTER_1_FIFO_OVERFLOW_FLAG, SDFM_FILTER_2_FIFO_OVERFLOW_FLAG,SDFM_FILTER_3_FIFO_OVERFLOW_FLAG SDFM_FILTER_4_FIFO_OVERFLOW_FLAG,SDFM_FILTER_1_FIFO_INTERRUPT_FLAG, SDFM_FILTER_2_FIFO_INTERRUPT_FLAG,SDFM_FILTER_3_FIFO_INTERRUPT_FLAG SDFM_FILTER_4_FIFO_INTERRUPT_FLAG or any combination of the above flags.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Enable main interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the main SDFM interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Disable main interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the main SDFM interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Enable main filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables main filter.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Disable main filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables main filter.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Return the FIFO data count</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the FIFO data count.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of data words available in FIFO buffer.</dd></dl>
<p>Return the Comparator sinc filter data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the Comparator sinc filter data output.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the Comparator sinc filter data output.</dd></dl>
<p>Return the FIFO data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the latest FIFO data.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the latest FIFO data.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Discard the upper 16 bits if the output data format is 16bits.</dd></dl>
<p>Set the FIFO interrupt level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">fifoLevel</td><td>is the FIFO interrupt level.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the FIFO interrupt level. Interrupt is generated when the FIFO buffer word count gets to or exceeds the value of <em>fifoLevel</em>. Maximum value for <em>fifoLevel</em> is 16.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set data ready interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">dataReadySource</td><td>is the data ready interrupt source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the data ready interrupt source. Valid values for <em>dataReadySource:</em> </p><ul>
<li>SDFM_DATA_READY_SOURCE_DIRECT - Direct data ready</li>
<li>SDFM_DATA_READY_SOURCE_FIFO - FIFO data ready.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get the wait-for-sync event status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the Wait-for-Sync event status.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if sync event has occurred. Returns false if sync event has not occurred.</dd></dl>
<p>Clear the Wait-for-sync event status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the Wait-for-sync event status.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable wait for sync mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the wait for sync mode. Data to FIFO will be written only after PWM sync event.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable wait for sync mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the wait for sync mode. Data to FIFO will be written every Data ready event.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the PWM sync mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">syncSource</td><td>is the PWM sync source.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the PWM sync source for the specific SDFM filter. Valid values for syncSource are SDFM_SYNC_PWMx_CMPy. Where x ranges from 1 to 8 Representing PWM1 to PWM8 respectively and y ranges from A to D representing PWM comparators A to D.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set FIFO clear on sync mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">fifoClearSyncMode</td><td>is the FIFO clear on sync mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the FIFO clear mode for the specified filter when a sync happens depending on the value of fifoClearSyncMode. Valid values for fifoClearSyncMode are:</p><ul>
<li>SDFM_FIFO_NOT_CLEARED_ON_SYNC - FIFO is not cleared on sync.</li>
<li>SDFM_FIFO_CLEARED_ON_SYNC - FIFO is cleared on sync.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set Wait-for-sync clear mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">syncClearMode</td><td>is the wait-for-sync clear mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the Wait-For-sync clear mode depending on the value of syncClearMode. Valid values for syncClearMode are:</p><ul>
<li>SDFM_MANUAL_CLEAR_WAIT_FOR_SYNC - Wait-for-sync flag is cleared by invoking SDFM_clearWaitForSyncFlag().</li>
<li>SDFM_AUTO_CLEAR_WAIT_FOR_SYNC - Wait-for-sync flag is cleared automatically on FIFO interrupt.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Selects clock source for SDFM channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">clkSource</td><td>is the clock source</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the clock for SDFM module filter channels. Valid values for clkSource are:</p><ul>
<li>SDFM_CLK_SOURCE_CHANNEL_CLK - Respective channel's clk is the source</li>
<li>SDFM_CLK_SOURCE_SD1_CLK - Filter 1 clock is the source</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables Input Synchronizer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">syncConfig</td><td>defines which synchronizer to be enabled</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables either data or clock or both synchronizer. Valid values for syncConfig can be the logical OR of any of the values:</p><ul>
<li>SDFM_CLOCK_SYNCHRONIZER - Enable SDFM input clock synchronizer</li>
<li>SDFM_DATA_SYNCHRONIZER - Enable SDFM input data synchronizer</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables Input Synchronizer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">syncConfig</td><td>defines which synchronizer to be disabled</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables either data or clock or both synchronizer. Valid values for syncConfig can be the logical OR of any of the values:</p><ul>
<li>SDFM_CLOCK_SYNCHRONIZER - Disable SDFM input clock synchronizer</li>
<li>SDFM_DATA_SYNCHRONIZER - Disable SDFM input data synchronizer</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Selects comparator event high source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">source</td><td>is the comparator event high source</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the source for comparator event high. Valid values for source are:</p><ul>
<li>SDFM_COMPHOUT_SOURCE_COMPHIN - Original COMPHIN/CEVT1 signal is source</li>
<li>SDFM_COMPHOUT_SOURCE_FILTER - Filtered COMPHIN/CEVT1 signal is source</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Selects comparator event low source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">source</td><td>is the comparator event low source</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the source for comparator event low. Valid values for source are:</p><ul>
<li>SDFM_COMPLOUT_SOURCE_COMPLIN - Original COMPLIN/CEVT2 signal is source</li>
<li>SDFM_COMPHOUT_SOURCE_FILTER - Filtered COMPLIN/CEVT2 signal is source</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Initializes Comparator Event Low Filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes Comparator Event Low Filter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Initializes Comparator Event High Filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number.</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes Comparator Event High Filter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Lock Comparator Event Filter Configurations</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SDFM module </td></tr>
    <tr><td class="paramname">filterNumber</td><td>is the filter number. </td></tr>
    <tr><td class="paramname">lockConfig</td><td>defines the configurations to be locked</td></tr>
  </table>
  </dd>
</dl>
<p>This function locks the comparator event filter configurations. Valid values of the lockConfig can be logical OR of any of the following values:</p><ul>
<li>SDFM_SDCOMPLOCK_SDCOMPCTL - Locks write access to SDCOMPCTL register</li>
<li>SDFM_SDCOMPLOCK_COMP - Locks write access to SDCOMPxFILCTL &amp; SDCOMPxFILCLKCTL register</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the serial peripheral interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>specifies the SPI module base address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables operation of the serial peripheral interface. Call this function before doing any configuration.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the character length of SPI transaction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>specifies the SPI module base address. </td></tr>
    <tr><td class="paramname">charLength</td><td>specifies the character length of SPI transaction</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the character length of SPI transaction. SPI character length can be from anywhere between 1-bit word to 16 bit word of character length</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables the transmit and receive FIFOs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<p>This functions enables the transmit and receive FIFOs in the SPI.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the transmit and receive FIFOs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<p>This functions disables the transmit and receive FIFOs in the SPI.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Resets the transmit FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function resets the transmit FIFO, setting the FIFO pointer back to zero.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Resets the receive FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function resets the receive FIFO, setting the FIFO pointer back to zero.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the FIFO level at which interrupts are generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port. </td></tr>
    <tr><td class="paramname">txLevel</td><td>is the transmit FIFO interrupt level, specified as <b>SPI_FIFO_TX0</b>, <b>SPI_FIFO_TX1</b>, <b>SPI_FIFO_TX2</b>, . . . or <b>SPI_FIFO_TX16</b>. </td></tr>
    <tr><td class="paramname">rxLevel</td><td>is the receive FIFO interrupt level, specified as <b>SPI_FIFO_RX0</b>, <b>SPI_FIFO_RX1</b>, <b>SPI_FIFO_RX2</b>, . . . or <b>SPI_FIFO_RX16</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the FIFO level at which transmit and receive interrupts are generated.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the FIFO level at which interrupts are generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port. </td></tr>
    <tr><td class="paramname">txLevel</td><td>is a pointer to storage for the transmit FIFO level, returned as one of <b>SPI_FIFO_TX0</b>, <b>SPI_FIFO_TX1</b>, <b>SPI_FIFO_TX2</b>, . . . or <b>SPI_FIFO_TX16</b>. </td></tr>
    <tr><td class="paramname">rxLevel</td><td>is a pointer to storage for the receive FIFO level, returned as one of <b>SPI_FIFO_RX0</b>, <b>SPI_FIFO_RX1</b>, <b>SPI_FIFO_RX2</b>, . . . or <b>SPI_FIFO_RX16</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the FIFO level at which transmit and receive interrupts are generated.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get the transmit FIFO status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the current number of words in the transmit FIFO.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current number of words in the transmit FIFO specified as one of the following: <b>SPI_FIFO_TX0</b>, <b>SPI_FIFO_TX1</b>, <b>SPI_FIFO_TX2</b>, <b>SPI_FIFO_TX3</b>, ..., or <b>SPI_FIFO_TX16</b> </dd></dl>
<p>Get the receive FIFO status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the current number of words in the receive FIFO.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current number of words in the receive FIFO specified as one of the following: <b>SPI_FIFO_RX0</b>, <b>SPI_FIFO_RX1</b>, <b>SPI_FIFO_RX2</b>, <b>SPI_FIFO_RX3</b>, ..., or <b>SPI_FIFO_RX16</b> </dd></dl>
<p>Determines whether the SPI transmitter is busy or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the caller to determine whether all transmitted bytes have cleared the transmitter hardware. If <b>false</b> is returned, then the transmit FIFO is empty and all bits of the last transmitted word have left the hardware shift register. This function is only valid when operating in FIFO mode.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the SPI is transmitting or <b>false</b> if all transmissions are complete.</dd></dl>
<p>Puts a data element into the SPI transmit buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>specifies the SPI module base address. </td></tr>
    <tr><td class="paramname">data</td><td>is the left-justified data to be transmitted over SPI.</td></tr>
  </table>
  </dd>
</dl>
<p>This function places the supplied data into the transmit buffer of the specified SPI module.</p>
<dl class="section note"><dt>Note</dt><dd>The data being sent must be left-justified in <em>data</em>. The lower 16 - N bits will be discarded where N is the data width selected in <a class="el" href="group__spi__api.html#ga6932fc6631222890485f7a1adb883086">SPI_setConfig()</a>. For example, if configured for a 6-bit data width, the lower 10 bits of data will be discarded.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets a data element from the SPI receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>specifies the SPI module base address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets received data from the receive buffer of the specified SPI module and returns it.</p>
<dl class="section note"><dt>Note</dt><dd>Only the lower N bits of the value written to <em>data</em> contain valid data, where N is the data width as configured by <a class="el" href="group__spi__api.html#ga6932fc6631222890485f7a1adb883086">SPI_setConfig()</a>. For example, if the interface is configured for 8-bit data width, only the lower 8 bits of the value written to <em>data</em> contain valid data.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the word of data read from the SPI receive buffer.</dd></dl>
<p>Waits for space in the FIFO and then puts data into the transmit buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>specifies the SPI module base address. </td></tr>
    <tr><td class="paramname">data</td><td>is the left-justified data to be transmitted over SPI.</td></tr>
  </table>
  </dd>
</dl>
<p>This function places the supplied data into the transmit buffer of the specified SPI module once space is available in the transmit FIFO. This function should only be used when the FIFO is enabled.</p>
<dl class="section note"><dt>Note</dt><dd>The data being sent must be left-justified in <em>data</em>. The lower 16 - N bits will be discarded where N is the data width selected in <a class="el" href="group__spi__api.html#ga6932fc6631222890485f7a1adb883086">SPI_setConfig()</a>. For example, if configured for a 6-bit data width, the lower 10 bits of data will be discarded.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Waits for data in the FIFO and then reads it from the receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>specifies the SPI module base address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function waits until there is data in the receive FIFO and then reads received data from the receive buffer. This function should only be used when FIFO mode is enabled.</p>
<dl class="section note"><dt>Note</dt><dd>Only the lower N bits of the value written to <em>data</em> contain valid data, where N is the data width as configured by <a class="el" href="group__spi__api.html#ga6932fc6631222890485f7a1adb883086">SPI_setConfig()</a>. For example, if the interface is configured for 8-bit data width, only the lower 8 bits of the value written to <em>data</em> contain valid data.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the word of data read from the SPI receive buffer.</dd></dl>
<p>Waits for the transmit buffer to empty and then writes data to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>specifies the SPI module base address. </td></tr>
    <tr><td class="paramname">data</td><td>is the left-justified data to be transmitted over SPI.</td></tr>
  </table>
  </dd>
</dl>
<p>This function places the supplied data into the transmit buffer of the specified SPI module once it is empty. This function should not be used when FIFO mode is enabled.</p>
<dl class="section note"><dt>Note</dt><dd>The data being sent must be left-justified in <em>data</em>. The lower 16 - N bits will be discarded where N is the data width selected in <a class="el" href="group__spi__api.html#ga6932fc6631222890485f7a1adb883086">SPI_setConfig()</a>. For example, if configured for a 6-bit data width, the lower 10 bits of data will be discarded.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Waits for data to be received and then reads it from the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>specifies the SPI module base address.</td></tr>
  </table>
  </dd>
</dl>
<p>This function waits for data to be received and then reads it from the receive buffer of the specified SPI module. This function should not be used when FIFO mode is enabled.</p>
<dl class="section note"><dt>Note</dt><dd>Only the lower N bits of the value written to <em>data</em> contain valid data, where N is the data width as configured by <a class="el" href="group__spi__api.html#ga6932fc6631222890485f7a1adb883086">SPI_setConfig()</a>. For example, if the interface is configured for 8-bit data width, only the lower 8 bits of the value written to <em>data</em> contain valid data.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the word of data read from the SPI receive buffer.</dd></dl>
<p>Enables SPI 3-wire mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables 3-wire mode. When in controller mode, this allows SPIPICO to become SPICOCI and SPIPOCI to become free for non-SPI use. When in peripheral mode, SPIPOCI because the SPIPIPO pin and SPIPICO is free for non-SPI use.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables SPI 3-wire mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables 3-wire mode. SPI will operate in normal 4-wire mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables SPI loopback mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables loopback mode. This mode is only valid during controller mode and is helpful during device testing as it internally connects PICO and POCI.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables SPI loopback mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables loopback mode. Loopback mode is disabled by default after reset.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the peripheral select (SPIPTE) signal polarity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port. </td></tr>
    <tr><td class="paramname">polarity</td><td>is the SPIPTE signal polarity.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the polarity of the peripheral select (SPIPTE) signal. The two modes to choose from for the <em>polarity</em> parameter are <b>SPI_PTE_ACTIVE_LOW</b> for active-low polarity (typical) and <b>SPI_PTE_ACTIVE_HIGH</b> for active-high polarity (considered inverted).</p>
<dl class="section note"><dt>Note</dt><dd>This has no effect on the PTE signal when in controller mode. It is only applicable to peripheral mode.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables SPI high speed mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables high speed mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables SPI high speed mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables high speed mode. High speed mode is disabled by default after reset.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets SPI emulation mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port. </td></tr>
    <tr><td class="paramname">mode</td><td>is the emulation mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the behavior of the SPI operation when an emulation suspend occurs. The <em>mode</em> parameter can be one of the following:</p>
<ul>
<li><b>SPI_EMULATION_STOP_MIDWAY</b> - Transmission stops midway through the bit stream. The rest of the bits will be transmitting after the suspend is deasserted.</li>
<li><b>SPI_EMULATION_STOP_AFTER_TRANSMIT</b> - If the suspend occurs before the first SPICLK pulse, the transmission will not start. If it occurs later, the transmission will be completed.</li>
<li><b>SPI_EMULATION_FREE_RUN</b> - SPI operation continues regardless of a the suspend.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Configures the FIFO Transmit Delay</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port. </td></tr>
    <tr><td class="paramname">delay</td><td>Tx FIFO delay to be configured in cycles (0..0xFF)</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the delay between every transfer from FIFO transmit buffer to transmit shift register. The delay is defined in number SPI serial clock cycles.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Returns the Emulation Buffer Received Data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the Emulation Buffer Received Data</p>
<dl class="section return"><dt>Returns</dt><dd>Rx emulation buffer data</dd></dl>
<p>Enable Transmit</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the TALK bit enabling the data transmission. This bit is enabled by SPI_setConfig if the parameter \r mode is selected as SPI_MODE_PERIPHERAL or SPI_MODE_CONTROLLER.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Disable Transmit</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the TALK bit disabling the data transmission. The output pin will be put in high-impedance state. This bit is enabled by SPI_setConfig if the parameter \r mode is selected as SPI_MODE_PERIPHERAL or SPI_MODE_CONTROLLER.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Reset SPI transmit and receive channels</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the SPI port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function resets the SPI transmit and receive channels.</p>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Disables a peripheral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>is the peripheral to disable.</td></tr>
  </table>
  </dd>
</dl>
<p>Peripherals are disabled with this function. Once disabled, they will not operate or respond to register reads/writes.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Resets a peripheral</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>is the peripheral to reset.</td></tr>
  </table>
  </dd>
</dl>
<p>This function uses the SOFTPRESx registers to reset a specified peripheral. Module registers will be returned to their reset states.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Returns the PER FRAME configuration for the selected peripheral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>is the peripheral for which FRAME needs to be checked</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>peripheral</em> parameter can have one enumerated value from SysCtl_PeripheralConfig</p>
<dl class="section return"><dt>Returns</dt><dd>Retuns one of the folowing -<ul>
<li><b>SYSCTL_FRAMESEL_0</b> - peripheral connected to Frame 0</li>
<li><b>SYSCTL_FRAMESEL_1</b> - peripheral connected to Frame 1</li>
<li><b>SYSCTL_FRAMESEL_2</b> - peripheral connected to Frame 2</li>
<li><b>SYSCTL_FRAMESEL_3</b> - peripheral connected to Frame 3</li>
</ul>
</dd></dl>
<p>Gets the reason for a reset.</p>
<p>This function will return the reason(s) for a reset. Since the reset reasons are sticky until either cleared by software or an external reset, multiple reset reasons may be returned if multiple resets have occurred. The reset reason will be a logical OR of</p><ul>
<li><b>SYSCTL_CAUSE_POR</b> - POR POR Reset Cause Clear Bit</li>
<li><b>SYSCTL_CAUSE_XRSN</b> - XRSn POR Reset Cause Clear Bit</li>
<li><b>SYSCTL_CAUSE_WDRSN</b> - WDRSn POR Reset Cause Clear Bit</li>
<li><b>SYSCTL_CAUSE_NMIWDRSN</b> - NMIWDRSn POR Reset Cause Clear Bit</li>
<li><b>SYSCTL_CAUSE_ECAT_RESET_OUT</b> - ECAT_RESET_OUT POR Reset Cause Clear Bit</li>
<li><b>SYSCTL_CAUSE_SIMRESET_XRSN</b> - SIMRESET_XRSn POR Reset Cause Clear Bit</li>
<li><b>SYSCTL_CAUSE_ESMXRSN</b> - ESMXRSn Reset Cause Clear Bit</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If you re-purpose the reserved boot ROM RAM, the POR and XRS reset statuses won't be accurate.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the reason(s) for a reset.</dd></dl>
<p>Clears reset reasons.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rstCauses</td><td>are the reset causes to be cleared; must be a logical OR of<ul>
<li><b>SYSCTL_CAUSE_POR</b> - POR POR Reset Cause Clear Bit</li>
<li><b>SYSCTL_CAUSE_XRSN</b> - XRSn POR Reset Cause Clear Bit</li>
<li><b>SYSCTL_CAUSE_WDRSN</b> - WDRSn POR Reset Cause Clear Bit</li>
<li><b>SYSCTL_CAUSE_NMIWDRSN</b> - NMIWDRSn POR Reset Cause Clear Bit</li>
<li><b>SYSCTL_CAUSE_ECAT_RESET_OUT</b> - ECAT_RESET_OUT POR Reset Cause Clear Bit</li>
<li><b>SYSCTL_CAUSE_SIMRESET_XRSN</b> - SIMRESET_XRSn POR Reset Cause Clear Bit</li>
<li><b>SYSCTL_CAUSE_ESMXRSN</b> - ESMXRSn Reset Cause Clear Bit</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the specified sticky reset reasons. Once cleared, another reset for the same reason can be detected, and a reset for a different reason can be distinguished (instead of having two reset causes set). If the reset reason is used by an application, all reset causes should be cleared after they are retrieved with SysCtl_getResetCause().</p>
<dl class="section note"><dt>Note</dt><dd>Some reset causes are cleared by the boot ROM.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Simulates a XRSn reset</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API exists only on CPU1</dd></dl>
<p>Check if the CPU2 is held in reset or not</p>
<dl class="section note"><dt>Note</dt><dd>This API is applicable only for the CPU1 subsystem.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if CPU2 core is in reset <b>false</b> if CPU2 core is out of reset</dd></dl>
<p>Get the CPU2 LPM status</p>
<dl class="section note"><dt>Note</dt><dd>This API is applicable only for the CPU1 subsystem.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>returns one of the following values :<ul>
<li>SYSCTL_CPU_ACTIVE</li>
<li>SYSCTL_CPU_IDLE</li>
<li>SYSCTL_CPU_STANDBY</li>
</ul>
</dd></dl>
<p>Check if the CPU3 is held in reset or not</p>
<dl class="section note"><dt>Note</dt><dd>This API is applicable only for the CPU1 subsystem.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if CPU3 core is in reset <b>false</b> if CPU3 core is out of reset</dd></dl>
<p>Get the CPU3 LPM status</p>
<dl class="section note"><dt>Note</dt><dd>This API is applicable only for the CPU1 subsystem.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>returns one of the following values :<ul>
<li>SYSCTL_CPU_ACTIVE</li>
<li>SYSCTL_CPU_IDLE</li>
<li>SYSCTL_CPU_STANDBY</li>
</ul>
</dd></dl>
<p>Enters IDLE mode.</p>
<p>This function puts the device into IDLE mode. The CPU clock is gated while all peripheral clocks are left running. Any enabled interrupt will wake the CPU up from IDLE mode.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enters STANDBY mode.</p>
<p>This function puts the device into STANDBY mode. This will gate both the CPU clock and any peripheral clocks derived from SYSCLK. The watchdog is left active, and an NMI or an optional watchdog interrupt will wake the CPU subsystem from STANDBY mode.</p>
<p>GPIOs may be configured to wake the CPU subsystem. See SysCtl_enableLPMWakeupPin().</p>
<p>The CPU will receive an interrupt (WAKEINT) on wakeup.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables a pin to wake up the device from the low power mode:</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>is the identifying number of the pin. Use enum SYSCTL_LPMSEL_xx</td></tr>
  </table>
  </dd>
</dl>
<p>This function connects a pin to the LPM circuit, allowing an event on the pin to wake up the device when when it is in following mode(s):</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the number of cycles to qualify an input on waking from STANDBY mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cycles</td><td>is the number of OSCCLK cycles.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the number of OSCCLK clock cycles used to qualify the selected inputs when waking from STANDBY mode. The <em>cycles</em> parameter should be passed a cycle count between 2 and 65 cycles inclusive.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Get CPU ID</p>
<dl class="section return"><dt>Returns</dt><dd>Returns CPU ID : 1 for CPU1, 2 for CPU2, 3 for CPU3.</dd></dl>
<p>Check if the MCAN wakeup event has occured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mcanInst</td><td>is the MCAN instance</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>mcanInst</em> parameter can have one enumerated value from SysCtl_MCANInstance</p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the MCAN wakeup event has occured. <b>false</b> if the MCAN wakeup event has not occured.</dd></dl>
<p>Clears the MCAN wakeup event status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mcanInst</td><td>is the MCAN instance</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the MCAN wakeup event status. To check if it was set first, see SysCtl_isMCANWakeStatusSet().</p>
<p>The <em>mcanInst</em> parameter can have one enumerated value from SysCtl_MCANInstance</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the user register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>is the register to be set </td></tr>
    <tr><td class="paramname">value</td><td>is the value to be set</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets sepcified user register. The <em>value</em> parameter can have one enumerated value from SysCtl_UserRegister.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the user register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>is the register to be set</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets sepcified user register. The <em>value</em> parameter can have one enumerated value from SysCtl_UserRegister.</p>
<dl class="section return"><dt>Returns</dt><dd>value of the specified register.</dd></dl>
<p>Get the Device Silicon Revision ID</p>
<p>This function returns the silicon revision ID for the device.</p>
<dl class="section note"><dt>Note</dt><dd>This API is applicable only for the CPU1 subsystem.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the silicon revision ID value.</dd></dl>
<p>Gets the status of the watchdog interrupt signal.</p>
<p>This function returns the status of the watchdog interrupt signal. If the interrupt is active, this function will return <b>true</b>. If <b>false</b>, the interrupt is NOT active.</p>
<dl class="section note"><dt>Note</dt><dd>Make sure to call this function to ensure that the interrupt is not active before making any changes to the configuration of the watchdog to prevent any unexpected behavior. For instance, switching from interrupt mode to reset mode while the interrupt is active will immediately reset the device.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the interrupt is active and <b>false</b> if it is not.</dd></dl>
<p>Disables the watchdog.</p>
<p>This function disables the watchdog timer. Note that the watchdog timer is enabled on reset.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables the watchdog.</p>
<p>This function enables the watchdog timer. Note that the watchdog timer is enabled on reset.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Services the watchdog.</p>
<p>This function resets the watchdog.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Writes the first key to enter the watchdog reset.</p>
<p>This function writes the first key to enter the watchdog reset.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Writes the second key to reset the watchdog.</p>
<p>This function writes the second key to reset the watchdog.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets up watchdog clock (WDCLK) pre-divider.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predivider</td><td>is the value that configures the pre-divider.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the watchdog clock (WDCLK) pre-divider. There are two dividers that scale INTOSC1 to WDCLK. The <em>predivider</em> parameter divides INTOSC1 down to PREDIVCLK and the prescaler (set by the SysCtl_setWatchdogPrescaler() function) divides PREDIVCLK down to WDCLK.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets up watchdog clock (WDCLK) prescaler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prescaler</td><td>is the value that configures the watchdog clock relative to the value from the pre-divider.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the watchdog clock (WDCLK) prescaler. There are two dividers that scale INTOSC1 to WDCLK. The predivider (set with the SysCtl_setWatchdogPredivider() function) divides INTOSC1 down to PREDIVCLK and the <em>prescaler</em> parameter divides PREDIVCLK down to WDCLK.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the watchdog counter value.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current value of the 8-bit watchdog counter. If this count value overflows, a watchdog output pulse is generated.</dd></dl>
<p>Gets the watchdog reset status.</p>
<p>This function returns the watchdog reset status. If this function returns <b>true</b>, that indicates that a watchdog reset generated the last reset condition. Otherwise, it was an external device or power-up reset condition.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the watchdog generated the last reset condition.</dd></dl>
<p>Clears the watchdog reset status.</p>
<p>This function clears the watchdog reset status. To check if it was set first, see SysCtl_getWatchdogResetStatus().</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Set the minimum threshold value for windowed watchdog</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the value to set the window threshold</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the minimum threshold value used to define the lower limit of the windowed watchdog functionality.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Clears the watchdog override.</p>
<p>This function clears the watchdog override and locks the watchdog timer module to remain in its prior state which could be either enable /disable. The watchdog timer will remain in this state until the next system reset.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables CPU timer interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the timer module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the CPU timer interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables CPU timer interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the timer module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the CPU timer interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Reloads CPU timer counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the timer module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reloads the CPU timer counter with the values contained in the CPU timer period register.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Stops CPU timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the timer module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function stops the CPU timer.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Starts(restarts) CPU timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the timer module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function starts (restarts) the CPU timer.</p>
<p><b>Note:</b> This function doesn't reset the timer counter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Starts(restarts) CPU timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the timer module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function starts (restarts) the CPU timer.</p>
<p><b>Note:</b> This function reloads the timer counter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets CPU timer period.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the timer module. </td></tr>
    <tr><td class="paramname">periodCount</td><td>is the CPU timer period count.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the CPU timer period count.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Returns the current CPU timer counter value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the timer module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current CPU timer counter value.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current CPU timer count value.</dd></dl>
<p>Set CPU timer pre-scaler value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the timer module. </td></tr>
    <tr><td class="paramname">prescaler</td><td>is the CPU timer pre-scaler value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the pre-scaler value for the CPU timer. For every value of (prescaler + 1), the CPU timer counter decrements by 1.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Return the CPU timer overflow status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the timer module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the CPU timer overflow status.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the CPU timer has overflowed, false if not.</dd></dl>
<p>Gets the type of parity currently being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the type of parity used for transmitting data and expected when receiving data.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current parity settings, specified as one of <b>UART_CONFIG_PAR_NONE</b>, <b>UART_CONFIG_PAR_EVEN</b>, <b>UART_CONFIG_PAR_ODD</b>, <b>UART_CONFIG_PAR_ONE</b>, or <b>UART_CONFIG_PAR_ZERO</b>.</dd></dl>
<p>Sets the FIFO level at which interrupts are generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port. </td></tr>
    <tr><td class="paramname">txLevel</td><td>is the transmit FIFO interrupt level, specified as one of <b>UART_FIFO_TX1_8</b>, <b>UART_FIFO_TX2_8</b>, <b>UART_FIFO_TX4_8</b>, <b>UART_FIFO_TX6_8</b>, or <b>UART_FIFO_TX7_8</b>. </td></tr>
    <tr><td class="paramname">rxLevel</td><td>is the receive FIFO interrupt level, specified as one of <b>UART_FIFO_RX1_8</b>, <b>UART_FIFO_RX2_8</b>, <b>UART_FIFO_RX4_8</b>, <b>UART_FIFO_RX6_8</b>, or <b>UART_FIFO_RX7_8</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the FIFO level at which transmit and receive interrupts are generated.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the FIFO level at which interrupts are generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port. </td></tr>
    <tr><td class="paramname">txLevel</td><td>is a pointer to storage for the transmit FIFO level, returned as one of <b>UART_FIFO_TX1_8</b>, <b>UART_FIFO_TX2_8</b>, <b>UART_FIFO_TX4_8</b>, <b>UART_FIFO_TX6_8</b>, or <b>UART_FIFO_TX7_8</b>. </td></tr>
    <tr><td class="paramname">rxLevel</td><td>is a pointer to storage for the receive FIFO level, returned as one of <b>UART_FIFO_RX1_8</b>, <b>UART_FIFO_RX2_8</b>, <b>UART_FIFO_RX4_8</b>, <b>UART_FIFO_RX6_8</b>, or <b>UART_FIFO_RX7_8</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets the FIFO level at which transmit and receive interrupts are generated.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables transmitting and receiving.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the UART and its transmit and receive FIFOs.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables transmitting and receiving, without enabling FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the UART and its transmit and receive FIFOs.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables transmitting and receiving.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the UART, waits for the end of transmission of the current character, and flushes the transmit FIFO.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables transmitting and receiving without FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the UART, waits for the end of transmission of the current character.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables the transmit and receive FIFOs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This functions enables the transmit and receive FIFOs in the UART.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables the transmit and receive FIFOs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the transmit and receive FIFOs in the UART.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Determines if the transmit and receive FIFOs are enabled</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns a flag indicating whether or not the transmit and receive FIFOs are enabled.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if FIFOs are enabled or <b>false</b> if FIFOs are not enabled.</dd></dl>
<p>Enables SIR (IrDA) mode on the specified UART.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port. </td></tr>
    <tr><td class="paramname">bLowPower</td><td>indicates if SIR Low Power Mode is to be used. This parameter is of type UART_SirLPMode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables SIR (IrDA) mode on the UART. If the <em>bLowPower</em> flag is set, then SIR low power mode will be selected as well. This function only has an effect if the UART has not been enabled by a call to UART_enableModule(). The call UART_enableSIR() must be made before a call to <a class="el" href="group__uart__api.html#ga41c6d99b6e60b52d22729be7d6fc9e1d">UART_setConfig()</a> because the <a class="el" href="group__uart__api.html#ga41c6d99b6e60b52d22729be7d6fc9e1d">UART_setConfig()</a> function calls the UART_enableModule() function. Another option is to call UART_disableModule() followed by UART_enableSIR(), and then enable the UART by calling UART_enableModule().</p>
<dl class="section note"><dt>Note</dt><dd>The IrDA SIR physical layer specifies a minimum 10 ms delay between transmission and reception which needs to be provided.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables SIR (IrDA) mode on the specified UART.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables SIR(IrDA) mode on the UART. This function only has an effect if the UART has not been enabled by a call to UART_enableModule(). The call UART_disableSIR() must be made before a call to <a class="el" href="group__uart__api.html#ga41c6d99b6e60b52d22729be7d6fc9e1d">UART_setConfig()</a> because the <a class="el" href="group__uart__api.html#ga41c6d99b6e60b52d22729be7d6fc9e1d">UART_setConfig()</a> function calls the UART_enableModule() function. Another option is to call UART_disableModule() followed by UART_disableSIR() and then enable the UART by calling UART_enableModule().</p>
<dl class="section note"><dt>Note</dt><dd>The IrDA SIR physical layer specifies a minimum 10 ms delay between transmission and reception which needs to be provided.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the operating mode for the UART transmit interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port. </td></tr>
    <tr><td class="paramname">mode</td><td>is the operating mode for the transmit interrupt. It may be <b>UART_TXINT_MODE_EOT</b> to trigger interrupts when the transmitter is idle or <b>UART_TXINT_MODE_FIFO</b> to trigger based on the current transmit FIFO level.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the mode of the UART transmit interrupt to be set. By default, the transmit interrupt is asserted when the FIFO level falls past a threshold set via a call to UART_setFIFOLevel(). Alternatively, if this function is called with <em>mode</em> set to <b>UART_TXINT_MODE_EOT</b>, the transmit interrupt is asserted once the transmitter is completely idle - the transmit FIFO is empty and all bits, including any stop bits, have cleared the transmitter.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Returns the current operating mode for the UART transmit interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current operating mode for the UART transmit interrupt. The return value is <b>UART_TXINT_MODE_EOT</b> if the transmit interrupt is currently configured to be asserted once the transmitter is completely idle - the transmit FIFO is empty and all bits, including any stop bits, have cleared the transmitter. The return value is <b>UART_TXINT_MODE_FIFO</b> if the interrupt is configured to be asserted based on the level of the transmit FIFO.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>UART_TXINT_MODE_FIFO</b> or <b>UART_TXINT_MODE_EOT</b>.</dd></dl>
<p>Determines if there are any characters in the receive FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns a flag indicating whether or not there is data available in the receive FIFO.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if there is data in the receive FIFO or <b>false</b> if there is no data in the receive FIFO.</dd></dl>
<p>Determines if there is any space in the transmit FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns a flag indicating whether or not there is space available in the transmit FIFO.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if there is space available in the transmit FIFO or <b>false</b> if there is no space available in the transmit FIFO.</dd></dl>
<p>Receives a character from the specified port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets a character from the receive FIFO for the specified port.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the character read from the specified port, cast as a <em>int32_t</em>. A <b>-1</b> is returned if there are no characters present in the receive FIFO. The UART_isDataAvailable() function should be called before attempting to call this function.</dd></dl>
<p>Waits for a character from the specified port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets a character from the receive FIFO for the specified port. If there are no characters available, this function waits until a character is received before returning.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the character read from the specified port, cast as a <em>int32_t</em>.</dd></dl>
<p>Waits to send a character from the specified port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port. </td></tr>
    <tr><td class="paramname">data</td><td>is the character to be transmitted.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sends the character <em>data</em> to the transmit FIFO for the specified port. If there is no space available in the transmit FIFO, this function waits until there is space available before returning.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Causes a BREAK to be sent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port. </td></tr>
    <tr><td class="paramname">breakState</td><td>controls the output level.</td></tr>
  </table>
  </dd>
</dl>
<p>Calling this function with <em>breakState</em> set to <b>true</b> asserts a break condition on the UART. Calling this function with <em>breakState</em> set to <b>false</b> removes the break condition. For proper transmission of a break command, the break must be asserted for at least two complete frames.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Determines whether the UART transmitter is busy or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the caller to determine whether all transmitted bytes have cleared the transmitter hardware. If <b>false</b> is returned, the transmit FIFO is empty and all bits of the last transmitted character, including all stop bits, have left the hardware shift register.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if the UART is transmitting or <b>false</b> if all transmissions are complete.</dd></dl>
<p>Clears UART global interrupt flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the indicated UART global interrupt flag register.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Returns the status of UART global interrupt flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the status of UART global interrupt flag register.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of UART global interrupt flag register.</dd></dl>
<p>Enables individual UART interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of the interrupt sources to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated UART interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt, disabled sources have no effect on the processor.</p>
<p>The <em>intFlags</em> parameter is the logical OR of any of the following:</p>
<ul>
<li><b>UART_INT_DMATX</b> - Transmit DMA interrupt</li>
<li><b>UART_INT_DMARX</b> - Receive DMA interrupt</li>
<li><b>UART_INT_9BIT</b> - 9-bit Address Match interrupt</li>
<li><b>UART_INT_OE</b> - Overrun Error interrupt</li>
<li><b>UART_INT_BE</b> - Break Error interrupt</li>
<li><b>UART_INT_PE</b> - Parity Error interrupt</li>
<li><b>UART_INT_FE</b> - Framing Error interrupt</li>
<li><b>UART_INT_RT</b> - Receive Timeout interrupt</li>
<li><b>UART_INT_TX</b> - Transmit interrupt</li>
<li><b>UART_INT_RX</b> - Receive interrupt</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables individual UART interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is the bit mask of the interrupt sources to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated UART interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt, disabled sources have no effect on the processor.</p>
<p>The <em>intFlags</em> parameter has the same definition as the <em>intFlags</em> parameter to UART_enableInterrupt().</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets the current interrupt status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port. </td></tr>
    <tr><td class="paramname">masked</td><td>of type UART_IntType is UART_RAW_INT if the raw interrupt status is requested, and UART_MASKED_INT if the masked interrupt status is requested.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the interrupt status for the specified UART. Either the raw interrupt status or the status of interrupts that are allowed to reflect to the processor can be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current interrupt status, enumerated as a bit field of values described in UART_enableInterrupt().</dd></dl>
<p>Clears UART interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port. </td></tr>
    <tr><td class="paramname">intFlags</td><td>is a bit mask of the interrupt sources to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>The specified UART interrupt sources are cleared, so that they no longer assert. This function must be called in the interrupt handler to keep the interrupt from being triggered again immediately upon exit.</p>
<p>The <em>intFlags</em> parameter has the same definition as the <em>intFlags</em> parameter to UART_enableInterrupt().</p>
<dl class="section note"><dt>Note</dt><dd>It is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action). Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enable UART DMA operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port. </td></tr>
    <tr><td class="paramname">dmaFlags</td><td>is a bit mask of the DMA features to enable.</td></tr>
  </table>
  </dd>
</dl>
<p>The specified UART DMA features are enabled. The UART can be configured to use DMA for transmit or receive and to disable receive if an error occurs. The <em>dmaFlags</em> parameter is the logical OR of any of the following values:</p>
<ul>
<li><b>UART_DMA_RX</b> - enable DMA for receive</li>
<li><b>UART_DMA_TX</b> - enable DMA for transmit</li>
<li><b>UART_DMA_ERR_RXSTOP</b> - disable DMA receive on UART error</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The DMA controller must also be set up before DMA can be used with the UART.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disable UART DMA operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port. </td></tr>
    <tr><td class="paramname">dmaFlags</td><td>is a bit mask of the DMA features to disable.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to disable UART DMA features that were enabled by UART_enableDMA(). The specified UART DMA features are disabled. The <em>dmaFlags</em> parameter is the logical OR of any of the following values:</p>
<ul>
<li><b>UART_DMA_RX</b> - disable DMA for receive</li>
<li><b>UART_DMA_TX</b> - disable DMA for transmit</li>
<li><b>UART_DMA_ERR_RXSTOP</b> - do not disable DMA receive on UART error</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Gets current receiver errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the current state of each of the 4 receiver error sources. The returned errors are equivalent to the four error bits returned via the previous call to UART_readChar() or UART_readCharNonBlocking() with the exception that the overrun error is set immediately when the overrun occurs rather than when a character is next read.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a logical OR combination of the receiver error flags, <b>UART_RXERROR_FRAMING</b>, <b>UART_RXERROR_PARITY</b>, <b>UART_RXERROR_BREAK</b> and <b>UART_RXERROR_OVERRUN</b>.</dd></dl>
<p>Clears all reported receiver errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to clear all receiver error conditions reported via UART_getRxError(). If using the overrun, framing error, parity error or break interrupts, this function must be called after clearing the interrupt to ensure that later errors of the same type trigger another interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables 9-bit mode on the specified UART.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the 9-bit operational mode of the UART.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables 9-bit mode on the specified UART.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the 9-bit operational mode of the UART.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the device address(es) for 9-bit mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port. </td></tr>
    <tr><td class="paramname">addr</td><td>is the device address. </td></tr>
    <tr><td class="paramname">mask</td><td>is the device address mask.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the device address or range of device addresses that respond to requests on the 9-bit UART port. The received address is masked with the mask and then compared against the given address, allowing either a single address (if <b>mask</b> is 0xff) or a set of addresses to be matched.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Sets the SIR (IrDA) Low Power Divisor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART port. </td></tr>
    <tr><td class="paramname">uartClk</td><td>is the rate of the clock supplied to the UART module. It should be provided as UART_CLK_FREQ using the updated clk rate.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the SIR (IrDA) Low power divisor. This function is used only if the SIR ( IrDA ) is to be used in Low Power mode which is indicated as part of the UART_enableSIR().</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Enables internal loopback mode for an UART port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures an UART port in internal loopback mode to help with diagnostics and debug. In this mode, the UART Tx path is fed through the UART Rx path. This allows data to be transferred between the TX and RX of the same UART port, without having to go through I/O's. UART_writeChar() &amp; <a class="el" href="group__uart__api.html#ga328c1865b935f22dce0e8932a91544ab">UART_writeCharNonBlocking()</a> can be used along with this function.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Disables internal loopback mode for an UART port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the UART module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables internal loopback mode in an UART port. In this mode, the UART Tx path is not fed through the UART Rx path. This prevents data to be transferred between the TX and RX of the same UART port, without having to go through I/O's.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Returns the status of the output latch</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>specifies the X-BAR base address. </td></tr>
    <tr><td class="paramname">output</td><td>is the X-BAR output whose flags are being accessed. The valid inputs are XBAR_OUTPUTy where y is from 1 to 16.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>base</em> parameter can take base address OUTPUTXBAR_BASE. The base address for OUTPUTXBARx FLAGS is calculated using the <em>output</em> number specified.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <b>true</b> if there is a latched event. If not, it will return <b>false</b>.</dd></dl>
<p>Clears the output latch for the specified output X-BAR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>specifies the X-BAR base address. </td></tr>
    <tr><td class="paramname">output</td><td>is the X-BAR output whose flags are being accessed. The valid inputs are XBAR_OUTPUTy where y is from 1 to 16.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>base</em> parameter can take base address OUTPUTXBAR_BASE. The base address for OUTPUTXBARx FLAGS is calculated using the <em>output</em> number specified.</p>
<p>This function clears the Output X-BAR output latch flag.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<p>Forces the output latch for the specified output X-BAR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>specifies the X-BAR base address. </td></tr>
    <tr><td class="paramname">output</td><td>is the X-BAR output whose flags are being accessed. The valid inputs are XBAR_OUTPUTy where y is from 1 to 16.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>base</em> parameter can take base addresses of OUTPUTXBAR_BASE. The base address for OUTPUTXBARx FLAGS is calculated using the <em>output</em> number specified.</p>
<p>This function forces the respective Output X-BAR output signal latched flag.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga352d1d80342471169d3a0ee2827652a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga352d1d80342471169d3a0ee2827652a6">&#9670;&nbsp;</a></span>HWREGH() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWREGH </td>
          <td>(</td>
          <td class="paramtype">base+&#160;</td>
          <td class="paramname"><em>ADC_O_CTL2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= (<a class="code" href="group__adc__api.html#ga352d1d80342471169d3a0ee2827652a6">HWREGH</a>(base + ADC_O_CTL1) &amp;</div>
<div class="line">                                 ~ADC_CTL1_INTPULSEPOS) | (uint16_t)<a class="code" href="group__adc__api.html#ga9c7961db4047d8e3a0aad1a1f3cb6751">pulseMode</a></div>
<div class="ttc" id="agroup__adc__api_html_ga352d1d80342471169d3a0ee2827652a6"><div class="ttname"><a href="group__adc__api.html#ga352d1d80342471169d3a0ee2827652a6">HWREGH</a></div><div class="ttdeci">HWREGH(base+ADC_O_CTL2)</div></div>
<div class="ttc" id="agroup__adc__api_html_ga9c7961db4047d8e3a0aad1a1f3cb6751"><div class="ttname"><a href="group__adc__api.html#ga9c7961db4047d8e3a0aad1a1f3cb6751">pulseMode</a></div><div class="ttdeci">ADC_PulseMode pulseMode</div><div class="ttdef"><b>Definition:</b> adc.h:1274</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga3b0276e379a5a2f071b4794b75bc8411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b0276e379a5a2f071b4794b75bc8411">&#9670;&nbsp;</a></span>ASSERT() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASSERT </td>
          <td>(</td>
          <td class="paramtype">ADC_isBaseValid(base)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga82e04495547c44de1dd2fb5b57a5a015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82e04495547c44de1dd2fb5b57a5a015">&#9670;&nbsp;</a></span>ASSERT() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASSERT </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="group__adc__api.html#ga139e91afbb42ffe7b8e5d6b951c2e299">sampleWindow</a> &gt;=1U) &amp;&amp;(<a class="el" href="group__adc__api.html#ga139e91afbb42ffe7b8e5d6b951c2e299">sampleWindow</a>&lt;=512U)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaaccbe2386a6a27cadaaa3afa23175d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaccbe2386a6a27cadaaa3afa23175d38">&#9670;&nbsp;</a></span>HWREG() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWREG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#ga42b7b3dd4778651a8203b5be9701dedf">ctlRegAddr</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">                   (<a class="code" href="group__adc__api.html#gaaccbe2386a6a27cadaaa3afa23175d38">HWREG</a>(<a class="code" href="group__adc__api.html#ga42b7b3dd4778651a8203b5be9701dedf">ctlRegAddr</a>) &amp; ~((uint32_t)ADC_SOC0CTL_EXTCHSEL_M)) |</div>
<div class="line">                   (uint32_t)<a class="code" href="group__adc__api.html#gaff35d151ed6e343c03d4cefc467055ef">extChannel</a></div>
<div class="ttc" id="agroup__adc__api_html_ga42b7b3dd4778651a8203b5be9701dedf"><div class="ttname"><a href="group__adc__api.html#ga42b7b3dd4778651a8203b5be9701dedf">ctlRegAddr</a></div><div class="ttdeci">ctlRegAddr</div><div class="ttdef"><b>Definition:</b> adc.h:1041</div></div>
<div class="ttc" id="agroup__adc__api_html_gaaccbe2386a6a27cadaaa3afa23175d38"><div class="ttname"><a href="group__adc__api.html#gaaccbe2386a6a27cadaaa3afa23175d38">HWREG</a></div><div class="ttdeci">HWREG(ctlRegAddr)</div></div>
<div class="ttc" id="agroup__adc__api_html_gaff35d151ed6e343c03d4cefc467055ef"><div class="ttname"><a href="group__adc__api.html#gaff35d151ed6e343c03d4cefc467055ef">extChannel</a></div><div class="ttdeci">ADC_SOCNumber uint16_t extChannel</div><div class="ttdef"><b>Definition:</b> adc.h:1101</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga5411b1c1d3f7f9e716076d8a7400eb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5411b1c1d3f7f9e716076d8a7400eb28">&#9670;&nbsp;</a></span>ASSERT() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASSERT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#gaff35d151ed6e343c03d4cefc467055ef">extChannel</a>&lt;=&#160;</td>
          <td class="paramname"><em>15U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa0a16f59e0a70656a4c4f091d92c0954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0a16f59e0a70656a4c4f091d92c0954">&#9670;&nbsp;</a></span>HWREGH() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWREGH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#gab84a03b00f3c041fcca9687504b03a6a">regOffset</a>+&#160;</td>
          <td class="paramname"><em>ADC_O_REP1FRC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaea09d7aa46471f386381dad028facbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea09d7aa46471f386381dad028facbe7">&#9670;&nbsp;</a></span>return() <span class="overload">[1/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__xbar__api.html#gaea30ea7ef8d51d933a82ff1f684ee95f">HWREGH</a>(<a class="el" href="group__adc__api.html#gab84a03b00f3c041fcca9687504b03a6a">regOffset</a>+ADC_O_REP1CTL) &amp;&#160;</td>
          <td class="paramname"><em>ADC_REPSTATUS_MASK</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa8093b760436a6b31ce12d6edcafd591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8093b760436a6b31ce12d6edcafd591">&#9670;&nbsp;</a></span>if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#ga89624cc1f9e5146db40bdc1d89e4e1a7">socNumber</a> &gt;=&#160;</td>
          <td class="paramname"><em>ADC_SOC_NUMBER16</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9e3e86936133b844bbbaccf33f6a7cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e3e86936133b844bbbaccf33f6a7cb3">&#9670;&nbsp;</a></span>HWREG() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWREG </td>
          <td>(</td>
          <td class="paramtype">base+&#160;</td>
          <td class="paramname"><em>regOffset</em></td><td>)</td>
          <td> = <a class="el" href="group__adc__api.html#ga0dba5e75536f43bd1303a498c93bcc52">socMask</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa08f7eccbc6fdd0deb8ffdd71e3d4386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa08f7eccbc6fdd0deb8ffdd71e3d4386">&#9670;&nbsp;</a></span>return() <span class="overload">[2/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="group__xbar__api.html#gaea30ea7ef8d51d933a82ff1f684ee95f">HWREGH</a>(base+ADC_O_INTFLG) &amp;(1U&lt;&lt;((uint16_t) <a class="el" href="group__adc__api.html#gad38a5cb0fdd8e8a9d3ad3e631db6aebb">adcIntNum</a>+4U))) !&#160;</td>
          <td class="paramname"> = <code>0U</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga106b46b23fd24c86b843b45e768ebcd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga106b46b23fd24c86b843b45e768ebcd7">&#9670;&nbsp;</a></span>return() <span class="overload">[3/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="group__xbar__api.html#gaea30ea7ef8d51d933a82ff1f684ee95f">HWREGH</a>(base+ADC_O_INTFLG) &amp;(1U&lt;&lt;(uint16_t) <a class="el" href="group__adc__api.html#gad38a5cb0fdd8e8a9d3ad3e631db6aebb">adcIntNum</a>)) !&#160;</td>
          <td class="paramname"> = <code>0U</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5b71579c06dae1849ebfba59f4755774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b71579c06dae1849ebfba59f4755774">&#9670;&nbsp;</a></span>return() <span class="overload">[4/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="group__xbar__api.html#gaea30ea7ef8d51d933a82ff1f684ee95f">HWREGH</a>(base+ADC_O_INTOVF) &amp;(1U&lt;&lt;(uint16_t) <a class="el" href="group__adc__api.html#gad38a5cb0fdd8e8a9d3ad3e631db6aebb">adcIntNum</a>)) !&#160;</td>
          <td class="paramname"> = <code>0U</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga84e70bfddb8442905743fcbb7a548047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84e70bfddb8442905743fcbb7a548047">&#9670;&nbsp;</a></span>return() <span class="overload">[5/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__xbar__api.html#gaea30ea7ef8d51d933a82ff1f684ee95f">HWREGH</a>(resultBase+(uint32_t) <a class="el" href="group__adc__api.html#gaa112157a688d3a93ad050744df519d8c">ADC_RESULTx_OFFSET_BASE</a>+(uint32_t) <a class="el" href="group__adc__api.html#ga89624cc1f9e5146db40bdc1d89e4e1a7">socNumber</a> *2U)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7d4c1e9c1b468d52f813706bcf11f6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d4c1e9c1b468d52f813706bcf11f6fe">&#9670;&nbsp;</a></span>ASSERT() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASSERT </td>
          <td>(</td>
          <td class="paramtype">((uint16_t) <a class="el" href="group__epwm__api.html#ga0c3340352ff50bb2f9c5a64f95c018eb">trigger</a> &amp;~((uint16_t) 0x1FU))&#160;</td>
          <td class="paramname"> = <code>=0U</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaaa41fbfdd613aa2a847dd86b5cbc1ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa41fbfdd613aa2a847dd86b5cbc1ce3">&#9670;&nbsp;</a></span>ASSERT() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASSERT </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="group__adc__api.html#ga89ada8f35c7000f6307974313149afa3">burstSize</a> &gt;=1U) &amp;&amp;(<a class="el" href="group__adc__api.html#ga89ada8f35c7000f6307974313149afa3">burstSize</a>&lt;=32U)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5cc0d0fc14137db2949367140d6013e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cc0d0fc14137db2949367140d6013e1">&#9670;&nbsp;</a></span>ASSERT() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASSERT </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="group__fsi__api.html#gab8437a9efb8f45f84fc54073f06e1dc7">evtFlags</a> &amp;~0x7U)&#160;</td>
          <td class="paramname"> = <code>=0U</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga61f892c4adb7f04881a8d54dc3f5de54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61f892c4adb7f04881a8d54dc3f5de54">&#9670;&nbsp;</a></span>HWREGH() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWREGH </td>
          <td>(</td>
          <td class="paramtype">base+&#160;</td>
          <td class="paramname"><em>ADC_O_EVTSEL</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= ~(<a class="code" href="group__adc__api.html#ga725ce2418b983a338c5d58a9ca1baad6">intFlags</a> &lt;&lt;</div>
<div class="line">                                        ((uint16_t)<a class="code" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> * 4U))</div>
<div class="ttc" id="agroup__adc__api_html_ga21e8ca529da776715c7e3e9b06210caa"><div class="ttname"><a href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a></div><div class="ttdeci">ADC_PPBNumber ppbNumber</div><div class="ttdef"><b>Definition:</b> adc.h:2060</div></div>
<div class="ttc" id="agroup__adc__api_html_ga725ce2418b983a338c5d58a9ca1baad6"><div class="ttname"><a href="group__adc__api.html#ga725ce2418b983a338c5d58a9ca1baad6">intFlags</a></div><div class="ttdeci">ADC_PPBNumber uint16_t intFlags</div><div class="ttdef"><b>Definition:</b> adc.h:2173</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gabcd51a8d9c150eea2da4d46554c8c9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcd51a8d9c150eea2da4d46554c8c9cd">&#9670;&nbsp;</a></span>ASSERT() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASSERT </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="group__uart__api.html#ga725ce2418b983a338c5d58a9ca1baad6">intFlags</a> &amp;~0x7U)&#160;</td>
          <td class="paramname"> = <code>=0U</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9bcf29a1c889be815fe0c8e786e16e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bcf29a1c889be815fe0c8e786e16e83">&#9670;&nbsp;</a></span>return() <span class="overload">[6/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="group__xbar__api.html#gaea30ea7ef8d51d933a82ff1f684ee95f">HWREGH</a>(base+ADC_O_EVTSTAT) &gt;&gt;((uint16_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *4U)) &amp;&#160;</td>
          <td class="paramname"><em>0x7U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaedb1f991e6c34f5f0557fe50e2231516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedb1f991e6c34f5f0557fe50e2231516">&#9670;&nbsp;</a></span>ASSERT() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASSERT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#ga6e8e21280adfab4d1a5b4275b3aea590">limit</a>&lt;=&#160;</td>
          <td class="paramname"><em>ADC_PPB1LIMIT_LIMIT_M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaba0ea9dcd05b06eedaeec20cf06d4d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba0ea9dcd05b06eedaeec20cf06d4d9f">&#9670;&nbsp;</a></span>return() <span class="overload">[7/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#ga6e8e21280adfab4d1a5b4275b3aea590">limit</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa6216ad4a333348b67164e3116ac97c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6216ad4a333348b67164e3116ac97c1">&#9670;&nbsp;</a></span>return() <span class="overload">[8/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(base+(uint32_t) <a class="el" href="group__adc__api.html#ga437d861f409a157db3f2d9a07344dfca">ADC_PPBxPCOUNT_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *26UL *2UL))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0ce558cee36f8ce219c6380247c17c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ce558cee36f8ce219c6380247c17c26">&#9670;&nbsp;</a></span>return() <span class="overload">[9/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype">(int32_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(base+(uint32_t) <a class="el" href="group__adc__api.html#ga0d1b5698287de79f5f1577fcda816386">ADC_PPBxPSUM_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *26UL *2UL))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4bb0fd4308afdd00d632e74df9675f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bb0fd4308afdd00d632e74df9675f46">&#9670;&nbsp;</a></span>return() <span class="overload">[10/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype">(int32_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(base+(uint32_t) <a class="el" href="group__adc__api.html#ga9ef83b3a78d0983af6c5f2ab72833751">ADC_PPBxPMAX_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *26UL *2UL))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3905c9453aa39afcd6f15324aabd5a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3905c9453aa39afcd6f15324aabd5a3d">&#9670;&nbsp;</a></span>return() <span class="overload">[11/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype">(int32_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(base+(uint32_t) <a class="el" href="group__adc__api.html#gaaab63fb1795587086e1f46416864e2be">ADC_PPBxPMIN_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *26UL *2UL))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga49c8db963f4741895e55005cc35529bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49c8db963f4741895e55005cc35529bd">&#9670;&nbsp;</a></span>return() <span class="overload">[12/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype">(uint16_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(base+(uint32_t) <a class="el" href="group__adc__api.html#gad02c12204c2dc93c27b2500530961b15">ADC_PPBxPMAXI_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *26UL *2UL))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad4ef9958d8841f54c429ead3dbfa68e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4ef9958d8841f54c429ead3dbfa68e4">&#9670;&nbsp;</a></span>return() <span class="overload">[13/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype">(uint16_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(base+(uint32_t) <a class="el" href="group__adc__api.html#gadc8d0aced8122b23437d2ad4e1e143b7">ADC_PPBxPMINI_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *26UL *2UL))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0a97a6a3ceb1ad2ab0a07f5a441722eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a97a6a3ceb1ad2ab0a07f5a441722eb">&#9670;&nbsp;</a></span>ASSERT() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASSERT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sent__api.html#ga3437693c30df099c987147d4b9ff3267">shiftVal</a>&lt;=&#160;</td>
          <td class="paramname"><em>10U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga2af6da15de4478d172a02b0ee5756cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2af6da15de4478d172a02b0ee5756cf3">&#9670;&nbsp;</a></span>ASSERT() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASSERT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#ga17b2a2e1d7f4b9777ad54abc5ecf334c">syncInput</a>&lt;=&#160;</td>
          <td class="paramname"><em>0x1DU</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga683b2bf6fb53eb073dd9713072678f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga683b2bf6fb53eb073dd9713072678f14">&#9670;&nbsp;</a></span>ASSERT() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASSERT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#ga55e53d6079bb80730928d367729ebb30">osIntSrc</a>&lt;=&#160;</td>
          <td class="paramname"><em>1U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9dcd5188270c4229abde65f3a7b209bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dcd5188270c4229abde65f3a7b209bb">&#9670;&nbsp;</a></span>ASSERT() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASSERT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#ga28982f9c9b6a5958ae9fe5a706d3bf0e">compSrc</a>&lt;=&#160;</td>
          <td class="paramname"><em>2U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga45597203f856cb2f176384658a10a8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45597203f856cb2f176384658a10a8a9">&#9670;&nbsp;</a></span>return() <span class="overload">[14/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype">(int32_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(resultBase+(uint32_t) <a class="el" href="group__adc__api.html#ga9d1b25bfa0a3e3943018cfb170511a04">ADC_PPBxSUM_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *4UL *2UL))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae528ab962c5c1b75597f8a4f4d8954ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae528ab962c5c1b75597f8a4f4d8954ce">&#9670;&nbsp;</a></span>return() <span class="overload">[15/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype">(uint32_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(resultBase+(uint32_t) <a class="el" href="group__adc__api.html#ga5a70b72944ed25738a637efa0e0ee2e7">ADC_PPBxCOUNT_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *4UL *2UL))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaafaa5a107523c905ca25f72ab7cb339a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafaa5a107523c905ca25f72ab7cb339a">&#9670;&nbsp;</a></span>return() <span class="overload">[16/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype">(int32_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(resultBase+(uint32_t) <a class="el" href="group__adc__api.html#ga7ca65192da9ebeda9cfd6a649f4ebb40">ADC_PPBxMAX_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *8UL *2UL))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9b7cfb35e4ea026cdf7e190d2c6442e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b7cfb35e4ea026cdf7e190d2c6442e0">&#9670;&nbsp;</a></span>return() <span class="overload">[17/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype">(int32_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(resultBase+(uint32_t) <a class="el" href="group__adc__api.html#ga1228b21a75ea02767101524fbc3d41d8">ADC_PPBxMIN_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *8UL *2UL))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab0cc65462f7abafa3e77554910cb9e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0cc65462f7abafa3e77554910cb9e2e">&#9670;&nbsp;</a></span>return() <span class="overload">[18/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(resultBase+(uint32_t) <a class="el" href="group__adc__api.html#ga5092b64861c237074c57a7218890fc87">ADC_PPBxMAXI_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *8UL *2UL))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab3a7c1e90449ef574b46129d3f73ddd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3a7c1e90449ef574b46129d3f73ddd7">&#9670;&nbsp;</a></span>return() <span class="overload">[19/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(resultBase+(uint32_t) <a class="el" href="group__adc__api.html#ga732d9c8c6ef51e36ad606c480c0908f7">ADC_PPBxMINI_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *8UL *2UL))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad5acbf69975cad1e5610d5b59e46a290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5acbf69975cad1e5610d5b59e46a290">&#9670;&nbsp;</a></span>return() <span class="overload">[20/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype">(int32_t) <a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(resultBase+(uint32_t) <a class="el" href="group__adc__api.html#gab93b3d59039266605bee26e11b6077be">ADC_PPBxRESULT_OFFSET_BASE</a>+((uint32_t) <a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a> *4UL))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaeb0170d4f6e074a689abefb540bf355a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb0170d4f6e074a689abefb540bf355a">&#9670;&nbsp;</a></span>return() <span class="overload">[21/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__xbar__api.html#gaea30ea7ef8d51d933a82ff1f684ee95f">HWREGH</a>(base+<a class="el" href="group__adc__api.html#ga5c1608f532c04cd01ed2f1a2497e84d0">ppbOffset</a>) &amp;&#160;</td>
          <td class="paramname"><em>ADC_PPB2STAMP_DLYSTAMP_M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gabe693c168f098da13939e38298d305f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe693c168f098da13939e38298d305f2">&#9670;&nbsp;</a></span>HWREG() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWREG </td>
          <td>(</td>
          <td class="paramtype">base+&#160;</td>
          <td class="paramname"><em>ppbOffset</em></td><td>)</td>
          <td> &amp; = ~ECAP_MUNIT_1_CTL_DEBUG_RANGE_EN</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaaef5d28bb05e43ee59b57b4d58041a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaef5d28bb05e43ee59b57b4d58041a8b">&#9670;&nbsp;</a></span>HWREGH() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWREGH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#gaf26a4c8dacfbaa9cb56118d0798b02ac">intRegAddr</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        (<a class="code" href="group__adc__api.html#ga352d1d80342471169d3a0ee2827652a6">HWREGH</a>(<a class="code" href="group__adc__api.html#gaf26a4c8dacfbaa9cb56118d0798b02ac">intRegAddr</a>) &amp; ~(ADC_INTSEL1N2_INT1SEL_M &lt;&lt; <a class="code" href="group__adc__api.html#gab5d94fb94d4664d466f10e584691e8ee">shiftVal</a>)) |</div>
<div class="line">        ((uint16_t)<a class="code" href="group__adc__api.html#ga8da51b05e4cb9c23e458f65f9610f4fe">intTrigger</a> &lt;&lt; <a class="code" href="group__adc__api.html#gab5d94fb94d4664d466f10e584691e8ee">shiftVal</a>)</div>
<div class="ttc" id="agroup__adc__api_html_ga8da51b05e4cb9c23e458f65f9610f4fe"><div class="ttname"><a href="group__adc__api.html#ga8da51b05e4cb9c23e458f65f9610f4fe">intTrigger</a></div><div class="ttdeci">ADC_IntNumber ADC_IntTrigger intTrigger</div><div class="ttdef"><b>Definition:</b> adc.h:3580</div></div>
<div class="ttc" id="agroup__adc__api_html_gab5d94fb94d4664d466f10e584691e8ee"><div class="ttname"><a href="group__adc__api.html#gab5d94fb94d4664d466f10e584691e8ee">shiftVal</a></div><div class="ttdeci">shiftVal</div><div class="ttdef"><b>Definition:</b> adc.h:1240</div></div>
<div class="ttc" id="agroup__adc__api_html_gaf26a4c8dacfbaa9cb56118d0798b02ac"><div class="ttname"><a href="group__adc__api.html#gaf26a4c8dacfbaa9cb56118d0798b02ac">intRegAddr</a></div><div class="ttdeci">intRegAddr</div><div class="ttdef"><b>Definition:</b> adc.h:3499</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gab1b0332600fbe71eb791fb48b8c7dadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1b0332600fbe71eb791fb48b8c7dadd">&#9670;&nbsp;</a></span>HWREGH() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWREGH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#gaf26a4c8dacfbaa9cb56118d0798b02ac">intRegAddr</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp; = ~(ADC_INTSEL1N2_INT1CONT &lt;&lt; <a class="el" href="group__sent__api.html#ga3437693c30df099c987147d4b9ff3267">shiftVal</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6b38cd2f4d5acd8597da5fd7e7284803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b38cd2f4d5acd8597da5fd7e7284803">&#9670;&nbsp;</a></span>if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#ga0283977132d023294bd0a34faf61695c">refMode</a>&#160;</td>
          <td class="paramname"> = <code>=&#160;<a class="el" href="group__adc__api.html#ggad33ea1f3c3db73f25e0bdf15a86be959afbf176ce408c0621a20dd98442ac05ae">ADC_REFERENCE_INTERNAL</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gacedd9c80ea9283f370d77471a2e2f058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacedd9c80ea9283f370d77471a2e2f058">&#9670;&nbsp;</a></span>HWREGH() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWREGH </td>
          <td>(</td>
          <td class="paramtype">scBase+ADC_O_RESSEL1+(uint16_t) <a class="el" href="group__adc__api.html#gafc980d327c8cc70836562b64b9e417fe">checkInst</a> *&#160;</td>
          <td class="paramname"><em>2U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga22343e79baeff4af85e0dc0ce101ca97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22343e79baeff4af85e0dc0ce101ca97">&#9670;&nbsp;</a></span>ASSERT() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASSERT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#ga0c2bf3e18f553a6c2d34b58094ba5402">tolerance</a>&lt;=&#160;</td>
          <td class="paramname"><em>ADC_TOLERANCE_TOLERANCE_M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga00d2774a5fe75be9f44af822a6b4c4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00d2774a5fe75be9f44af822a6b4c4b3">&#9670;&nbsp;</a></span>HWREGH() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWREGH </td>
          <td>(</td>
          <td class="paramtype">scBase+&#160;</td>
          <td class="paramname"><em>ADC_O_TOLERANCE</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaef36cbbad38929ea296f4ee0175fe18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef36cbbad38929ea296f4ee0175fe18f">&#9670;&nbsp;</a></span>return() <span class="overload">[22/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(scBase+ADC_O_CHECKRESULT1+(uint16_t) <a class="el" href="group__adc__api.html#gafc980d327c8cc70836562b64b9e417fe">checkInst</a> *2U) &amp;&#160;</td>
          <td class="paramname"><em>ADC_CHECKRESULT1_RESULT_M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaec443b5c8199037ba0edd64de5c8bedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec443b5c8199037ba0edd64de5c8bedb">&#9670;&nbsp;</a></span>HWREG() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWREG </td>
          <td>(</td>
          <td class="paramtype">scIntEvtBase+ADC_O_CHECKEVT1SEL1+((uint32_t) <a class="el" href="group__adc__api.html#ga7a35b7eb8077674ad9084e6ff665f99f">checkEvent</a>+(uint32_t) <a class="el" href="group__adc__api.html#gaf1b4e5b69a7ac95f93c002311a6181c4">checkResult</a>) *&#160;</td>
          <td class="paramname"><em>2UL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa5020d6131f4b31d16b5858af635cc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5020d6131f4b31d16b5858af635cc9f">&#9670;&nbsp;</a></span>HWREG() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWREG </td>
          <td>(</td>
          <td class="paramtype">scIntEvtBase+ADC_O_CHECKEVT1SEL1+((uint32_t) <a class="el" href="group__adc__api.html#ga7a35b7eb8077674ad9084e6ff665f99f">checkEvent</a>+(uint32_t) <a class="el" href="group__adc__api.html#gaf1b4e5b69a7ac95f93c002311a6181c4">checkResult</a>) *&#160;</td>
          <td class="paramname"><em>2UL</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad1fafc7f856e9246f4426f3bed1ccf39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1fafc7f856e9246f4426f3bed1ccf39">&#9670;&nbsp;</a></span>HWREG() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWREG </td>
          <td>(</td>
          <td class="paramtype">scIntEvtBase+ADC_O_CHECKINTSEL1+(uint32_t) <a class="el" href="group__adc__api.html#gaf1b4e5b69a7ac95f93c002311a6181c4">checkResult</a> *&#160;</td>
          <td class="paramname"><em>2UL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5ee94f19506c2867c4b6e40be634d20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ee94f19506c2867c4b6e40be634d20a">&#9670;&nbsp;</a></span>HWREG() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWREG </td>
          <td>(</td>
          <td class="paramtype">scIntEvtBase+ADC_O_CHECKINTSEL1+(uint32_t) <a class="el" href="group__adc__api.html#gaf1b4e5b69a7ac95f93c002311a6181c4">checkResult</a> *&#160;</td>
          <td class="paramname"><em>2UL</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1730dc785e8cdba596e7d75ef35bc3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1730dc785e8cdba596e7d75ef35bc3b6">&#9670;&nbsp;</a></span>return() <span class="overload">[23/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(scIntEvtBase+ADC_O_OOTFLG+(uint32_t) <a class="el" href="group__adc__api.html#gae4e0c18e893b7318af14779e8db7fdc1">checkerFlag</a> *2UL) &amp;(1U&lt;&lt;(uint32_t) <a class="el" href="group__adc__api.html#gaf6b93c709cbc4bc7f896eb20d9f82f70">checkerNumber</a>)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga09ab9f0ec7c6c1c1f769ce284189ff70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09ab9f0ec7c6c1c1f769ce284189ff70">&#9670;&nbsp;</a></span>HWREG() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWREG </td>
          <td>(</td>
          <td class="paramtype">scIntEvtBase+ADC_O_OOTFLGCLR+(uint32_t) <a class="el" href="group__adc__api.html#gae4e0c18e893b7318af14779e8db7fdc1">checkerFlag</a> *&#160;</td>
          <td class="paramname"><em>2UL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga16a0ec303eaada432c087317faeebe23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16a0ec303eaada432c087317faeebe23">&#9670;&nbsp;</a></span>HWREG() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HWREG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#gab84a03b00f3c041fcca9687504b03a6a">regOffset</a>+&#160;</td>
          <td class="paramname"><em>ADC_O_REP1CTL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= (<a class="code" href="group__adc__api.html#gaaccbe2386a6a27cadaaa3afa23175d38">HWREG</a>(<a class="code" href="group__adc__api.html#gab84a03b00f3c041fcca9687504b03a6a">regOffset</a> + ADC_O_REP1CTL) &amp;</div>
<div class="line">                        ~((uint32_t)ADC_REP1CTL_TRIGGER_M)) |</div>
<div class="line">                        ((uint32_t)<a class="code" href="group__adc__api.html#ga0c3340352ff50bb2f9c5a64f95c018eb">trigger</a> &lt;&lt; ADC_REP1CTL_TRIGGER_S)</div>
<div class="ttc" id="agroup__adc__api_html_ga0c3340352ff50bb2f9c5a64f95c018eb"><div class="ttname"><a href="group__adc__api.html#ga0c3340352ff50bb2f9c5a64f95c018eb">trigger</a></div><div class="ttdeci">ADC_SOCNumber ADC_Trigger trigger</div><div class="ttdef"><b>Definition:</b> adc.h:1025</div></div>
<div class="ttc" id="agroup__adc__api_html_gab84a03b00f3c041fcca9687504b03a6a"><div class="ttname"><a href="group__adc__api.html#gab84a03b00f3c041fcca9687504b03a6a">regOffset</a></div><div class="ttdeci">regOffset</div><div class="ttdef"><b>Definition:</b> adc.h:1150</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga3f1b33eec6dbc5b65385e311b6a0511f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f1b33eec6dbc5b65385e311b6a0511f">&#9670;&nbsp;</a></span>return() <span class="overload">[24/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(<a class="el" href="group__adc__api.html#gab84a03b00f3c041fcca9687504b03a6a">regOffset</a>+ADC_O_REP1CTL) &amp;(1U&lt;&lt; <a class="el" href="group__adc__api.html#ga869b25bb4e431bfcd0eb9e1665e89284">ADC_REP1CTL_ACTIVEMODE_S</a>)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad50918b02c2b62168201a89022b0f894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad50918b02c2b62168201a89022b0f894">&#9670;&nbsp;</a></span>return() <span class="overload">[25/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__uart__api.html#ga208aa492e12955faf3ab058f59a3a3cc">HWREG</a>(<a class="el" href="group__adc__api.html#gab84a03b00f3c041fcca9687504b03a6a">regOffset</a>+ADC_O_REP1CTL) &amp;(1U&lt;&lt; <a class="el" href="group__adc__api.html#gab842e8dcd72fbf8a8b0d2278ed737701">ADC_REP1CTL_MODULEBUSY_S</a>)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9be520d669cdc02fd357a5281f032884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9be520d669cdc02fd357a5281f032884">&#9670;&nbsp;</a></span>ASSERT() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASSERT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#gace198ded246b134826243276d46384a1">repCount</a>&lt;=&#160;</td>
          <td class="paramname"><em>127U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4a3111e591fb1bc4bb1d40487aff721f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a3111e591fb1bc4bb1d40487aff721f">&#9670;&nbsp;</a></span>ADC_configureRepeater()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC_configureRepeater </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>repInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structADC__RepeaterConfig.html">ADC_RepeaterConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the trigger repeater.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">repInstance</td><td>is the repeater instance. </td></tr>
    <tr><td class="paramname">config</td><td>is the desired repeater configuration.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures ADC trigger repeater for repeater mode, trigger and sync along with count, phase delay and spread of triggers.</p>
<p>The <em>repInstance</em> is the repeater instance to be configured. Valid values for this parameter can be referred from the enum <em>ADC_RepInstance</em>.</p>
<p>The <em>config</em> is the desired trigger repeater configuration which is of type <em><a class="el" href="structADC__RepeaterConfig.html">ADC_RepeaterConfig</a></em>.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga82811db076d3d59caa26e85fe3f9e4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82811db076d3d59caa26e85fe3f9e4a9">&#9670;&nbsp;</a></span>ADC_setupSOCRefloChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC_setupSOCRefloChannel </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#ga254fedc72090784dcfcdcebebdf3ea39">ADC_SOCNumber</a>&#160;</td>
          <td class="paramname"><em>socNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#ga7973b7d12fc7bfb96bd276b0a5926834">ADC_Trigger</a>&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sampleWindow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#ga429dd4804497c259c3e869cbca38106c">ADC_ChannelType</a>&#160;</td>
          <td class="paramname"><em>channelType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cofigure the internal connection to route VREFLO to ADC module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">socNumber</td><td>is the number of the start-of-conversion. </td></tr>
    <tr><td class="paramname">trigger</td><td>the source that will cause the SOC. </td></tr>
    <tr><td class="paramname">sampleWindow</td><td>is the acquisition window duration. </td></tr>
    <tr><td class="paramname">channelType</td><td>specifies the type of the ADC channel.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the internal connection to route VREFLO to the ADC module as all the modules do not have direct connection to internal VREFLO.</p>
<p>The <em>socNumber</em> number is a value <b>ADC_SOC_NUMBERX</b> where X is a number from 0 to 15 specifying which SOC is to be configured on the ADC module specified by <em>base</em>.</p>
<p>The <em>trigger</em> parameter takes the same values as the ADC_setupSOC() API and the <em>sampleWindow</em> parameter is the acquisition window duration in SYSCLK cycles. It should be a value between 1 and 512 cycles inclusive.</p>
<p>The <em>channelType</em> parameter must be one of the following: <b>ADC_CHANNEL_ODD</b> or <b>ADC_CHANNEL_EVEN</b> based on the channel selection.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gac6b5f4a6e28b845462cb44d00889a6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6b5f4a6e28b845462cb44d00889a6f9">&#9670;&nbsp;</a></span>ADC_setMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC_setMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#ga61bdbeb0bb5a4b445ba88d05a51c701b">ADC_Resolution</a>&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#gabb3445edb2b4d559233957cd6311d909">ADC_SignalMode</a>&#160;</td>
          <td class="paramname"><em>signalMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the analog-to-digital converter resolution and signal mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">resolution</td><td>is the resolution of the converter (12 or 16 bits). </td></tr>
    <tr><td class="paramname">signalMode</td><td>is the input signal mode of the converter.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the ADC module's conversion resolution and input signal mode and ensures that the corresponding trims are loaded.</p>
<p>The <em>resolution</em> parameter specifies the resolution of the conversion. It can be 12-bit or 16-bit specified by <b>ADC_RESOLUTION_12BIT</b> or <b>ADC_RESOLUTION_16BIT</b>.</p>
<p>The <em>signalMode</em> parameter specifies the signal mode. In single-ended mode, which is indicated by <b>ADC_MODE_SINGLE_ENDED</b>, the input voltage is sampled on a single pin referenced to VREFLO. In differential mode, which is indicated by <b>ADC_MODE_DIFFERENTIAL</b>, the input voltage to the converter is sampled on a pair of input pins, a positive and a negative.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gabe0d15283495abce50c21eb97a8491a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe0d15283495abce50c21eb97a8491a4">&#9670;&nbsp;</a></span>ADC_setOffsetTrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC_setOffsetTrim </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the offset trim for the desired ADC instance</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function loads the offset trims for the desired ADC instance.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga245251ff514fae5b6959e78842bec621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga245251ff514fae5b6959e78842bec621">&#9670;&nbsp;</a></span>ADC_setINLTrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC_setINLTrim </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the INL trim for the desired ADC instance</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function loads the INL trims for the desired ADC instance.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga378cb44d8b8674121e44de0acf48006f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga378cb44d8b8674121e44de0acf48006f">&#9670;&nbsp;</a></span>ADC_setPPBTripLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC_setPPBTripLimits </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__adc__api.html#ga17f0c071ab2c71a40e3d95c9eeadf3b9">ADC_PPBNumber</a>&#160;</td>
          <td class="paramname"><em>ppbNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>tripHiLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>tripLoLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the windowed trip limits for a PPB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base address of the ADC module. </td></tr>
    <tr><td class="paramname">ppbNumber</td><td>is the number of the post-processing block. </td></tr>
    <tr><td class="paramname">tripHiLimit</td><td>is the value is the digital comparator trip high limit. </td></tr>
    <tr><td class="paramname">tripLoLimit</td><td>is the value is the digital comparator trip low limit.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the windowed trip limits for a PPB. These values set the digital comparator so that when one of the values is exceeded, either a high or low trip event will occur.</p>
<p>The <em>ppbNumber</em> is a value <b>ADC_PPB_NUMBERX</b> where X is a value from 1 to 4 inclusive that identifies a PPB to be configured.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gad63bb88dce8ef083d387ecd1502ef54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad63bb88dce8ef083d387ecd1502ef54f">&#9670;&nbsp;</a></span>clkPrescale</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#ga8d6ae5ac93027785bc422c07d87f4a5a">ADC_ClkPrescale</a> clkPrescale</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a>(ADC_isBaseValid(base))</div>
<div class="ttc" id="agroup__adc__api_html_ga3b0276e379a5a2f071b4794b75bc8411"><div class="ttname"><a href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a></div><div class="ttdeci">ASSERT(ADC_isBaseValid(base))</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga89624cc1f9e5146db40bdc1d89e4e1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89624cc1f9e5146db40bdc1d89e4e1a7">&#9670;&nbsp;</a></span>socNumber</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#ga254fedc72090784dcfcdcebebdf3ea39">ADC_SOCNumber</a> socNumber</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a>(ADC_isBaseValid(base))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga0c3340352ff50bb2f9c5a64f95c018eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c3340352ff50bb2f9c5a64f95c018eb">&#9670;&nbsp;</a></span>trigger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__epwm__api.html#ga6a5116a4a69a819f7a7cca02f419a75c">EPWM_ActionQualifierTriggerSource</a> trigger</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    uint16_t <a class="code" href="group__adc__api.html#gab5d94fb94d4664d466f10e584691e8ee">shiftVal</a></div>
</div><!-- fragment -->
</div>
</div>
<a id="gae3e936152484e3180e158e597904a57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3e936152484e3180e158e597904a57e">&#9670;&nbsp;</a></span>channel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sent__api.html#ga0ec5500e19daa6bdb9450350ffb20d5d">SENT_Channel</a> channel</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line"> </div>
<div class="line">    uint32_t <a class="code" href="group__sent__api.html#gae71d259c05b183562ea34ba742bb8860">channelOffset</a></div>
<div class="ttc" id="agroup__sent__api_html_gae71d259c05b183562ea34ba742bb8860"><div class="ttname"><a href="group__sent__api.html#gae71d259c05b183562ea34ba742bb8860">channelOffset</a></div><div class="ttdeci">channelOffset</div><div class="ttdef"><b>Definition:</b> sent.h:1627</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga139e91afbb42ffe7b8e5d6b951c2e299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga139e91afbb42ffe7b8e5d6b951c2e299">&#9670;&nbsp;</a></span>sampleWindow</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#ga254fedc72090784dcfcdcebebdf3ea39">ADC_SOCNumber</a> <a class="el" href="group__adc__api.html#ga7973b7d12fc7bfb96bd276b0a5926834">ADC_Trigger</a> <a class="el" href="group__adc__api.html#gad7b9fa1ae8a65e534cce7d26fa0984f6">ADC_Channel</a> uint32_t sampleWindow</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    uint32_t <a class="code" href="group__adc__api.html#ga42b7b3dd4778651a8203b5be9701dedf">ctlRegAddr</a>, <a class="code" href="group__adc__api.html#ga2c4686cc52780432803d65f40f5d96b1">mask</a></div>
<div class="ttc" id="agroup__adc__api_html_ga2c4686cc52780432803d65f40f5d96b1"><div class="ttname"><a href="group__adc__api.html#ga2c4686cc52780432803d65f40f5d96b1">mask</a></div><div class="ttdeci">mask</div><div class="ttdef"><b>Definition:</b> adc.h:1036</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga2c4686cc52780432803d65f40f5d96b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c4686cc52780432803d65f40f5d96b1">&#9670;&nbsp;</a></span>mask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lin__api.html#gac302f973c0a21999026980d9e62c856a">LIN_PinSampleMask</a> mask = (ADC_SOC0CTL_CHSEL_M | ADC_SOC0CTL_TRIGSEL_M | ADC_SOC0CTL_ACQPS_M)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga42b7b3dd4778651a8203b5be9701dedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42b7b3dd4778651a8203b5be9701dedf">&#9670;&nbsp;</a></span>ctlRegAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ctlRegAddr = base + <a class="el" href="group__adc__api.html#ga68f8653816fd2da9ed485b770ce4962f">ADC_SOCxCTL_OFFSET_BASE</a> + ((uint32_t)<a class="el" href="group__adc__api.html#ga89624cc1f9e5146db40bdc1d89e4e1a7">socNumber</a> * 4U)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaff35d151ed6e343c03d4cefc467055ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff35d151ed6e343c03d4cefc467055ef">&#9670;&nbsp;</a></span>extChannel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#ga254fedc72090784dcfcdcebebdf3ea39">ADC_SOCNumber</a> uint16_t extChannel</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    uint32_t <a class="code" href="group__adc__api.html#ga42b7b3dd4778651a8203b5be9701dedf">ctlRegAddr</a></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8cd5cacce3a01f77ac3c814e740d2632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cd5cacce3a01f77ac3c814e740d2632">&#9670;&nbsp;</a></span>repInstance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t repInstance</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">  uint32_t <a class="code" href="group__adc__api.html#gab84a03b00f3c041fcca9687504b03a6a">regOffset</a></div>
</div><!-- fragment -->
</div>
</div>
<a id="gab84a03b00f3c041fcca9687504b03a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab84a03b00f3c041fcca9687504b03a6a">&#9670;&nbsp;</a></span>regOffset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t regOffset = base + (2U * <a class="el" href="group__adc__api.html#ga8cd5cacce3a01f77ac3c814e740d2632">repInstance</a> * (<a class="el" href="group__adc__api.html#ga18b630821695c4f84107fefaf46029fd">ADC_REPxCTL_STEP</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab5d94fb94d4664d466f10e584691e8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5d94fb94d4664d466f10e584691e8ee">&#9670;&nbsp;</a></span>shiftVal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t shiftVal = (uint16_t)<a class="el" href="group__adc__api.html#ga89624cc1f9e5146db40bdc1d89e4e1a7">socNumber</a> &lt;&lt; 1U</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9c7961db4047d8e3a0aad1a1f3cb6751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c7961db4047d8e3a0aad1a1f3cb6751">&#9670;&nbsp;</a></span>pulseMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#gacd907be60c59083e2bf41efcc36d4baf">ADC_PulseMode</a> pulseMode</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a>(ADC_isBaseValid(base))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga777e62e5af98d42fb5f6db2a22eb07e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga777e62e5af98d42fb5f6db2a22eb07e5">&#9670;&nbsp;</a></span>cycleOffset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t cycleOffset</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a>(ADC_isBaseValid(base))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga4a3dcebc2dbc68128688bedfe38a4411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a3dcebc2dbc68128688bedfe38a4411">&#9670;&nbsp;</a></span>mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__rtdma__api.html#gad22afffd7626658740f5bee08b6ffe67">DMA_BurstSignalingMode</a> mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a>(ADC_isBaseValid(base))</div>
</div><!-- fragment -->
</div>
</div>
<a id="gad38a5cb0fdd8e8a9d3ad3e631db6aebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad38a5cb0fdd8e8a9d3ad3e631db6aebb">&#9670;&nbsp;</a></span>adcIntNum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#ga2cb95bd359b9df2dfd0977ce2020df06">ADC_IntNumber</a> adcIntNum</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a>(ADC_isBaseValid(base))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga0dba5e75536f43bd1303a498c93bcc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dba5e75536f43bd1303a498c93bcc52">&#9670;&nbsp;</a></span>socMask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t socMask</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a>(ADC_isBaseValid(base))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga89ada8f35c7000f6307974313149afa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89ada8f35c7000f6307974313149afa3">&#9670;&nbsp;</a></span>burstSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#ga7973b7d12fc7bfb96bd276b0a5926834">ADC_Trigger</a> uint16_t burstSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    uint16_t <a class="code" href="group__adc__api.html#ga69ec1a20db760e04bc0b984106e19d80">regValue</a></div>
<div class="ttc" id="agroup__adc__api_html_ga69ec1a20db760e04bc0b984106e19d80"><div class="ttname"><a href="group__adc__api.html#ga69ec1a20db760e04bc0b984106e19d80">regValue</a></div><div class="ttdeci">regValue</div><div class="ttdef"><b>Definition:</b> adc.h:1889</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga69ec1a20db760e04bc0b984106e19d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69ec1a20db760e04bc0b984106e19d80">&#9670;&nbsp;</a></span>regValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regValue</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= (uint16_t)<a class="code" href="group__adc__api.html#ga0c3340352ff50bb2f9c5a64f95c018eb">trigger</a> | ((<a class="code" href="group__adc__api.html#ga89ada8f35c7000f6307974313149afa3">burstSize</a> - 1U) &lt;&lt;</div>
<div class="line">                                    ADC_BURSTCTL_BURSTSIZE_S)</div>
<div class="ttc" id="agroup__adc__api_html_ga89ada8f35c7000f6307974313149afa3"><div class="ttname"><a href="group__adc__api.html#ga89ada8f35c7000f6307974313149afa3">burstSize</a></div><div class="ttdeci">ADC_Trigger uint16_t burstSize</div><div class="ttdef"><b>Definition:</b> adc.h:1875</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa40c111df58db53e2a729131903130dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa40c111df58db53e2a729131903130dc">&#9670;&nbsp;</a></span>priMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#ga4f60e7ea55578eb4eb621f31b0b8d434">ADC_PriorityMode</a> priMode</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a>(ADC_isBaseValid(base))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga824c2018fac76a21f1261808db860fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga824c2018fac76a21f1261808db860fb1">&#9670;&nbsp;</a></span>modeVal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#ga1382e9ae48e28340cff1ea75f6f59ac8">ADC_OSDetectMode</a> modeVal</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__adc__api.html#ga352d1d80342471169d3a0ee2827652a6">HWREGH</a>(base + ADC_O_OSDETECT) = ((<a class="code" href="group__adc__api.html#ga352d1d80342471169d3a0ee2827652a6">HWREGH</a>(base + ADC_O_OSDETECT) &amp;</div>
<div class="line">                                     (~ADC_OSDETECT_DETECTCFG_M)) |</div>
<div class="line">                                     (uint16_t)<a class="code" href="group__adc__api.html#ga824c2018fac76a21f1261808db860fb1">modeVal</a>)</div>
<div class="ttc" id="agroup__adc__api_html_ga824c2018fac76a21f1261808db860fb1"><div class="ttname"><a href="group__adc__api.html#ga824c2018fac76a21f1261808db860fb1">modeVal</a></div><div class="ttdeci">ADC_OSDetectMode modeVal</div><div class="ttdef"><b>Definition:</b> adc.h:2021</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga21e8ca529da776715c7e3e9b06210caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21e8ca529da776715c7e3e9b06210caa">&#9670;&nbsp;</a></span>ppbNumber</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#ga17f0c071ab2c71a40e3d95c9eeadf3b9">ADC_PPBNumber</a> ppbNumber</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a>(ADC_isBaseValid(base))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga5c1608f532c04cd01ed2f1a2497e84d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c1608f532c04cd01ed2f1a2497e84d0">&#9670;&nbsp;</a></span>ppbOffset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ppbOffset = (<a class="el" href="group__adc__api.html#gabc6bdbd41b411aac98ed70aae0409333">ADC_PPBxCONFIG_STEP</a> * (uint32_t)<a class="el" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a>) + ADC_O_PPB1CONFIG</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab8437a9efb8f45f84fc54073f06e1dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8437a9efb8f45f84fc54073f06e1dc7">&#9670;&nbsp;</a></span>evtFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t evtFlags</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a>(ADC_isBaseValid(base))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga725ce2418b983a338c5d58a9ca1baad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga725ce2418b983a338c5d58a9ca1baad6">&#9670;&nbsp;</a></span>intFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t intFlags</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a>(ADC_isBaseValid(base))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga6e8e21280adfab4d1a5b4275b3aea590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e8e21280adfab4d1a5b4275b3aea590">&#9670;&nbsp;</a></span>limit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">limit</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    uint32_t <a class="code" href="group__adc__api.html#ga5c1608f532c04cd01ed2f1a2497e84d0">ppbOffset</a></div>
<div class="ttc" id="agroup__adc__api_html_ga5c1608f532c04cd01ed2f1a2497e84d0"><div class="ttname"><a href="group__adc__api.html#ga5c1608f532c04cd01ed2f1a2497e84d0">ppbOffset</a></div><div class="ttdeci">ppbOffset</div><div class="ttdef"><b>Definition:</b> adc.h:2072</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga17b2a2e1d7f4b9777ad54abc5ecf334c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17b2a2e1d7f4b9777ad54abc5ecf334c">&#9670;&nbsp;</a></span>syncInput</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="group__adc__api.html#ga51ed1bc5073c7ef6394c3538b007e730">ADC_SyncInput</a> syncInput</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    uint32_t <a class="code" href="group__adc__api.html#ga5c1608f532c04cd01ed2f1a2497e84d0">ppbOffset</a></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga55e53d6079bb80730928d367729ebb30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55e53d6079bb80730928d367729ebb30">&#9670;&nbsp;</a></span>osIntSrc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#ga17f0c071ab2c71a40e3d95c9eeadf3b9">ADC_PPBNumber</a> uint16_t osIntSrc</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    uint32_t <a class="code" href="group__adc__api.html#ga5c1608f532c04cd01ed2f1a2497e84d0">ppbOffset</a></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga28982f9c9b6a5958ae9fe5a706d3bf0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28982f9c9b6a5958ae9fe5a706d3bf0e">&#9670;&nbsp;</a></span>compSrc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#ga17f0c071ab2c71a40e3d95c9eeadf3b9">ADC_PPBNumber</a> uint16_t compSrc</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    uint32_t <a class="code" href="group__adc__api.html#ga5c1608f532c04cd01ed2f1a2497e84d0">ppbOffset</a></div>
</div><!-- fragment -->
</div>
</div>
<a id="gafa14b7b87c8edcfbf2cca6ff7f68e4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa14b7b87c8edcfbf2cca6ff7f68e4ac">&#9670;&nbsp;</a></span>offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__emif__api.html#gafb00746b18326a7755d4c2ee9fabe83e">EMIF_AsyncCSOffset</a> offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    uint32_t <a class="code" href="group__adc__api.html#ga5c1608f532c04cd01ed2f1a2497e84d0">ppbOffset</a></div>
</div><!-- fragment -->
</div>
</div>
<a id="gad8e3e18edd4ca626355a1c21f66526f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8e3e18edd4ca626355a1c21f66526f8">&#9670;&nbsp;</a></span>ppbLoOffset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ppbLoOffset</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= (<a class="code" href="group__adc__api.html#gae674bf5583947a8c5665cc2b908b3053">ADC_PPBxTRIPLO_STEP</a> * (uint32_t)<a class="code" href="group__adc__api.html#ga21e8ca529da776715c7e3e9b06210caa">ppbNumber</a>) +</div>
<div class="line">                  ADC_O_PPB1TRIPLO</div>
<div class="ttc" id="agroup__adc__api_html_gae674bf5583947a8c5665cc2b908b3053"><div class="ttname"><a href="group__adc__api.html#gae674bf5583947a8c5665cc2b908b3053">ADC_PPBxTRIPLO_STEP</a></div><div class="ttdeci">#define ADC_PPBxTRIPLO_STEP</div><div class="ttdef"><b>Definition:</b> adc.h:92</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf26a4c8dacfbaa9cb56118d0798b02ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf26a4c8dacfbaa9cb56118d0798b02ac">&#9670;&nbsp;</a></span>intRegAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">intRegAddr = base + <a class="el" href="group__adc__api.html#ga5080ff53784043785bca57fbef96203a">ADC_INTSELxNy_OFFSET_BASE</a> + ((uint32_t)<a class="el" href="group__adc__api.html#gad38a5cb0fdd8e8a9d3ad3e631db6aebb">adcIntNum</a> &gt;&gt; 1) * 2U</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8da51b05e4cb9c23e458f65f9610f4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8da51b05e4cb9c23e458f65f9610f4fe">&#9670;&nbsp;</a></span>intTrigger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#ga2cb95bd359b9df2dfd0977ce2020df06">ADC_IntNumber</a> <a class="el" href="group__adc__api.html#gae4463487eb170cf7f23699e7f01407de">ADC_IntTrigger</a> intTrigger</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    uint32_t <a class="code" href="group__adc__api.html#gaf26a4c8dacfbaa9cb56118d0798b02ac">intRegAddr</a></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga0283977132d023294bd0a34faf61695c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0283977132d023294bd0a34faf61695c">&#9670;&nbsp;</a></span>refMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#gad33ea1f3c3db73f25e0bdf15a86be959">ADC_ReferenceMode</a> refMode</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa8652499e99170b0d384205c474c675c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8652499e99170b0d384205c474c675c">&#9670;&nbsp;</a></span>vref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#gad33ea1f3c3db73f25e0bdf15a86be959">ADC_ReferenceMode</a> float32_t vref</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    float32_t <a class="code" href="group__adc__api.html#ga905c521e05ec8042631a912b71d0454e">temp</a></div>
<div class="ttc" id="agroup__adc__api_html_ga905c521e05ec8042631a912b71d0454e"><div class="ttname"><a href="group__adc__api.html#ga905c521e05ec8042631a912b71d0454e">temp</a></div><div class="ttdeci">temp</div><div class="ttdef"><b>Definition:</b> adc.h:3731</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga905c521e05ec8042631a912b71d0454e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga905c521e05ec8042631a912b71d0454e">&#9670;&nbsp;</a></span>temp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">temp = (float32_t)tempResult * (<a class="el" href="group__adc__api.html#gaa8652499e99170b0d384205c474c675c">vref</a> / 2.5F)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0544c3fe466e421738dae463968b70ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0544c3fe466e421738dae463968b70ba">&#9670;&nbsp;</a></span>else</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">else</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">        <span class="keywordflow">return</span>((int16_t)((((int32_t)<a class="code" href="group__adc__api.html#ga905c521e05ec8042631a912b71d0454e">temp</a> - <a class="code" href="group__adc__api.html#ga7cd21facf4d774ca7afc43a915246fe7">ADC_EXT_REF_TSOFFSET</a>) * 4096) /</div>
<div class="line">                         <a class="code" href="group__adc__api.html#gacdf6f073dd1336bc9d4a386155bb53a3">ADC_EXT_REF_TSSLOPE</a>))</div>
<div class="ttc" id="agroup__adc__api_html_ga7cd21facf4d774ca7afc43a915246fe7"><div class="ttname"><a href="group__adc__api.html#ga7cd21facf4d774ca7afc43a915246fe7">ADC_EXT_REF_TSOFFSET</a></div><div class="ttdeci">#define ADC_EXT_REF_TSOFFSET</div><div class="ttdef"><b>Definition:</b> adc.h:100</div></div>
<div class="ttc" id="agroup__adc__api_html_gacdf6f073dd1336bc9d4a386155bb53a3"><div class="ttname"><a href="group__adc__api.html#gacdf6f073dd1336bc9d4a386155bb53a3">ADC_EXT_REF_TSSLOPE</a></div><div class="ttdeci">#define ADC_EXT_REF_TSSLOPE</div><div class="ttdef"><b>Definition:</b> adc.h:99</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gae98b8b271e80e2b50de8f852b0e5fe5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae98b8b271e80e2b50de8f852b0e5fe5f">&#9670;&nbsp;</a></span>scInput</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#ga254fedc72090784dcfcdcebebdf3ea39">ADC_SOCNumber</a> <a class="el" href="group__adc__api.html#ga9a99e2014f91f8a1542836553f3345d3">ADC_SafetyCheckerInput</a> scInput</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    uint32_t <a class="code" href="group__adc__api.html#gadcbd2e3dea01e5935b18ea32231cf249">socShift</a></div>
<div class="ttc" id="agroup__adc__api_html_gadcbd2e3dea01e5935b18ea32231cf249"><div class="ttname"><a href="group__adc__api.html#gadcbd2e3dea01e5935b18ea32231cf249">socShift</a></div><div class="ttdeci">socShift</div><div class="ttdef"><b>Definition:</b> adc.h:3827</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gadcbd2e3dea01e5935b18ea32231cf249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcbd2e3dea01e5935b18ea32231cf249">&#9670;&nbsp;</a></span>socShift</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">socShift = ((uint32_t)<a class="el" href="group__adc__api.html#ga89624cc1f9e5146db40bdc1d89e4e1a7">socNumber</a> * 2UL)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gafc980d327c8cc70836562b64b9e417fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc980d327c8cc70836562b64b9e417fe">&#9670;&nbsp;</a></span>checkInst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#gaf0eaff3df07283db317190504ba7433c">ADC_SafetyCheckInst</a> checkInst</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a>(ADC_isSafetyCheckerBaseValid(scBase))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga28ef30ecfe90d113c6b08c15d488ad2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28ef30ecfe90d113c6b08c15d488ad2d">&#9670;&nbsp;</a></span>adcInst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#gaf0eaff3df07283db317190504ba7433c">ADC_SafetyCheckInst</a> <a class="el" href="group__adc__api.html#gaa4f3f8888fe66b3d30d3947bee9dcbe8">ADC_Select</a> adcInst</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gabab7530d7fe5fc6bdb8ccca02cc8f7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabab7530d7fe5fc6bdb8ccca02cc8f7c0">&#9670;&nbsp;</a></span>adcResultInst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#gaf0eaff3df07283db317190504ba7433c">ADC_SafetyCheckInst</a> <a class="el" href="group__adc__api.html#gaa4f3f8888fe66b3d30d3947bee9dcbe8">ADC_Select</a> <a class="el" href="group__adc__api.html#ga0a948430846a59c84370fecfe2547790">ADC_ResultSelect</a> adcResultInst</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a>(ADC_isSafetyCheckerBaseValid(scBase))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga0c2bf3e18f553a6c2d34b58094ba5402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c2bf3e18f553a6c2d34b58094ba5402">&#9670;&nbsp;</a></span>tolerance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t tolerance</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a>(ADC_isSafetyCheckerBaseValid(scBase))</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf6b93c709cbc4bc7f896eb20d9f82f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6b93c709cbc4bc7f896eb20d9f82f70">&#9670;&nbsp;</a></span>checkerNumber</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#ga67bf6616fde2efca32617144cb3f6d52">ADC_Checker</a> checkerNumber</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7a35b7eb8077674ad9084e6ff665f99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a35b7eb8077674ad9084e6ff665f99f">&#9670;&nbsp;</a></span>checkEvent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#ga67bf6616fde2efca32617144cb3f6d52">ADC_Checker</a> <a class="el" href="group__adc__api.html#ga416fb154f5cfd167096b2968caa47a95">ADC_SafetyCheckEvent</a> checkEvent</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf1b4e5b69a7ac95f93c002311a6181c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1b4e5b69a7ac95f93c002311a6181c4">&#9670;&nbsp;</a></span>checkResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#ga67bf6616fde2efca32617144cb3f6d52">ADC_Checker</a> <a class="el" href="group__adc__api.html#gafe93f7735c9ef3508bb48319305ed633">ADC_SafetyCheckResult</a> checkResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a>(ADC_isSafeCheckINTEVTBaseValid(scIntEvtBase))</div>
</div><!-- fragment -->
</div>
</div>
<a id="gae4e0c18e893b7318af14779e8db7fdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4e0c18e893b7318af14779e8db7fdc1">&#9670;&nbsp;</a></span>checkerFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__adc__api.html#ga67bf6616fde2efca32617144cb3f6d52">ADC_Checker</a> <a class="el" href="group__adc__api.html#gaa2e0c6a4e97d9e24868acc6adf7f97af">ADC_SafetyCheckFlag</a> checkerFlag</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__adc__api.html#ga3b0276e379a5a2f071b4794b75bc8411">ASSERT</a>(ADC_isSafeCheckINTEVTBaseValid(scIntEvtBase))</div>
</div><!-- fragment -->
</div>
</div>
<a id="gace198ded246b134826243276d46384a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace198ded246b134826243276d46384a1">&#9670;&nbsp;</a></span>repCount</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t uint16_t repCount</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    uint32_t <a class="code" href="group__adc__api.html#gab84a03b00f3c041fcca9687504b03a6a">regOffset</a></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga84519362cd082e5e863fe652edd18ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84519362cd082e5e863fe652edd18ca9">&#9670;&nbsp;</a></span>repPhase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t uint16_t repPhase</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    uint32_t <a class="code" href="group__adc__api.html#gab84a03b00f3c041fcca9687504b03a6a">regOffset</a></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9bda44d1362c54440a07fd9f77b25be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bda44d1362c54440a07fd9f77b25be8">&#9670;&nbsp;</a></span>repSpread</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t uint16_t repSpread</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    uint32_t <a class="code" href="group__adc__api.html#gab84a03b00f3c041fcca9687504b03a6a">regOffset</a></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
