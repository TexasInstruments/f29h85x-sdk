<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<title>F29H85x-SDK: Flash-based CAN SBL w/ Firmware Over-The-Air</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="F29H85x-SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F29H85x-SDK
   &#160;<span id="projectnumber">1.02.02.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <span id="MSearchSelectExt">&#160;</span>
              <input type="text" id="MSearchField" name="query" value="" placeholder="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('EXAMPLES_DRIVERS_FLASH_BASED_CAN_SBL_WITH_FOTA.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Flash-based CAN SBL w/ Firmware Over-The-Air</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md589">Introduction</a></li>
<li class="level1"><a href="#autotoc_md590">Getting Started</a></li>
<li class="level1"><a href="#autotoc_md591">Software Overview</a><ul><li class="level2"><a href="#autotoc_md592">FOTA Overview</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md593">Build Configurations</a><ul><li class="level2"><a href="#autotoc_md594">Build Options</a></li>
<li class="level2"><a href="#autotoc_md595">Post Build Steps</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md596">Memory Partition</a></li>
<li class="level1"><a href="#autotoc_md597">Initalization Sequence</a></li>
<li class="level1"><a href="#autotoc_md598">Device Setup</a><ul><li class="level2"><a href="#autotoc_md599">CAN Hardware Setup</a></li>
<li class="level2"><a href="#autotoc_md600">CAN Software Setup</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md601">Bootloader Security</a></li>
<li class="level1"><a href="#autotoc_md602">Available commands</a></li>
<li class="level1"><a href="#autotoc_md603">Example demonstration</a></li>
<li class="level1"><a href="#autotoc_md604">Addintional resource</a></li>
<li class="level1"><a href="#autotoc_md605">Help and Support</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_C_1_2anandyk_2C29_2SDK_2source__code_2c29__sdk__docs_2docs__src_2docs_2api__guide_2examples_2drivers_2flash__based__can__sbl"></a></p>
<p>F29x Flash-based CAN SBL w/ FOTA example.</p>
<p>Located in F29H85X-SDK /examples/driverlib/single_core/flash/flash_based_sbl_with_fota</p>
<h1><a class="anchor" id="autotoc_md589"></a>
Introduction</h1>
<p>This example demonstrates a way to program the device whilst running the application, by leveraging the A/B partition (bank swap) functionality of F29H85X-SDK device to achive Firmware Over-The-Air (FOTA), which allows seemless firmware upgrade after a device reset.</p>
<p>The CAN Flash Programmer CLI (can_flash_programmer_appIn.exe) is required to interface with device via CAN. More details are provided in the following sections.</p>
<h1><a class="anchor" id="autotoc_md590"></a>
Getting Started</h1>
<p>To fully understand this example, it is highly recommened to first review the foundational concepts outlined in the <a class="el" href="CAN_FLASH_PROGRAMMER_PAGE.html">CAN Flash Programmer</a> document.</p>
<p>The document covers essential topics such as device lifecycle, firmware update methodologies (DFU,FOTA,LFU) and flash bank modes, which are prerequisites for a complete understanding of this SBL.</p>
<h1><a class="anchor" id="autotoc_md591"></a>
Software Overview</h1>
<p>The Flash-based CAN Secondary Bootloader (SBL) consists of two software components, the bootloader and the application code, both running on the CPU1 core.</p>
<p>The <b>bootloader</b> contains the communication layer to accept requests and exchange information with the flash programmer, as well as the code to execute the requested programming and utility commands.</p>
<p>The <b>application</b>, in this case, is a simple LED-blinking example. The key difference is an additional MCANA receive ISR that flags a global semaphore when the host sends a request. Once the application has handled all interrupts, it can return to its main routine and service the host request by calling the bootloader function. This application code is meant to be replaced by a user application, while retaining the aforementioned changes.</p>
<p>The two components reside and are built as individual projects in CCS or via a Makefile and are merged during the final post-build steps to form a combined CPU1 binary image with appended X.509 certificates.</p>
<h2><a class="anchor" id="autotoc_md592"></a>
FOTA Overview</h2>
<p>At a high level, FOTA is achieved as follows: the host (Flash Programmer CLI) first sends a FOTA command (for CPU1 or CPU3) to the SBL. When an opportunity arises, the running application passes control of the CPU to the bootloader. The bootloader accepts the command and directs the received data to a dormant flash bank (via either CPU or HSM programming). Once complete, the host can send another request to reset the device. Once device resets, during device startup, the ROM handles the bank swap and activates the dormant bank. Finally, the device now boots with the latest firmware in flash boot mode.</p>
<p>FOTA is also available for the HSM flash application, following a similar flow.</p>
<h1><a class="anchor" id="autotoc_md593"></a>
Build Configurations</h1>
<p>The example provides four build configurations, covering two bank modes and two device types:</p>
<table class="doxtable">
<tr>
<th colspan="2">Flash-based SBL build configuration  </th></tr>
<tr>
<td bgcolor="#F0F0F0">BANKMODE1_NONSECURE </td><td>• Bank mode 1 <br  />
 • HS-FS only   </td></tr>
<tr>
<td bgcolor="#F0F0F0">BANKMODE3_NONSECURE </td><td>• Bank mode 3 <br  />
 • HS-FS only   </td></tr>
<tr>
<td bgcolor="#F0F0F0">BANKMODE1_SECURE_CP </td><td>• Bank mode 1 <br  />
 • HS-SE only <br  />
 • Requires HSM flash application (w/ CP services)  </td></tr>
<tr>
<td bgcolor="#F0F0F0">BANKMODE3_SECURE_CP </td><td>• Bank mode 3 <br  />
 • HS-SE only <br  />
 • Requires HSM flash application (w/ CP services)  </td></tr>
</table>
<p>The difference between bank mode configurations is primarily just different linker scripts with respective flash address mappings. However, the difference between nonsecure and secure configurations determines the required device setup and the supported host commands. See the "Device Setup" and "Available Commands" sections for more information.</p>
<p>The nonsecure configurations are only allowed to run on an HS-FS device, where the CPU is permitted to program its flash banks without the HSM. Conversely, the secure configuration must run in HS-SE, where a security configuration (Sec Cfg) is set up and HSM authentications are enabled. Additionally, the HSM flash needs to be programmed with the HSM flash-based runtime to provide HSM services via Secure IPC for all programming operations.</p>
<p>This example limits the scope to flash modes 1 &amp; 3 since FOTA and A/B partitioning rely on the device's bank swap feature. Nonetheless, unsecure programming and secure CP also support directly overwriting active flash banks (DFU) in modes 0 &amp; 2, similar to how the RAM-based SBL functions. Refer to RAM-based SBL on archieving DFU.</p>
<h2><a class="anchor" id="autotoc_md594"></a>
Build Options</h2>
<p>Two build options are provided in the <code>\ccs</code> folder: Importing a CCS project or using a Makefile.</p>
<ul>
<li>CCS project:<ul>
<li>In CCS, click on "Import CCS Projects..." and select "flash_based_can_sbl_with_fota"</li>
<li>The main bootloader project "flash_based_can_sbl_with_fota" and the application project "fota_can_cpu1_application" will be both imported.</li>
<li>Select the bootloader project and choose the desired build configuration.</li>
<li>Build the main bootloader project "flash_based_can_sbl_with_fota", and it will also build the application project as a prerequisite.</li>
</ul>
</li>
<li>Makefile:<ul>
<li>First, make sure all required Makefile dependency paths are properly set up (see <a class="el" href="MAKEFILE_BUILD_PAGE.html">Makefile based Build</a>)</li>
<li>Three makefiles are provided:<ul>
<li>the master project "flash_based_can_sbl.mk"</li>
<li>the bootloader makefile "makefile_can_sbl"</li>
<li>the application makefile "makefile_can_led_blinky"</li>
</ul>
</li>
<li>To build the makefile, within <code>\ccs</code> folder, do:<ul>
<li>For BANKMODE1_NONSECURE config, use<code>Make -f flash_based_can.sbl.mk all</code></li>
<li>For BANKMODE3_NONSECURE config, use <code>Make -f flash_based_can.sbl.mk all BANKMODE=3 APP=NONSECURE</code></li>
<li>For BANKMODE1_SECURE_CP config, use <code>Make -f flash_based_can.sbl.mk all BANKMODE=1 APP=SECURE</code></li>
<li>For BANKMODE3_SECURE_CP config, use <code>Make -f flash_based_can.sbl.mk all BANKMODE=3 APP=SECURE</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md595"></a>
Post Build Steps</h2>
<p>Post-build steps are used in both the bootloader and application projects to merge the two images into one consolidated .out executable and .bin binary image. The flash programmer uses the .bin file, while the .out file can be used for unsecure programming and debugging symbols in CCS.</p>
<p>In both build methods, the application project is always built first to generate the necessary artifacts for the bootloader project.</p>
<p>1) led_blinky application post-build step: </p><div class="fragment"><div class="line">&quot;${CG_TOOL_OBJCOPY} -O binary ${ProjName}.out ../../cpu1_firmware.bin&quot;</div>
</div><!-- fragment --><p> In the application example, the post build simply convert the image into a raw binary that will be merged into the bootloader project.</p>
<p>1) bootloader post-build step: </p><div class="fragment"><div class="line">&quot;</div>
<div class="line">// 1. Update cpu1app section with cpu1 binary content to obtain a combined .out image</div>
<div class="line">${CG_TOOL_OBJCOPY} --update-section cpu1app=../../cpu1_firmware.bin ${ProjName}.out ${ProjName}_firmware.out;</div>
<div class="line">// 2. Produce combine binary without the cert section padding  </div>
<div class="line">${CG_TOOL_OBJCOPY} --remove-section=cert -O binary ${ProjName}_firmware.out ${ProjName}.bin;</div>
<div class="line">// 3. Generate a X.509 certificate with inputted keys and the combined binary</div>
<div class="line">$(PYTHON) ${COM_TI_MCU_SDK_INSTALL_DIR}/tools/boot/signing/mcu_rom_image_gen.py --image-bin ${ProjName}.bin --core C29 --swrv 1 --loadaddr 0x10001000 --sign-key ${COM_TI_MCU_SDK_INSTALL_DIR}/$(SIGNING_KEY) --out-image ${ProjName}.cert.bin --device f29h85x --boot FLASH --img_integ no;</div>
<div class="line">// 4. Update the combined .out with the certificate</div>
<div class="line">${CG_TOOL_OBJCOPY} --update-section cert=C29-cert-pad.bin ${ProjName}_firmware.out ${ProjName}_cert.out;</div>
<div class="line">// 5. delete artifacts and rename the final .out to flash_based_can_sbl_with_fota.out</div>
<div class="line">$(DELETE) ${ProjName}.out C29-cert-pad.bin;</div>
<div class="line">$(RENAME) ${ProjName}_cert.out ${ProjName}.out;</div>
<div class="line">// 6. Produce the final binary image with combined projects and prepended certificate (flash_based_can_sbl_with_fota.bin)</div>
<div class="line">${CG_TOOL_OBJCOPY} -O binary ${ProjName}.out ${ProjName}.bin</div>
<div class="line">&quot;</div>
</div><!-- fragment --><p> The steps are annotated above. Note that in step 3, the chosen key and algorithm (&ndash;sign-key) are irrelevant for unsecure build configurations since no boot authentication is performed in HS-FS. However, this is enforced in the HS-SE/secure configuration with addintional supported features such as SBL image encryption. Refer to the Python script for more optional parameters that can be used for the secure configuration.</p>
<p>/note The final combined ELF file (flash_based_can_sbl_with_fota.out) does not contain symbolic information (e.g., DWARF debug symbols) for the application project. Therefore, the application's .out needs to be loaded separately when debugging application code.</p>
<div class="fragment"><div class="line">flash_based_can_sbl.c</div>
<div class="line"> </div>
<div class="line">__attribute__((retain, section(&quot;cpu1app&quot;)))</div>
<div class="line">const uint8_t cpu1appData[] = </div>
<div class="line">{</div>
<div class="line">    //</div>
<div class="line">    // ONLY for obtaining the size of cpu1app in the program header of the generated .out</div>
<div class="line">    // actual content will be inserted in post-build step</div>
<div class="line">    //</div>
<div class="line">    #embed &quot;../../cpu1_firmware.bin&quot; </div>
<div class="line">};</div>
</div><!-- fragment --><p> Lastly, a C23 directive <code>#embed</code> is used to dynamically update the ELF program header with the size of cpu1app. This directive may not be ideal due to its alpha compiler support and lack of C++ support (expected in C++26). Its sole intention is to retain program sections when programming the .out file in CCS Flash or Uniflash for unsecure configurations; it does not affect the .bin file used by SBLs for secure or production builds.</p>
<p>As such, feel free to remove cpu1appData[] and use fillings in the linker script instead to achieve the same result.</p>
<div class="fragment"><div class="line">bankmode_flash_sbl_cpu1.cmd</div>
<div class="line"> </div>
<div class="line">// Change 0xE8000 to the maximum size of cpu1app (size of CPU1_FLASH_APP) </div>
<div class="line">// or if .out programming is used, just more than the size of application image </div>
<div class="line">cpu1app      : { . = . + 0xE8000; } &gt; APP1_ENTRY,  FILL=0xFF, START(app1EntryAddr)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md596"></a>
Memory Partition</h1>
<p>Since the bootloader and CPU1 application run on the same core and share memory, a RAM and Flash boundary is needed to separate them. The memory reserved by the bootloader is listed below; other sections can be freely used by other applications:</p>
<p><b>RAM Partition</b>:</p><ul>
<li>LDA 1 and 0 are reserved to the bootloader, LDA 2-7 can be used by HSM, CPU 1 &amp; 2 application</li>
<li>LPAx are not used by bootloader, can be shared across CPU 1 &amp; 2 application</li>
<li>CPAx are not used by bootloader, can be shared across CPU 1 &amp; 3 application</li>
<li>CDA 10 and 11 are reserved to the bootloader, CDA 0-9 can be shared across CPU 1 &amp; 3 application</li>
</ul>
<p>Note that of the RAM reserved by the bootloader, LDA1 and CDA10/11 are used as a scratchpad for receiving host data. This means other applications can use this memory while the bootloader is inactive, as long as the memory is disabled for other applications while the bootloader is actively receiving data from the host.</p>
<p><b>Flash Partition</b>:</p><ul>
<li>bootloader reserves the beginning 98K bytes, including the flash entry point<ul>
<li>4096 bytes of certificate space + 94K code space starting from the flash entry point (0x10001000)</li>
<li>Rest of CPU1 Flash are left for CPU1 application. With CPU1 application entry point (0x10018000) at the end of bootloader partition space</li>
</ul>
</li>
</ul>
<p>The bootloader flash size is reconfigurable in the linker script. The <em><code>APP1_ENTRY</code></em> macro address must be adjusted in <b>both</b> the bootloader and application linker scripts to reflect the new end address of the bootloader partition.</p>
<h1><a class="anchor" id="autotoc_md597"></a>
Initalization Sequence</h1>
<p>The flash-based SBL is expected to be run in flash boot, and follows this initalization steps:</p>
<ol type="1">
<li>ROM branches into flash entry address</li>
<li>Bootloader codestart is called, initializing the bootloader stack and RAM data</li>
<li>Bootloader device and board init are called to initalize peripherial settings from syscfg</li>
<li>(If firmware is valid) Bootloader branches into CPU1 application entry address</li>
<li>CPU1 application codestart is called, initializing the application stack and RAM data<ul>
<li>(Optional)<sup>1,2</sup> CPU2 contents are copied from Flash to RAM via CopyTable in BINIT or manual memcpy</li>
</ul>
</li>
<li>Application device and board init are called to initalize peripherial settings from syscfg<ul>
<li>(Optional)<sup>1,2</sup> Configures CPU2 reset and nmi vector, and activiates CPU2 core</li>
<li>(Optional)<sup>1,2</sup> Configures CPU3 reset and nmi vector, and activiates CPU3 core</li>
</ul>
</li>
</ol>
<p>The bootloader and CPU1 application both perform peripheral initialization (steps 5 &amp; 6). Therefore, core peripherals shared between the two (DPL, ESM, and CAN) must have the same syscfg settings, with the exception of the CAN receive ISR in the CPU1 application, as mentioned previously.</p>
<p>In a production program, one might consider reducing redundant peripheral initializations to speed up boot time.</p>
<p>If a custom NMI ISR is desired, ensure it is configured in only one place. For instance, if the CPU1 application relies on DPL, it is recommended to set the NMI ISR within the CPU1 application, as DPL initialization resets the interrupt vector table.</p>
<blockquote class="doxtable">
<p>&zwj;1. The optional steps describe the procedures for CPU1 to prepare and activate the CPU2/3 cores. Although these steps are not part of the Flash-based SBL example, users are encouraged to integrate them from other multi-core examples (see <a class="el" href="EXAMPLES_DRIVERS_LED_EX2_BLINKY_CPU1_CPU2_CPU3_MULTI.html">LED Blinky - CPU1/ CPU2/ CPU3</a>) </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;2. CPU2 &amp; 3 bring-up can also be part of the bootloader initialization (steps 2 &amp; 3) or the bootloader initialization (steps 5 &amp; 6). </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md598"></a>
Device Setup</h1>
<p>Some initial device setup is required to run the Flash-based SBL example. As mentioned in the build configuration section, the device needs to be in the appropriate bank mode and device type, and have the Flash-based SBL binary programmed into the CPU1 flash. All of this can be accomplished using the RAM-based SBL.</p>
<p>The RAM-based SBL is used to convert the device, set the bank mode, and flash all required binaries. RAM-based SBLs (supporting CAN, CAN, or JTAG) are the only method to convert the device and perform secure programming prior to using the Flash-based SBL.</p>
<p>To summarize, the prerequisites to run the Flash-based SBL are as follows:</p>
<table class="doxtable">
<caption>Flash-based SBL prerequisites </caption>
<tr>
<th>Configuration </th><th>Setup  </th></tr>
<tr>
<td bgcolor="#F0F0F0">BANKMODE1_NONSECURE <br  />
 BANKMODE3_NONSECURE  </td><td>• Device in HS-FS <br  />
 • Flash bank mode 1/3 <br  />
 • Flash-based SBL programmed in CPU1 flash <br  />
 • Device in flash boot mode   </td></tr>
<tr>
<td bgcolor="#F0F0F0">BANKMODE1_SECURE_CP <br  />
 BANKMODE3_SECURE_CP  </td><td>• Device in HS-SE <br  />
 • Flash bank mode 1/3 <br  />
 • Flash-based SBL programmed in CPU1 flash <br  />
 • HSM CP services are programmed to HSM flash <br  />
 • Device in flash boot mode   </td></tr>
</table>
<p>The command to flash unsecure CPU1 flash in Flash Programer is "CPU1 DFU/FOTA (HS-FS only)", and "Load C29 CPU1 Image" for the secure configuration.</p>
<p>On the RAM-based SBL operation sequence to ensure a complete device bring-up for the secure configuration, see "Device Bringup" in <a class="el" href="EXAMPLES_DRIVERS_RAM_BASED_UART_SBL.html">RAM-based UART SBL</a>.</p>
<h2><a class="anchor" id="autotoc_md599"></a>
CAN Hardware Setup</h2>
<p>The SBL CAN RX/TX pins are mapped to GPIO 65/64, which are also the default pins for CAN/CAN-FD boot and the RAM-based CAN SBL in F29H85x .</p>
<ul>
<li>On the <b>F29H85x SOM</b>, the pins are routed to EtherCAT by default, it requires a resolder of 0-ohm shunt resistors to reroute GPIO 65/64 pins. Addintionally, SOM doesn't have a XTAL but X1 oscillator instead. Therefore, X1 must be selected as a MCAN clock source.<ul>
<li>See SOM Schematic for the MCAN-A boot support instruction</li>
</ul>
</li>
<li>On the <b>F29H85x Launchpad</b>, GPIO 65/64 can be routed to a built-in CAN transceiver with CAN-L/H/GND pinout (J14) when CAN ROUTE switch (S4) is ON. Alternatively, GPIO 65/64 are exposed as standard GPIO headers for external CAN transceiver, if the CAN ROUTE switch is toggled off.</li>
</ul>
<p>Therefore, for F29H85x , Launchpad is recommended to development CAN solutions due to a built-in CAN transceiver and less cumbersome setup.</p>
<dl class="section note"><dt>Note</dt><dd>In addintion, according to the device TRM, CAN requires XTAL as its clock source due to protocol's strict timing requirements. Nonetheless, the SBL example used INTOSC2 as the clock source to be compatible across various board designs. While it works without any issues in testing, it should be switched to XTAL in sysconfig in production software.</dd></dl>
<h2><a class="anchor" id="autotoc_md600"></a>
CAN Software Setup</h2>
<p>In this example, the CAN configuration uses the same bitrate as CAN-FD boot:</p><ul>
<li>CAN-FD enabled</li>
<li>1 Mbps nomial bitrate</li>
<li>2 Mbps data bitrate</li>
</ul>
<p>The device's MCAN-A module reserves Rx FIFO0 exclusively for the bootloader, leaving Rx FIFO1 and Rx buffer for application use.</p>
<p>Rx FIFO0 is configured to only accept CAN frames with a ID between 0x0 and 0xF in standard/extended format. It accepts any non-matching frames into Rx FIFO1, and rejects any remote frames. The CAN Flash Programmer sends all of its frames with an ID of 0xF.</p>
<p>The filtering rules can be changed in sysconfig settings by adjusting the MCAN-A filter elements. The user is encouraged to add more filter elements, such as rules to store in Rx FIFO1 and Rx Buffer, to make use of them in the application space.</p>
<p>Similarly, the bootloader sends its CAN frame with an extended ID of 0x4 via Tx FIF0, with 24 of the 32 MCANA Tx Message RAM allocated as FIFO, and the rest 8 as a dedicated Tx buffer. The application may feel free to use any of the Tx buffers, or the Tx FIFO, long as the user can make sure FIFO don't get overfilled. The CAN flash programmer didn't have any frame rejection rules to accommodate this, but it can be easily added in CAN_Interface.h using PCAN-basic API.</p>
<div class="fragment"><div class="line">Transmit frame settings in</div>
<div class="line">sbl_packet_can_abstraction.c</div>
<div class="line"> </div>
<div class="line">    mcanIntf.txMsg.id       = ((uint32_t)(0x4)) &lt;&lt; 18U; // Identifier Value. 0x4 in extended frame format</div>
<div class="line">    mcanIntf.txMsg.rtr      = 0U; // Transmit data frame.</div>
<div class="line">    mcanIntf.txMsg.xtd      = 0U; // 11-bit standard identifier.</div>
<div class="line">    mcanIntf.txMsg.esi      = 0U; // ESI bit in CAN FD format depends only on error</div>
<div class="line">                                  // passive flag.</div>
<div class="line">    mcanIntf.txMsg.brs      = 1U; // CAN FD frames transmitted with bit rate</div>
<div class="line">                                  // switching.</div>
<div class="line">    mcanIntf.txMsg.fdf      = 1U; // Frame transmitted in CAN FD format.</div>
<div class="line">    mcanIntf.txMsg.efc      = 1U; // Store Tx events.</div>
<div class="line">    mcanIntf.txMsg.mm       = 0xAAU; // Message Marker.</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md601"></a>
Bootloader Security</h1>
<p>From the application's perspective, <em><code>cmdJumpTable()</code></em> serves as an entry point into the bootloader code. The function itself is decorated with <em><code>__attribute__((c29_protected_call))</code></em>, which clears all registers upon being called. This allows the application to call the function regardless of SSU Stack/Zone settings, effectively isolating the bootloader code from the application and making no assumptions about the application's memory security layout.</p>
<p>If SSU Mode 3 is enabled, ensure all bootloader code maps to LINK1.</p>
<h1><a class="anchor" id="autotoc_md602"></a>
Available commands</h1>
<p>The list below shows the commands supported by the CAN Flash Programmer for the Flash-based CAN SBL:</p>
<p><b>Unsecure</b>:</p><ul>
<li>CPU1 DFU/FOTA</li>
<li>CPU3 DFU/FOTA</li>
<li>Set Bankmode 0</li>
<li>Set Bankmode 1</li>
<li>Set Bankmode 2</li>
<li>Set Bankmode 3<ul>
<li>Note: all bankmode commands are for development only, as data integrity is not preserved after a mode switch. It is recommended to switch the bank mode prior to any programming operation.</li>
</ul>
</li>
</ul>
<p><b>Secure (CP)</b>:</p><ul>
<li>Program Sec Cfg</li>
<li>Load HSM Flash Image</li>
<li>Load C29 CPU1 Image</li>
<li>Load C29 CPU3 Image</li>
</ul>
<p><b>Utility commands</b>:</p><ul>
<li>Sync Device Status</li>
<li>Get SocID Info</li>
<li>Get Boot ROM Status</li>
<li>Run CPU3</li>
<li>Reset CPU1</li>
<li>Configure CAN Baud Rate</li>
</ul>
<h1><a class="anchor" id="autotoc_md603"></a>
Example demonstration</h1>
<p>To quickly run the example and demonstrate the FOTA functionality, you can prepare two versions of the Flash-based SBL, each with a different LED switch period (e.g., one with the default 2-second period and another with a 0.2-second period).</p>
<div class="fragment"><div class="line">CAN_led_blinky_cpu1.c</div>
<div class="line"> </div>
<div class="line">    //</div>
<div class="line">    // Set up free running periodic call backs via ClockP</div>
<div class="line">    // Note: In free running (timout = period)</div>
<div class="line">    //</div>
<div class="line">    ClockP_Params       ledClkPrms;</div>
<div class="line">    ClockP_Params_init(&amp;ledClkPrms);</div>
<div class="line">    ledClkPrms.start       = false;</div>
<div class="line">    ledClkPrms.timeout     = ClockP_usecToTicks(2 * 1000000U);</div>
<div class="line">    ledClkPrms.period      = ClockP_usecToTicks(2 * 1000000U); // 2sec period</div>
<div class="line">    ledClkPrms.callback    = &amp;blinkyLedCb;</div>
<div class="line">    ClockP_construct(&amp;gblinkyLedClk, &amp;ledClkPrms);</div>
<div class="line">    ClockP_start(&amp;gblinkyLedClk);</div>
</div><!-- fragment --><p>A. Preparation:</p>
<p>First, prepare the device as mentioned in "Device Setup" section, use the Flash-based SBL image with a slower LED blinky to program the CPU1 flash first.</p>
<p>B. Run the CAN Flash Programmer</p>
<ol type="1">
<li>Power on the device in flash boot, the device should be up &amp; running the first Flash-based SBL image that has the slower LED blinky.</li>
<li>In a terminal, run the following commands:<ul>
<li>nonsecure: <code>CAN_flash_programmer_appIn.exe -d f29h85x --appcpu1 &lt;second flash-based SBL img&gt;</code></li>
<li>secure: <code>CAN_flash_programmer_appIn.exe -d f29h85x --cpappcpu1 &lt;second flash-based SBL img&gt;</code></li>
</ul>
</li>
<li><p class="startli">(Optional) The CLI will ask for operations to take place, select <b>Sync Device Status</b>. And host should receive a message indicating both bootloader &amp; application is running.</p>
<p class="startli"> <style>div.image img[src="flash_sbl_sync_status.png"]{width:80%}</style> </p><div class="image">
<img src="flash_sbl_sync_status.png" alt=""/>
<div class="caption">
Sync Status Message</div></div>
</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>If the sync status message didn't mention the application &amp; LED isn't blinky. It's a indication that bootloader couldn't verify the application and therefore did not handover the control to the application. In this case, select command "Run CPU1" to force the bootloader branch to the application address. <br  />
</dd></dl>
<p> <style>div.image img[src="flash_sbl_sync_status_noapp.png"]{width:60%}</style> </p><div class="image">
<img src="flash_sbl_sync_status_noapp.png" alt=""/>
<div class="caption">
Sync Status without Application Message</div></div>
<ol type="1">
<li>Next, select the command to program FOTA<ul>
<li>command for nonsecure: "CPU1 DFU/FOTA (HS-FS only)"</li>
<li>command for secure: "Load CPU1 Flash Image (HS-SE Code Provision)"</li>
<li>LED still blinks whilst programming operation takes place.</li>
</ul>
</li>
<li>Once done with programming all FOTA images, select <b>Reset CPU1</b><ul>
<li>Reset CPU1 is a command to invoke CPU1.WDRSn and reset the device <br  />
</li>
</ul>
</li>
</ol>
<p>B. Verification:</p>
<p>Now the device should have the new firmware running, it can be observed visually by the change in LED blinky frequency.</p>
<p>Alternately, user can also send a "Get Boot ROM Status" command and see the CPU1 bank swap has been transitioned from "Default Swap" to "Alternative Swap" (or vice-versa) and the CPU1 bank management address has changed.</p>
<p> <style>div.image img[src="flash_sbl_bankswap.png"]{width:80%}</style> </p><div class="image">
<img src="flash_sbl_bankswap.png" alt=""/>
<div class="caption">
BROM Status SSU Status</div></div>
<h1><a class="anchor" id="autotoc_md604"></a>
Addintional resource</h1>
<ul>
<li>Refer to <a href="https://www.ti.com/lit/SPRADS1">Flash-Based Firmware Over-The-Air (FOTA) Example on F29H85x</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md605"></a>
Help and Support</h1>
<p>For additional help and support, please visit <a href="https://e2e.ti.com/support/microcontrollers/c2000-microcontrollers-group/c2000/f/c2000-microcontrollers-forum" target="_blank"><em>E2E™ design support forum</em></a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
